{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n// eslint-disable-next-line import/no-internal-modules\nimport cloneDeep from \"lodash/cloneDeep\";\nimport { readAndParse } from \"@fluidframework/driver-utils\";\nimport { CreateContainerError } from \"@fluidframework/container-utils\";\nimport { assert, Lazy } from \"@fluidframework/common-utils\";\nimport { createServiceEndpoints, summarizeChannel } from \"./channelContext\";\n/**\n * Channel context for a locally created channel\n */\nexport class LocalChannelContext {\n  constructor(id, registry, type, runtime, dataStoreContext, storageService, submitFn, dirtyFn, snapshotTree) {\n    this.id = id;\n    this.runtime = runtime;\n    this.dataStoreContext = dataStoreContext;\n    this.storageService = storageService;\n    this.submitFn = submitFn;\n    this.snapshotTree = snapshotTree;\n    this.attached = false;\n    this.pending = [];\n    let blobMap;\n    const clonedSnapshotTree = cloneDeep(this.snapshotTree);\n    if (clonedSnapshotTree !== undefined) {\n      blobMap = new Map();\n      this.collectExtraBlobsAndSanitizeSnapshot(clonedSnapshotTree, blobMap);\n    }\n    this.services = new Lazy(() => {\n      return createServiceEndpoints(this.id, this.dataStoreContext.connected, this.submitFn, this.dirtyFn, this.storageService, clonedSnapshotTree, blobMap);\n    });\n    this.factory = registry.get(type);\n    if (this.factory === undefined) {\n      throw new Error(`Channel Factory ${type} not registered`);\n    }\n    if (snapshotTree === undefined) {\n      this.channel = this.factory.create(runtime, id);\n    }\n    this.dirtyFn = () => {\n      dirtyFn(id);\n    };\n  }\n  getChannel() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (_this.channel === undefined) {\n        _this.channel = yield _this.loadChannel();\n      }\n      return _this.channel;\n    })();\n  }\n  get isLoaded() {\n    return this.channel !== undefined;\n  }\n  setConnectionState(connected, clientId) {\n    // Connection events are ignored if the data store is not yet attached or loaded\n    if (this.attached && this.isLoaded) {\n      this.services.value.deltaConnection.setConnectionState(connected);\n    }\n  }\n  processOp(message, local, localOpMetadata) {\n    assert(this.attached, \"Local channel must be attached when processing op\");\n    // A local channel may not be loaded in case where we rehydrate the container from a snapshot because of\n    // delay loading. So after the container is attached and some other client joins which start generating\n    // ops for this channel. So not loaded local channel can still receive ops and we store them to process later.\n    if (this.isLoaded) {\n      this.services.value.deltaConnection.process(message, local, localOpMetadata);\n    } else {\n      assert(local === false, \"Should always be remote because a local dds shouldn't generate ops before loading\");\n      this.pending.push(message);\n    }\n  }\n  reSubmit(content, localOpMetadata) {\n    assert(this.isLoaded, \"Channel should be loaded to resubmit ops\");\n    assert(this.attached, \"Local channel must be attached when resubmitting op\");\n    this.services.value.deltaConnection.reSubmit(content, localOpMetadata);\n  }\n  /**\n   * Returns a summary at the current sequence number.\n   * @param fullTree - true to bypass optimizations and force a full summary tree\n   * @param trackState - This tells whether we should track state from this summary.\n   */\n  summarize(fullTree = false, trackState = false) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      assert(_this2.isLoaded && _this2.channel !== undefined, \"Channel should be loaded to summarize\");\n      return summarizeChannel(_this2.channel, fullTree, trackState);\n    })();\n  }\n  getAttachSummary() {\n    assert(this.isLoaded && this.channel !== undefined, \"Channel should be loaded to take snapshot\");\n    return summarizeChannel(this.channel, true /* fullTree */, false /* trackState */);\n  }\n\n  loadChannel() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      assert(!_this3.isLoaded, \"Channel must not already be loaded when loading\");\n      assert(!!_this3.snapshotTree, \"Snapshot should be provided to load from!!\");\n      assert(yield _this3.services.value.objectStorage.contains(\".attributes\"), \".attributes blob should be present\");\n      const attributes = yield readAndParse(_this3.services.value.objectStorage, \".attributes\");\n      assert(!!_this3.factory, \"Factory should be there for local channel\");\n      // Services will be assigned during this load.\n      const channel = yield _this3.factory.load(_this3.runtime, _this3.id, _this3.services.value, attributes);\n      // Commit changes.\n      _this3.channel = channel;\n      // Send all pending messages to the channel\n      for (const message of _this3.pending) {\n        try {\n          _this3.services.value.deltaConnection.process(message, false, undefined /* localOpMetadata */);\n        } catch (err) {\n          // record sequence number for easier debugging\n          const error = CreateContainerError(err);\n          error.sequenceNumber = message.sequenceNumber;\n          throw error;\n        }\n      }\n      return _this3.channel;\n    })();\n  }\n  markAttached() {\n    if (this.attached) {\n      throw new Error(\"Channel is already attached\");\n    }\n    if (this.isLoaded) {\n      assert(!!this.channel, \"Channel should be there if loaded!!\");\n      this.channel.connect(this.services.value);\n    }\n    this.attached = true;\n  }\n  collectExtraBlobsAndSanitizeSnapshot(snapshotTree, blobMap) {\n    const blobMapInitial = new Map(Object.entries(snapshotTree.blobs));\n    for (const [blobName, blobId] of blobMapInitial.entries()) {\n      const blobValue = blobMapInitial.get(blobId);\n      if (blobValue !== undefined) {\n        blobMap.set(blobId, blobValue);\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete snapshotTree.blobs[blobName];\n      }\n    }\n    for (const value of Object.values(snapshotTree.trees)) {\n      this.collectExtraBlobsAndSanitizeSnapshot(value, blobMap);\n    }\n  }\n  getGCData() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      assert(_this4.isLoaded && _this4.channel !== undefined, \"Channel should be loaded to run GC\");\n      return _this4.channel.getGCData();\n    })();\n  }\n}\n//# sourceMappingURL=localChannelContext.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}