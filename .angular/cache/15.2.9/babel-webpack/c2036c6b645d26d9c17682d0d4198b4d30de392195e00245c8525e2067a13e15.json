{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { v4 as uuid } from \"uuid\";\nimport { ContainerErrorType } from \"@fluidframework/container-definitions\";\nimport { assert, performance, TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport { PerformanceEvent, TelemetryLogger, safeRaiseEvent } from \"@fluidframework/telemetry-utils\";\nimport { LoaderCachingPolicy } from \"@fluidframework/driver-definitions\";\nimport { isSystemType, isSystemMessage } from \"@fluidframework/protocol-base\";\nimport { MessageType, ScopeType } from \"@fluidframework/protocol-definitions\";\nimport { canRetryOnError, createWriteError, createGenericNetworkError } from \"@fluidframework/driver-utils\";\nimport { CreateContainerError, DataCorruptionError } from \"@fluidframework/container-utils\";\nimport { debug } from \"./debug\";\nimport { DeltaQueue } from \"./deltaQueue\";\nimport { logNetworkFailure, waitForConnectedState } from \"./networkUtils\";\nimport { RetriableDocumentStorageService } from \"./retriableDocumentStorageService\";\nimport { PrefetchDocumentStorageService } from \"./prefetchDocumentStorageService\";\nconst MaxReconnectDelaySeconds = 8;\nconst InitialReconnectDelaySeconds = 1;\nconst MissingFetchDelaySeconds = 0.1;\nconst MaxFetchDelaySeconds = 10;\nconst MaxBatchDeltas = 2000;\nconst DefaultChunkSize = 16 * 1024;\n// This can be anything other than null\nconst ImmediateNoOpResponse = \"\";\n// eslint-disable-next-line @typescript-eslint/no-unsafe-return\nexport const getRetryDelayFromError = error => {\n  var _a;\n  return (_a = error) === null || _a === void 0 ? void 0 : _a.retryAfterSeconds;\n};\nfunction getNackReconnectInfo(nackContent) {\n  const reason = `Nack: ${nackContent.message}`;\n  const canRetry = nackContent.code !== 403;\n  return createGenericNetworkError(reason, canRetry, nackContent.retryAfter, nackContent.code);\n}\nfunction createReconnectError(prefix, err) {\n  const error = CreateContainerError(err);\n  const error2 = Object.create(error);\n  error2.message = `${prefix}: ${error.message}`;\n  error2.canRetry = true;\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  return error2;\n}\nexport var ReconnectMode = /*#__PURE__*/(() => {\n  (function (ReconnectMode) {\n    ReconnectMode[\"Never\"] = \"Never\";\n    ReconnectMode[\"Disabled\"] = \"Disabled\";\n    ReconnectMode[\"Enabled\"] = \"Enabled\";\n  })(ReconnectMode || (ReconnectMode = {}));\n  return ReconnectMode;\n})();\n/**\n * Manages the flow of both inbound and outbound messages. This class ensures that shared objects receive delta\n * messages in order regardless of possible network conditions or timings causing out of order delivery.\n */\nexport class DeltaManager extends TypedEventEmitter {\n  constructor(serviceProvider, client, logger, reconnectAllowed) {\n    super();\n    this.serviceProvider = serviceProvider;\n    this.client = client;\n    this.logger = logger;\n    // tracks host requiring read-only mode.\n    this._forceReadonly = false;\n    this.pending = [];\n    this.fetching = false;\n    this.inQuorum = false;\n    // The minimum sequence number and last sequence number received from the server\n    this.minSequenceNumber = 0;\n    // There are three numbers we track\n    // * lastQueuedSequenceNumber is the last queued sequence number. If there are gaps in seq numbers, then this number\n    //   is not updated until we cover that gap, so it increases each time by 1.\n    // * lastObservedSeqNumber is  an estimation of last known sequence number for container in storage. It's initially\n    //   populated at web socket connection time (if storage provides that info) and is  updated once ops shows up.\n    //   It's never less than lastQueuedSequenceNumber\n    // * lastProcessedSequenceNumber - last processed sequence number\n    this.lastQueuedSequenceNumber = 0;\n    this.lastObservedSeqNumber = 0;\n    this.lastProcessedSequenceNumber = 0;\n    this.baseTerm = 0;\n    // The sequence number we initially loaded from\n    this.initSequenceNumber = 0;\n    this.clientSequenceNumber = 0;\n    this.clientSequenceNumberObserved = 0;\n    this.closed = false;\n    this.deltaStreamDelayId = uuid();\n    this.deltaStorageDelayId = uuid();\n    this.messageBuffer = [];\n    this.connectFirstConnection = true;\n    this.throttlingIdSet = new Set();\n    this.timeTillThrottling = 0;\n    // True if current connection has checkpoint information\n    // I.e. we know how far behind the client was at the time of establishing connection\n    this._hasCheckpointSequenceNumber = false;\n    this.opHandler = (documentId, messages) => {\n      if (messages instanceof Array) {\n        this.enqueueMessages(messages);\n      } else {\n        this.enqueueMessages([messages]);\n      }\n    };\n    this.signalHandler = message => {\n      this._inboundSignal.push(message);\n    };\n    // Always connect in write mode after getting nacked.\n    this.nackHandler = (documentId, messages) => {\n      const message = messages[0];\n      // TODO: we should remove this check when service updates?\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      if (this._readonlyPermissions) {\n        this.close(createWriteError(\"WriteOnReadOnlyDocument\"));\n      }\n      // check message.content for Back-compat with old service.\n      const reconnectInfo = message.content !== undefined ? getNackReconnectInfo(message.content) : createGenericNetworkError(`Nack: unknown reason`, true);\n      if (this.reconnectMode !== ReconnectMode.Enabled) {\n        this.logger.sendErrorEvent({\n          eventName: \"NackWithNoReconnect\",\n          reason: reconnectInfo.message,\n          mode: this.connectionMode\n        });\n      }\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.reconnectOnError(\"write\", reconnectInfo);\n    };\n    // Connection mode is always read on disconnect/error unless the system mode was write.\n    this.disconnectHandler = disconnectReason => {\n      // Note: we might get multiple disconnect calls on same socket, as early disconnect notification\n      // (\"server_disconnect\", ODSP-specific) is mapped to \"disconnect\"\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.reconnectOnError(this.defaultReconnectionMode, createReconnectError(\"Disconnect\", disconnectReason));\n    };\n    this.errorHandler = error => {\n      // Observation based on early pre-production telemetry:\n      // We are getting transport errors from WebSocket here, right before or after \"disconnect\".\n      // This happens only in Firefox.\n      logNetworkFailure(this.logger, {\n        eventName: \"DeltaConnectionError\"\n      }, error);\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.reconnectOnError(this.defaultReconnectionMode, createReconnectError(\"error\", error));\n    };\n    this.pongHandler = latency => {\n      this.emit(\"pong\", latency);\n    };\n    this.clientDetails = this.client.details;\n    this.defaultReconnectionMode = this.client.mode;\n    this._reconnectMode = reconnectAllowed ? ReconnectMode.Enabled : ReconnectMode.Never;\n    this._inbound = new DeltaQueue(op => {\n      this.processInboundMessage(op);\n    });\n    this._inbound.on(\"error\", error => {\n      this.close(CreateContainerError(error));\n    });\n    // Outbound message queue. The outbound queue is represented as a queue of an array of ops. Ops contained\n    // within an array *must* fit within the maxMessageSize and are guaranteed to be ordered sequentially.\n    this._outbound = new DeltaQueue(messages => {\n      if (this.connection === undefined) {\n        throw new Error(\"Attempted to submit an outbound message without connection\");\n      }\n      this.connection.submit(messages);\n    });\n    this._outbound.on(\"error\", error => {\n      this.close(CreateContainerError(error));\n    });\n    // Inbound signal queue\n    this._inboundSignal = new DeltaQueue(message => {\n      if (this.handler === undefined) {\n        throw new Error(\"Attempted to process an inbound signal without a handler attached\");\n      }\n      this.handler.processSignal({\n        clientId: message.clientId,\n        content: JSON.parse(message.content)\n      });\n    });\n    this._inboundSignal.on(\"error\", error => {\n      this.close(CreateContainerError(error));\n    });\n    // Require the user to start the processing\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this._inbound.pause();\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this._outbound.pause();\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this._inboundSignal.pause();\n  }\n  get disposed() {\n    return this.closed;\n  }\n  get IDeltaSender() {\n    return this;\n  }\n  /**\n   * Tells if  current connection has checkpoint information.\n   * I.e. we know how far behind the client was at the time of establishing connection\n   */\n  get hasCheckpointSequenceNumber() {\n    // Valid to be called only if we have active connection.\n    assert(this.connection !== undefined);\n    return this._hasCheckpointSequenceNumber;\n  }\n  get inbound() {\n    return this._inbound;\n  }\n  get outbound() {\n    return this._outbound;\n  }\n  get inboundSignal() {\n    return this._inboundSignal;\n  }\n  get initialSequenceNumber() {\n    return this.initSequenceNumber;\n  }\n  get lastSequenceNumber() {\n    return this.lastProcessedSequenceNumber;\n  }\n  get lastKnownSeqNumber() {\n    return this.lastObservedSeqNumber;\n  }\n  get referenceTerm() {\n    return this.baseTerm;\n  }\n  get minimumSequenceNumber() {\n    return this.minSequenceNumber;\n  }\n  get maxMessageSize() {\n    var _a, _b, _c, _d, _e;\n    return _e = (_c = (_b = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.serviceConfiguration) === null || _b === void 0 ? void 0 : _b.maxMessageSize, _c !== null && _c !== void 0 ? _c : (_d = this.connection) === null || _d === void 0 ? void 0 : _d.maxMessageSize), _e !== null && _e !== void 0 ? _e : DefaultChunkSize;\n  }\n  get version() {\n    if (this.connection === undefined) {\n      throw new Error(\"Cannot check version without a connection\");\n    }\n    return this.connection.version;\n  }\n  get serviceConfiguration() {\n    var _a;\n    return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.serviceConfiguration;\n  }\n  get scopes() {\n    var _a;\n    return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.claims.scopes;\n  }\n  get active() {\n    const res = this.inQuorum && this.connectionMode === \"write\";\n    // user can't have r/w connection when user has only read permissions.\n    // That said, connection can be r/w when host called forceReadonly(), as\n    // this is view-only change\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    assert(!(this._readonlyPermissions && res));\n    return res;\n  }\n  get socketDocumentId() {\n    var _a;\n    return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.claims.documentId;\n  }\n  /**\n   * The current connection mode, initially read.\n   */\n  get connectionMode() {\n    if (this.connection === undefined) {\n      return \"read\";\n    }\n    return this.connection.mode;\n  }\n  /**\n   * Tells if container is in read-only mode.\n   * Data stores should listen for \"readonly\" notifications and disallow user\n   * making changes to data stores.\n   * Readonly state can be because of no storage write permission,\n   * or due to host forcing readonly mode for container.\n   * It is undefined if we have not yet established websocket connection\n   * and do not know if user has write access to a file.\n   */\n  get readonly() {\n    if (this._forceReadonly) {\n      return true;\n    }\n    return this._readonlyPermissions;\n  }\n  /**\n   * Tells if user has no write permissions for file in storage\n   * It is undefined if we have not yet established websocket connection\n   * and do not know if user has write access to a file.\n   */\n  get readonlyPermissions() {\n    return this._readonlyPermissions;\n  }\n  /**\n   * Automatic reconnecting enabled or disabled.\n   * If set to Never, then reconnecting will never be allowed.\n   */\n  get reconnectMode() {\n    return this._reconnectMode;\n  }\n  connectToStorage() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      if (_this.storageService !== undefined) {\n        return _this.storageService;\n      }\n      const service = _this.serviceProvider();\n      if (service === undefined) {\n        throw new Error(\"Not attached\");\n      }\n      let storageService = yield service.connectToStorage();\n      // Enable prefetching for the service unless it has a caching policy set otherwise:\n      if (((_a = service.policies) === null || _a === void 0 ? void 0 : _a.caching) !== LoaderCachingPolicy.NoCaching) {\n        storageService = new PrefetchDocumentStorageService(storageService);\n      }\n      _this.storageService = new RetriableDocumentStorageService(storageService, _this);\n      return _this.storageService;\n    })();\n  }\n  /**\n   * Enables or disables automatic reconnecting.\n   * Will throw an error if reconnectMode set to Never.\n   */\n  setAutomaticReconnect(reconnect) {\n    assert(this._reconnectMode !== ReconnectMode.Never, \"Cannot toggle automatic reconnect if reconnect is set to Never.\");\n    this._reconnectMode = reconnect ? ReconnectMode.Enabled : ReconnectMode.Disabled;\n  }\n  /**\n   * Sends signal to runtime (and data stores) to be read-only.\n   * Hosts may have read only views, indicating to data stores that no edits are allowed.\n   * This is independent from this._readonlyPermissions (permissions) and this.connectionMode\n   * (server can return \"write\" mode even when asked for \"read\")\n   * Leveraging same \"readonly\" event as runtime & data stores should behave the same in such case\n   * as in read-only permissions.\n   * But this.active can be used by some DDSes to figure out if ops can be sent\n   * (for example, read-only view still participates in code proposals / upgrades decisions)\n   *\n   * Forcing Readonly does not prevent DDS from generating ops. It is up to user code to honour\n   * the readonly flag. If ops are generated, they will accumulate locally and not be sent. If\n   * there are pending in the outbound queue, it will stop sending until force readonly is\n   * cleared.\n   *\n   * @param readonly - set or clear force readonly.\n   */\n  forceReadonly(readonly) {\n    const oldValue = this.readonly;\n    this._forceReadonly = readonly;\n    if (oldValue !== this.readonly) {\n      let reconnect = false;\n      if (this.readonly === true) {\n        // If we switch to readonly while connected, we should disconnect first\n        // See comment in the \"readonly\" event handler to deltaManager set up by\n        // the ContainerRuntime constructor\n        reconnect = this.disconnectFromDeltaStream(\"Force readonly\");\n      }\n      safeRaiseEvent(this, this.logger, \"readonly\", this.readonly);\n      if (reconnect) {\n        // reconnect if we disconnected from before.\n        this.triggerConnect({\n          mode: \"read\",\n          fetchOpsFromStorage: false\n        });\n      }\n    }\n  }\n  set_readonlyPermissions(readonly) {\n    const oldValue = this.readonly;\n    this._readonlyPermissions = readonly;\n    if (oldValue !== this.readonly) {\n      safeRaiseEvent(this, this.logger, \"readonly\", this.readonly);\n    }\n  }\n  dispose() {\n    throw new Error(\"Not implemented.\");\n  }\n  /**\n   * Sets the sequence number from which inbound messages should be returned\n   */\n  attachOpHandler(minSequenceNumber, sequenceNumber, term, handler) {\n    debug(\"Attached op handler\", sequenceNumber);\n    this.initSequenceNumber = sequenceNumber;\n    this.lastProcessedSequenceNumber = sequenceNumber;\n    this.baseTerm = term;\n    this.minSequenceNumber = minSequenceNumber;\n    this.lastQueuedSequenceNumber = sequenceNumber;\n    this.lastObservedSeqNumber = sequenceNumber;\n    // We will use same check in other places to make sure all the seq number above are set properly.\n    assert(this.handler === undefined);\n    this.handler = handler;\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    assert(!!this.handler);\n    this._inbound.systemResume();\n    this._inboundSignal.systemResume();\n    // We could have connected to delta stream before getting here\n    // If so, it's time to process any accumulated ops\n    // Or request OPs from snapshot / or point zero (if we have no ops at all)\n    if (this.pending.length > 0) {\n      this.processPendingOps(\"DocumentOpen\");\n    } else if (this.connection !== undefined || this.connectionP !== undefined) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.fetchMissingDeltas(\"DocumentOpen\", this.lastQueuedSequenceNumber);\n    }\n  }\n  updateQuorumJoin() {\n    this.inQuorum = true;\n  }\n  updateQuorumLeave() {\n    this.inQuorum = false;\n  }\n  static detailsFromConnection(connection) {\n    return {\n      claims: connection.claims,\n      clientId: connection.clientId,\n      existing: connection.existing,\n      checkpointSequenceNumber: connection.checkpointSequenceNumber,\n      get initialClients() {\n        return connection.initialClients;\n      },\n      maxMessageSize: connection.maxMessageSize,\n      mode: connection.mode,\n      serviceConfiguration: connection.serviceConfiguration,\n      version: connection.version\n    };\n  }\n  connect(args = {}) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const connection = yield _this2.connectCore(args);\n      return DeltaManager.detailsFromConnection(connection);\n    })();\n  }\n  /**\n   * Start the connection. Any error should result in container being close.\n   * And report the error if it excape for any reason.\n   * @param args - The connection arguments\n   */\n  triggerConnect(args) {\n    this.connectCore(args).catch(err => {\n      // Errors are raised as \"error\" event and close container.\n      // Have a catch-all case in case we missed something\n      if (!this.closed) {\n        this.logger.sendErrorEvent({\n          eventName: \"ConnectException\"\n        }, err);\n      }\n    });\n  }\n  connectCore(args = {}) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c;\n      if (_this3.connection !== undefined) {\n        return _this3.connection;\n      }\n      if (_this3.connectionP !== undefined) {\n        return _this3.connectionP;\n      }\n      const fetchOpsFromStorage = (_a = args.fetchOpsFromStorage, _a !== null && _a !== void 0 ? _a : true);\n      let requestedMode = (_b = args.mode, _b !== null && _b !== void 0 ? _b : _this3.defaultReconnectionMode);\n      // if we have any non-acked ops from last connection, reconnect as \"write\".\n      // without that we would connect in view-only mode, which will result in immediate\n      // firing of \"connected\" event from Container and switch of current clientId (as tracked\n      // by all DDSes). This will make it impossible to figure out if ops actually made it through,\n      // so DDSes will immediately resubmit all pending ops, and some of them will be duplicates, corrupting document\n      if (_this3.clientSequenceNumberObserved !== _this3.clientSequenceNumber) {\n        requestedMode = \"write\";\n      }\n      // Note: There is race condition here.\n      // We want to issue request to storage as soon as possible, to\n      // reduce latency of becoming current, thus this code here.\n      // But there is no ordering between fetching OPs and connection to delta stream\n      // As result, we might be behind by the time we connect to delta stream\n      // In case of r/w connection, that's not an issue, because we will hear our\n      // own \"join\" message and realize any gap client has in ops.\n      // But for view-only connection, we have no such signal, and with no traffic\n      // on the wire, we might be always behind.\n      // See comment at the end of setupNewSuccessfulConnection()\n      _this3.logger.debugAssert(_this3.handler !== undefined || fetchOpsFromStorage); // on boot, always fetch ops!\n      if (fetchOpsFromStorage && _this3.handler !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        _this3.fetchMissingDeltas((_c = args.reason, _c !== null && _c !== void 0 ? _c : \"DocumentOpen\"), _this3.lastQueuedSequenceNumber);\n      }\n      const docService = _this3.serviceProvider();\n      if (docService === undefined) {\n        throw new Error(\"Container is not attached\");\n      }\n      // The promise returned from connectCore will settle with a resolved connection or reject with error\n      const connectCore = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* () {\n          let connection;\n          let delay = InitialReconnectDelaySeconds;\n          let connectRepeatCount = 0;\n          const connectStartTime = performance.now();\n          // This loop will keep trying to connect until successful, with a delay between each iteration.\n          while (connection === undefined) {\n            if (_this3.closed) {\n              throw new Error(\"Attempting to connect a closed DeltaManager\");\n            }\n            connectRepeatCount++;\n            try {\n              _this3.client.mode = requestedMode;\n              connection = yield docService.connectToDeltaStream(_this3.client);\n            } catch (origError) {\n              const error = CreateContainerError(origError);\n              // Socket.io error when we connect to wrong socket, or hit some multiplexing bug\n              if (!canRetryOnError(origError)) {\n                _this3.close(error);\n                throw error;\n              }\n              // Log error once - we get too many errors in logs when we are offline,\n              // and unfortunately there is no reliable way to detect that.\n              if (connectRepeatCount === 1) {\n                logNetworkFailure(_this3.logger, {\n                  delay,\n                  eventName: \"DeltaConnectionFailureToConnect\"\n                }, origError);\n              }\n              const retryDelayFromError = getRetryDelayFromError(origError);\n              delay = retryDelayFromError !== null && retryDelayFromError !== void 0 ? retryDelayFromError : Math.min(delay * 2, MaxReconnectDelaySeconds);\n              if (retryDelayFromError !== undefined) {\n                _this3.emitDelayInfo(_this3.deltaStreamDelayId, retryDelayFromError, error);\n              }\n              yield waitForConnectedState(delay * 1000);\n            }\n          }\n          // If we retried more than once, log an event about how long it took\n          if (connectRepeatCount > 1) {\n            _this3.logger.sendTelemetryEvent({\n              attempts: connectRepeatCount,\n              duration: TelemetryLogger.formatTick(performance.now() - connectStartTime),\n              eventName: \"MultipleDeltaConnectionFailures\"\n            });\n          }\n          _this3.setupNewSuccessfulConnection(connection, requestedMode);\n          return connection;\n        });\n        return function connectCore() {\n          return _ref.apply(this, arguments);\n        };\n      }();\n      // This promise settles as soon as we know the outcome of the connection attempt\n      _this3.connectionP = new Promise((resolve, reject) => {\n        // Regardless of how the connection attempt concludes, we'll clear the promise and remove the listener\n        // Reject the connection promise if the DeltaManager gets closed during connection\n        const cleanupAndReject = error => {\n          _this3.connectionP = undefined;\n          _this3.removeListener(\"closed\", cleanupAndReject);\n          reject(error);\n        };\n        _this3.on(\"closed\", cleanupAndReject);\n        // Attempt the connection\n        connectCore().then(connection => {\n          _this3.connectionP = undefined;\n          _this3.removeListener(\"closed\", cleanupAndReject);\n          resolve(connection);\n        }).catch(cleanupAndReject);\n      });\n      return _this3.connectionP;\n    })();\n  }\n  flush() {\n    if (this.messageBuffer.length === 0) {\n      return;\n    }\n    // The prepareFlush event allows listeners to append metadata to the batch prior to submission.\n    this.emit(\"prepareSend\", this.messageBuffer);\n    this._outbound.push(this.messageBuffer);\n    this.messageBuffer = [];\n  }\n  submit(type, contents, batch = false, metadata) {\n    // TODO need to fail if gets too large\n    // const serializedContent = JSON.stringify(this.messageBuffer);\n    // const maxOpSize = this.context.deltaManager.maxMessageSize;\n    var _a, _b;\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (this.readonly) {\n      this.close(CreateContainerError(\"Op is sent in read-only document state\"));\n      return -1;\n    }\n    // reset clientSequenceNumber if we are using new clientId.\n    // we keep info about old connection as long as possible to be able to account for all non-acked ops\n    // that we pick up on next connection.\n    assert(!!this.connection);\n    if (this.lastSubmittedClientId !== ((_a = this.connection) === null || _a === void 0 ? void 0 : _a.clientId)) {\n      this.lastSubmittedClientId = (_b = this.connection) === null || _b === void 0 ? void 0 : _b.clientId;\n      this.clientSequenceNumber = 0;\n      this.clientSequenceNumberObserved = 0;\n    }\n    const service = this.clientDetails.type === undefined || this.clientDetails.type === \"\" ? \"unknown\" : this.clientDetails.type;\n    // Start adding trace for the op.\n    const traces = [{\n      action: \"start\",\n      service,\n      timestamp: Date.now()\n    }];\n    const message = {\n      clientSequenceNumber: ++this.clientSequenceNumber,\n      contents: JSON.stringify(contents),\n      metadata,\n      referenceSequenceNumber: this.lastProcessedSequenceNumber,\n      traces,\n      type\n    };\n    const outbound = this.createOutboundMessage(type, message);\n    this.stopSequenceNumberUpdate();\n    this.emit(\"submitOp\", message);\n    if (!batch) {\n      this.flush();\n      this.messageBuffer.push(outbound);\n      this.flush();\n    } else {\n      this.messageBuffer.push(outbound);\n    }\n    return outbound.clientSequenceNumber;\n  }\n  submitSignal(content) {\n    if (this.connection !== undefined) {\n      this.connection.submitSignal(content);\n    } else {\n      this.logger.sendErrorEvent({\n        eventName: \"submitSignalDisconnected\"\n      });\n    }\n  }\n  getDeltas(telemetryEventSuffix, fromInitial, to, callback) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      let retry = 0;\n      let from = fromInitial;\n      let deltas = [];\n      let deltasRetrievedTotal = 0;\n      const docService = _this4.serviceProvider();\n      if (docService === undefined) {\n        throw new Error(\"Delta manager is not attached\");\n      }\n      const telemetryEvent = PerformanceEvent.start(_this4.logger, {\n        eventName: `GetDeltas_${telemetryEventSuffix}`,\n        from,\n        to\n      });\n      let requests = 0;\n      let deltaStorage;\n      while (!_this4.closed) {\n        const maxFetchTo = from + MaxBatchDeltas;\n        const fetchTo = to === undefined ? maxFetchTo : Math.min(maxFetchTo, to);\n        let deltasRetrievedLast = 0;\n        let success = true;\n        let canRetry = false;\n        let retryAfter;\n        try {\n          // Connect to the delta storage endpoint\n          if (deltaStorage === undefined) {\n            if (_this4.deltaStorageP === undefined) {\n              _this4.deltaStorageP = docService.connectToDeltaStorage();\n            }\n            deltaStorage = yield _this4.deltaStorageP;\n          }\n          requests++;\n          // Issue async request for deltas - limit the number fetched to MaxBatchDeltas\n          canRetry = true;\n          const deltasP = deltaStorage.get(from, fetchTo);\n          // Return previously fetched deltas, for processing while we are waiting for new request.\n          if (deltas.length > 0) {\n            callback(deltas);\n          }\n          // Now wait for request to come back\n          deltas = yield deltasP;\n          // Note that server (or driver code) can push here something unexpected, like undefined\n          // Exception thrown as result of it will result in us retrying\n          deltasRetrievedLast = deltas.length;\n          deltasRetrievedTotal += deltasRetrievedLast;\n          const lastFetch = deltasRetrievedLast > 0 ? deltas[deltasRetrievedLast - 1].sequenceNumber : from;\n          // If we have no upper bound and fetched less than the max deltas - meaning we got as many as exit -\n          // then we can resolve the promise. We also resolve if we fetched up to the expected to. Otherwise\n          // we will look to try again\n          // Note #1: we can get more ops than what we asked for - need to account for that!\n          // Note #2: from & to are exclusive! I.e. we actually expect [from + 1, to - 1] range of ops back!\n          // 1) to === undefined case: if last op  is below what we expect, then storage does not have\n          //    any more, thus it's time to leave\n          // 2) else case: if we got what we asked (to - 1) or more, then time to leave.\n          if (to === undefined ? lastFetch < maxFetchTo - 1 : to - 1 <= lastFetch) {\n            callback(deltas);\n            telemetryEvent.end({\n              lastFetch,\n              deltasRetrievedTotal,\n              requests\n            });\n            return;\n          }\n          // Attempt to fetch more deltas. If we didn't receive any in the previous call we up our retry\n          // count since something prevented us from seeing those deltas\n          from = lastFetch;\n        } catch (origError) {\n          canRetry = canRetry && canRetryOnError(origError);\n          const error = CreateContainerError(origError);\n          logNetworkFailure(_this4.logger, {\n            eventName: \"GetDeltas_Error\",\n            fetchTo,\n            from,\n            requests,\n            retry: retry + 1\n          }, origError);\n          if (!canRetry) {\n            // It's game over scenario.\n            telemetryEvent.cancel({\n              category: \"error\"\n            }, origError);\n            _this4.close(error);\n            return;\n          }\n          success = false;\n          retryAfter = getRetryDelayFromError(origError);\n          if (retryAfter !== undefined && retryAfter >= 0) {\n            _this4.emitDelayInfo(_this4.deltaStorageDelayId, retryAfter, error);\n          }\n        }\n        if (to !== undefined && _this4.lastQueuedSequenceNumber >= to) {\n          // the client caught up while we were trying to fetch ops from storage\n          // bail out since we no longer need to request these ops\n          telemetryEvent.end({\n            deltasRetrievedTotal,\n            requests,\n            lastQueuedSequenceNumber: _this4.lastQueuedSequenceNumber\n          });\n          return;\n        }\n        let delay;\n        if (deltasRetrievedLast !== 0) {\n          delay = 0;\n          retry = 0; // start calculating timeout over if we got some ops\n        } else {\n          retry++;\n          delay = retryAfter !== null && retryAfter !== void 0 ? retryAfter : Math.min(MaxFetchDelaySeconds, MissingFetchDelaySeconds * Math.pow(2, retry));\n          // Chances that we will get something from storage after that many retries is zero.\n          // We wait 10 seconds between most of retries, so that's 16 minutes of waiting!\n          // Note - it's very important that we differentiate connected state from possibly disconnected state!\n          // Only bail out if we successfully connected to storage, but there were no ops\n          // One (last) successful connection is sufficient, even if user was disconnected all prior attempts\n          if (success && retry >= 100) {\n            telemetryEvent.cancel({\n              category: \"error\",\n              error: \"too many retries\",\n              retry,\n              requests,\n              deltasRetrievedTotal,\n              replayFrom: from,\n              to\n            });\n            const closeError = createGenericNetworkError(\"Failed to retrieve ops from storage: giving up after too many retries\", false /* canRetry */);\n            _this4.close(closeError);\n            return;\n          }\n        }\n        telemetryEvent.reportProgress({\n          delay,\n          deltasRetrievedLast,\n          deltasRetrievedTotal,\n          replayFrom: from,\n          requests,\n          retry,\n          success\n        });\n        yield waitForConnectedState(delay * 1000);\n      }\n      // Might need to change to non-error event\n      _this4.logger.sendErrorEvent({\n        eventName: \"GetDeltasClosedConnection\"\n      });\n      telemetryEvent.cancel({\n        error: \"container closed\"\n      });\n    })();\n  }\n  /**\n   * Closes the connection and clears inbound & outbound queues.\n   */\n  close(error) {\n    var _a;\n    if (this.closed) {\n      return;\n    }\n    this.closed = true;\n    (_a = this.storageService) === null || _a === void 0 ? void 0 : _a.dispose();\n    this.stopSequenceNumberUpdate();\n    // This raises \"disconnect\" event if we have active connection.\n    this.disconnectFromDeltaStream(error !== undefined ? `${error.message}` : \"Container closed\");\n    this._inbound.clear();\n    this._outbound.clear();\n    this._inboundSignal.clear();\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this._inbound.pause();\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this._inboundSignal.pause();\n    // Drop pending messages - this will ensure catchUp() does not go into infinite loop\n    this.pending = [];\n    // Notify everyone we are in read-only state.\n    // Useful for data stores in case we hit some critical error,\n    // to switch to a mode where user edits are not accepted\n    this.set_readonlyPermissions(true);\n    // This needs to be the last thing we do (before removing listeners), as it causes\n    // Container to dispose context and break ability of data stores / runtime to \"hear\"\n    // from delta manager, including notification (above) about readonly state.\n    this.emit(\"closed\", error);\n    this.removeAllListeners();\n  }\n  // Specific system level message attributes are need to be looked at by the server.\n  // Hence they are separated and promoted as top level attributes.\n  createOutboundMessage(type, coreMessage) {\n    if (isSystemType(type)) {\n      const data = coreMessage.contents;\n      coreMessage.contents = null;\n      const outboundMessage = Object.assign(Object.assign({}, coreMessage), {\n        data\n      });\n      return outboundMessage;\n    } else {\n      return coreMessage;\n    }\n  }\n  refreshDelayInfo(id) {\n    this.throttlingIdSet.delete(id);\n    if (this.throttlingIdSet.size === 0) {\n      this.timeTillThrottling = 0;\n    }\n  }\n  emitDelayInfo(id, delaySeconds, error) {\n    const timeNow = Date.now();\n    this.throttlingIdSet.add(id);\n    if (delaySeconds > 0 && timeNow + delaySeconds > this.timeTillThrottling) {\n      this.timeTillThrottling = timeNow + delaySeconds;\n      const throttlingError = {\n        errorType: ContainerErrorType.throttlingError,\n        message: `Service busy/throttled: ${error.message}`,\n        retryAfterSeconds: delaySeconds\n      };\n      this.emit(\"throttled\", throttlingError);\n    }\n  }\n  /**\n   * Once we've successfully gotten a connection, we need to set up state, attach event listeners, and process\n   * initial messages.\n   * @param connection - The newly established connection\n   */\n  setupNewSuccessfulConnection(connection, requestedMode) {\n    var _a;\n    // Old connection should have been cleaned up before establishing a new one\n    assert(this.connection === undefined, \"old connection exists on new connection setup\");\n    this.connection = connection;\n    // Does information in scopes & mode matches?\n    // If we asked for \"write\" and got \"read\", then file is read-only\n    // But if we ask read, server can still give us write.\n    const readonly = !connection.claims.scopes.includes(ScopeType.DocWrite);\n    assert(requestedMode === \"read\" || readonly === (this.connectionMode === \"read\"), \"claims/connectionMode mismatch\");\n    assert(!readonly || this.connectionMode === \"read\", \"readonly perf with write connection\");\n    this.set_readonlyPermissions(readonly);\n    this.refreshDelayInfo(this.deltaStreamDelayId);\n    if (this.closed) {\n      // Raise proper events, Log telemetry event and close connection.\n      this.disconnectFromDeltaStream(`Disconnect on close`);\n      return;\n    }\n    // We cancel all ops on lost of connectivity, and rely on DDSes to resubmit them.\n    // Semantics are not well defined for batches (and they are broken right now on disconnects anyway),\n    // but it's safe to assume (until better design is put into place) that batches should not exist\n    // across multiple connections. Right now we assume runtime will not submit any ops in disconnected\n    // state. As requirements change, so should these checks.\n    assert(this.messageBuffer.length === 0, \"messageBuffer is not empty on new connection\");\n    this._outbound.systemResume();\n    connection.on(\"op\", this.opHandler);\n    connection.on(\"signal\", this.signalHandler);\n    connection.on(\"nack\", this.nackHandler);\n    connection.on(\"disconnect\", this.disconnectHandler);\n    connection.on(\"error\", this.errorHandler);\n    connection.on(\"pong\", this.pongHandler);\n    const initialMessages = connection.initialMessages;\n    this._hasCheckpointSequenceNumber = false;\n    // Some storages may provide checkpointSequenceNumber to identify how far client is behind.\n    if (connection.checkpointSequenceNumber !== undefined) {\n      this._hasCheckpointSequenceNumber = true;\n      this.updateLatestKnownOpSeqNumber(connection.checkpointSequenceNumber);\n    }\n    // Update knowledge of how far we are behind, before raising \"connect\" event\n    // This is duplication of what enqueueMessages() does, but we have to raise event before we get there,\n    // so duplicating update logic here as well.\n    if (initialMessages.length > 0) {\n      this._hasCheckpointSequenceNumber = true;\n      this.updateLatestKnownOpSeqNumber(initialMessages[initialMessages.length - 1].sequenceNumber);\n    }\n    // Notify of the connection\n    // WARNING: This has to happen before processInitialMessages() call below.\n    // If not, we may not update Container.pendingClientId in time before seeing our own join session op.\n    this.emit(\"connect\", DeltaManager.detailsFromConnection(connection), this._hasCheckpointSequenceNumber ? this.lastKnownSeqNumber - this.lastSequenceNumber : undefined);\n    this.processInitialMessages(initialMessages, (_a = connection.initialSignals, _a !== null && _a !== void 0 ? _a : []), this.connectFirstConnection);\n    // if we have some op on the wire (or will have a \"join\" op for ourselves for r/w connection), then client\n    // can detect it has a gap and fetch missing ops. However if we are connecting as view-only, then there\n    // is no good signal to realize if client is behind. Thus we have to hit storage to see if any ops are there.\n    if (this.handler !== undefined && connection.mode !== \"write\" && initialMessages.length === 0) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.fetchMissingDeltas(\"Reconnect\", this.lastQueuedSequenceNumber);\n    }\n    this.connectFirstConnection = false;\n  }\n  /**\n   * Disconnect the current connection.\n   * @param reason - Text description of disconnect reason to emit with disconnect event\n   */\n  disconnectFromDeltaStream(reason) {\n    if (this.connection === undefined) {\n      return false;\n    }\n    const connection = this.connection;\n    // Avoid any re-entrancy - clear object reference\n    this.connection = undefined;\n    // Remove listeners first so we don't try to retrigger this flow accidentally through reconnectOnError\n    connection.off(\"op\", this.opHandler);\n    connection.off(\"signal\", this.signalHandler);\n    connection.off(\"nack\", this.nackHandler);\n    connection.off(\"disconnect\", this.disconnectHandler);\n    connection.off(\"error\", this.errorHandler);\n    connection.off(\"pong\", this.pongHandler);\n    // We cancel all ops on lost of connectivity, and rely on DDSes to resubmit them.\n    // Semantics are not well defined for batches (and they are broken right now on disconnects anyway),\n    // but it's safe to assume (until better design is put into place) that batches should not exist\n    // across multiple connections. Right now we assume runtime will not submit any ops in disconnected\n    // state. As requirements change, so should these checks.\n    assert(this.messageBuffer.length === 0, \"messageBuffer is not empty on disconnect\");\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this._outbound.systemPause();\n    this._outbound.clear();\n    this.emit(\"disconnect\", reason);\n    connection.close();\n    return true;\n  }\n  /**\n   * Disconnect the current connection and reconnect.\n   * @param connection - The connection that wants to reconnect - no-op if it's different from this.connection\n   * @param requestedMode - Read or write\n   * @param reconnectInfo - Error reconnect information including whether or not to reconnect\n   * @returns A promise that resolves when the connection is reestablished or we stop trying\n   */\n  reconnectOnError(requestedMode, error) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      // We quite often get protocol errors before / after observing nack/disconnect\n      // we do not want to run through same sequence twice.\n      // If we're already disconnected/disconnecting it's not appropriate to call this again.\n      assert(_this5.connection !== undefined);\n      _this5.disconnectFromDeltaStream(error.message);\n      // If reconnection is not an option, close the DeltaManager\n      const canRetry = canRetryOnError(error);\n      if (_this5.reconnectMode === ReconnectMode.Never || !canRetry) {\n        // Do not raise container error if we are closing just because we lost connection.\n        // Those errors (like IdleDisconnect) would show up in telemetry dashboards and\n        // are very misleading, as first initial reaction - some logic is broken.\n        _this5.close(canRetry ? undefined : error);\n      }\n      // If closed then we can't reconnect\n      if (_this5.closed) {\n        return;\n      }\n      if (_this5.reconnectMode === ReconnectMode.Enabled) {\n        const delay = getRetryDelayFromError(error);\n        if (delay !== undefined) {\n          _this5.emitDelayInfo(_this5.deltaStreamDelayId, delay, error);\n          yield waitForConnectedState(delay * 1000);\n        }\n        _this5.triggerConnect({\n          mode: requestedMode,\n          fetchOpsFromStorage: false\n        });\n      }\n    })();\n  }\n  processInitialMessages(messages, signals, firstConnection) {\n    if (messages.length > 0) {\n      this.catchUp(messages, firstConnection ? \"InitialOps\" : \"ReconnectOps\");\n    }\n    for (const signal of signals) {\n      this._inboundSignal.push(signal);\n    }\n  }\n  // returns parts of message (in string format) that should never change for a given message.\n  // Used for message comparison. It attempts to avoid comparing fields that potentially may differ.\n  // for example, it's not clear if serverMetadata or timestamp property is a property of message or server state.\n  // We only extract the most obvious fields that are sufficient (with high probability) to detect sequence number\n  // reuse.\n  // Also payload goes to telemetry, so no PII, including content!!\n  comparableMessagePayload(m) {\n    return `${m.clientId}-${m.type}-${m.minimumSequenceNumber}-${m.referenceSequenceNumber}`;\n  }\n  enqueueMessages(messages, telemetryEventSuffix = \"OutOfOrderMessage\") {\n    var _a, _b;\n    if (this.handler === undefined) {\n      // We did not setup handler yet.\n      // This happens when we connect to web socket faster than we get attributes for container\n      // and thus faster than attachOpHandler() is called\n      // this.lastProcessedSequenceNumber is still zero, so we can't rely on this.fetchMissingDeltas()\n      // to do the right thing.\n      this.pending = this.pending.concat(messages);\n      return;\n    }\n    let duplicateStart;\n    let duplicateEnd;\n    let duplicateCount = 0;\n    if (messages.length > 0) {\n      this.updateLatestKnownOpSeqNumber(messages[messages.length - 1].sequenceNumber);\n    }\n    for (const message of messages) {\n      // Check that the messages are arriving in the expected order\n      if (message.sequenceNumber <= this.lastQueuedSequenceNumber) {\n        duplicateCount++;\n        if (duplicateStart === undefined || duplicateStart > message.sequenceNumber) {\n          duplicateStart = message.sequenceNumber;\n        }\n        if (duplicateEnd === undefined || duplicateEnd < message.sequenceNumber) {\n          duplicateEnd = message.sequenceNumber;\n        }\n        // Validate that we do not have data loss, i.e. sequencing is reset and started again\n        // with numbers that this client already observed before.\n        if (((_a = this.previouslyProcessedMessage) === null || _a === void 0 ? void 0 : _a.sequenceNumber) === message.sequenceNumber) {\n          const message1 = this.comparableMessagePayload(this.previouslyProcessedMessage);\n          const message2 = this.comparableMessagePayload(message);\n          if (message1 !== message2) {\n            const error = new DataCorruptionError(\"Two messages with same seq# and different payload!\", {\n              clientId: (_b = this.connection) === null || _b === void 0 ? void 0 : _b.clientId,\n              sequenceNumber: message.sequenceNumber,\n              message1,\n              message2\n            });\n            this.close(error);\n          }\n        }\n      } else if (message.sequenceNumber !== this.lastQueuedSequenceNumber + 1) {\n        this.pending.push(message);\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.fetchMissingDeltas(telemetryEventSuffix, this.lastQueuedSequenceNumber, message.sequenceNumber);\n      } else {\n        this.lastQueuedSequenceNumber = message.sequenceNumber;\n        this.previouslyProcessedMessage = message;\n        this._inbound.push(message);\n        if (this.pending.length > 0) {\n          // we processed a correctly sequenced inbound op while some are pending\n          // pending might include ops after the current sequence number, so process them now\n          this.processPendingOps(`EnqueueMessages_${telemetryEventSuffix}`);\n        }\n      }\n    }\n    if (duplicateCount !== 0) {\n      this.logger.sendTelemetryEvent({\n        eventName: `DuplicateMessages_${telemetryEventSuffix}`,\n        start: duplicateStart,\n        end: duplicateEnd,\n        count: duplicateCount\n      });\n    }\n  }\n  processInboundMessage(message) {\n    var _a;\n    const startTime = Date.now();\n    // All non-system messages are coming from some client, and should have clientId\n    // System messages may have no clientId (but some do, like propose, noop, summarize)\n    // Note: NoClient has not been added yet to isSystemMessage (in 0.16.x branch)\n    assert(message.clientId !== undefined || isSystemMessage(message) || message.type === MessageType.NoClient, \"non-system message have to have clientId\");\n    // if we have connection, and message is local, then we better treat is as local!\n    assert(this.connection === undefined || this.connection.clientId !== message.clientId || this.lastSubmittedClientId === message.clientId, \"Not accounting local messages correctly\");\n    if (this.lastSubmittedClientId !== undefined && this.lastSubmittedClientId === message.clientId) {\n      const clientSequenceNumber = message.clientSequenceNumber;\n      assert(this.clientSequenceNumberObserved < clientSequenceNumber, \"client seq# not growing\");\n      assert(clientSequenceNumber <= this.clientSequenceNumber, \"Incoming local client seq# > generated by this client\");\n      this.clientSequenceNumberObserved = clientSequenceNumber;\n    }\n    // TODO Remove after SPO picks up the latest build.\n    if (typeof message.contents === \"string\" && message.contents !== \"\" && message.type !== MessageType.ClientLeave) {\n      message.contents = JSON.parse(message.contents);\n    }\n    // Add final ack trace.\n    if (((_a = message.traces) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n      const service = this.clientDetails.type === undefined || this.clientDetails.type === \"\" ? \"unknown\" : this.clientDetails.type;\n      message.traces.push({\n        action: \"end\",\n        service,\n        timestamp: Date.now()\n      });\n    }\n    // Watch the minimum sequence number and be ready to update as needed\n    assert(this.minSequenceNumber <= message.minimumSequenceNumber, \"msn moves backwards\");\n    this.minSequenceNumber = message.minimumSequenceNumber;\n    assert(message.sequenceNumber === this.lastProcessedSequenceNumber + 1, \"non-seq seq#\");\n    this.lastProcessedSequenceNumber = message.sequenceNumber;\n    // Back-compat for older server with no term\n    if (message.term === undefined) {\n      message.term = 1;\n    }\n    this.baseTerm = message.term;\n    this.emit(\"beforeOpProcessing\", message);\n    if (this.handler === undefined) {\n      throw new Error(\"Attempted to process an inbound message without a handler attached\");\n    }\n    const result = this.handler.process(message);\n    this.scheduleSequenceNumberUpdate(message, result.immediateNoOp === true);\n    const endTime = Date.now();\n    this.emit(\"op\", message, endTime - startTime);\n  }\n  /**\n   * Retrieves the missing deltas between the given sequence numbers\n   */\n  fetchMissingDeltas(telemetryEventSuffix, from, to) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      // Exit out early if we're already fetching deltas\n      if (_this6.fetching) {\n        return;\n      }\n      if (_this6.closed) {\n        _this6.logger.sendTelemetryEvent({\n          eventName: \"fetchMissingDeltasClosedConnection\"\n        });\n        return;\n      }\n      _this6.fetching = true;\n      yield _this6.getDeltas(telemetryEventSuffix, from, to, messages => {\n        _this6.refreshDelayInfo(_this6.deltaStorageDelayId);\n        _this6.enqueueMessages(messages, telemetryEventSuffix);\n      });\n      _this6.refreshDelayInfo(_this6.deltaStorageDelayId);\n      _this6.fetching = false;\n    })();\n  }\n  catchUp(messages, telemetryEventSuffix) {\n    const props = {\n      eventName: `CatchUp_${telemetryEventSuffix}`,\n      messageCount: messages.length,\n      pendingCount: this.pending.length\n    };\n    if (messages.length !== 0) {\n      props.from = messages[0].sequenceNumber;\n      props.to = messages[messages.length - 1].sequenceNumber;\n      props.messageGap = this.handler !== undefined ? props.from - this.lastQueuedSequenceNumber - 1 : undefined;\n    }\n    this.logger.sendPerformanceEvent(props);\n    this.enqueueMessages(messages, telemetryEventSuffix);\n  }\n  /**\n   * Sorts pending ops and attempts to apply them\n   */\n  processPendingOps(telemetryEventSuffix) {\n    if (this.handler !== undefined) {\n      const pendingSorted = this.pending.sort((a, b) => a.sequenceNumber - b.sequenceNumber);\n      this.pending = [];\n      this.enqueueMessages(pendingSorted, telemetryEventSuffix);\n    }\n  }\n  /**\n   * Schedules as ack to the server to update the reference sequence number\n   */\n  scheduleSequenceNumberUpdate(message, immediateNoOp) {\n    // Exit early for inactive (not in quorum or not writers) clients.\n    // They don't take part in the minimum sequence number calculation.\n    if (!this.active) {\n      this.stopSequenceNumberUpdate();\n      return;\n    }\n    // While processing a message, an immediate no-op can be requested.\n    // i.e. to expedite approve or commit phase of quorum.\n    if (immediateNoOp) {\n      this.stopSequenceNumberUpdate();\n      this.submit(MessageType.NoOp, ImmediateNoOpResponse);\n      return;\n    }\n    // We don't acknowledge no-ops to avoid acknowledgement cycles (i.e. ack the MSN\n    // update, which updates the MSN, then ack the update, etc...).\n    if (message.type === MessageType.NoOp) {\n      return;\n    }\n    // We will queue a message to update our reference sequence number upon receiving a server\n    // operation. This allows the server to know our true reference sequence number and be able to\n    // correctly update the minimum sequence number (MSN).\n    if (this.updateSequenceNumberTimer === undefined) {\n      // Clear an update in 2 s\n      this.updateSequenceNumberTimer = setTimeout(() => {\n        this.updateSequenceNumberTimer = undefined;\n        if (this.active) {\n          this.submit(MessageType.NoOp, null);\n        }\n      }, 2000);\n    }\n  }\n  stopSequenceNumberUpdate() {\n    if (this.updateSequenceNumberTimer !== undefined) {\n      clearTimeout(this.updateSequenceNumberTimer);\n    }\n    this.updateSequenceNumberTimer = undefined;\n  }\n  updateLatestKnownOpSeqNumber(seq) {\n    if (this.lastObservedSeqNumber < seq) {\n      this.lastObservedSeqNumber = seq;\n    }\n  }\n}\n//# sourceMappingURL=deltaManager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}