{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { KJUR as jsrsasign } from \"jsrsasign\";\nimport { v4 as uuid } from \"uuid\";\n/**\n * InsecureTinyliciousUrlResolver knows how to get the URLs to the service (in this case Tinylicious) to use\n * for a given request.  This particular implementation has a goal to avoid imposing requirements on the app's\n * URL shape, so it expects the request url to have this format (as opposed to a more traditional URL):\n * documentId/containerRelativePathing\n */\nexport class InsecureTinyliciousUrlResolver {\n  resolve(request) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const url = request.url.replace(\"http://localhost:3000/\", \"\");\n      const documentId = url.split(\"/\")[0];\n      const encodedDocId = encodeURIComponent(documentId);\n      const documentRelativePath = url.slice(documentId.length);\n      const documentUrl = `fluid://localhost:3000/tinylicious/${encodedDocId}${documentRelativePath}`;\n      const deltaStorageUrl = `http://localhost:3000/deltas/tinylicious/${encodedDocId}`;\n      const storageUrl = `http://localhost:3000/repos/tinylicious`;\n      const response = {\n        endpoints: {\n          deltaStorageUrl,\n          ordererUrl: \"http://localhost:3000\",\n          storageUrl\n        },\n        tokens: {\n          jwt: _this.auth(documentId)\n        },\n        type: \"fluid\",\n        url: documentUrl\n      };\n      return response;\n    })();\n  }\n  getAbsoluteUrl(resolvedUrl, relativeUrl) {\n    return _asyncToGenerator(function* () {\n      const documentId = decodeURIComponent(resolvedUrl.url.replace(\"fluid://localhost:3000/tinylicious/\", \"\"));\n      /*\n       * The detached container flow will ultimately call getAbsoluteUrl() with the resolved.url produced by\n       * resolve().  The container expects getAbsoluteUrl's return value to be a URL that can then be roundtripped\n       * back through resolve() again, and get the same result again.  So we'll return a \"URL\" with the same format\n       * described above.\n       */\n      return `${documentId}/${relativeUrl}`;\n    })();\n  }\n  auth(documentId) {\n    const claims = {\n      documentId,\n      scopes: [\"doc:read\", \"doc:write\", \"summary:write\"],\n      tenantId: \"tinylicious\",\n      user: {\n        id: uuid()\n      },\n      iat: Math.round(new Date().getTime() / 1000),\n      exp: Math.round(new Date().getTime() / 1000) + 60 * 60,\n      ver: \"1.0\"\n    };\n    const utf8Key = {\n      utf8: \"12345\"\n    };\n    // eslint-disable-next-line no-null/no-null\n    return jsrsasign.jws.JWS.sign(null, JSON.stringify({\n      alg: \"HS256\",\n      typ: \"JWT\"\n    }), claims, utf8Key);\n  }\n}\nexport const createTinyliciousCreateNewRequest = documentId => ({\n  url: documentId,\n  headers: {\n    createNew: true\n  }\n});\n//# sourceMappingURL=insecureTinyliciousUrlResolver.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}