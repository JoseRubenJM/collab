{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { default as AbortController } from \"abort-controller\";\nimport { v4 as uuid } from \"uuid\";\nimport { assert, TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport { normalizeError, logIfFalse, safeRaiseEvent } from \"@fluidframework/telemetry-utils\";\nimport { DriverErrorType } from \"@fluidframework/driver-definitions\";\nimport { MessageType } from \"@fluidframework/protocol-definitions\";\nimport { NonRetryableError, isClientMessage } from \"@fluidframework/driver-utils\";\nimport { ThrottlingWarning, DataCorruptionError, extractSafePropertiesFromMessage, DataProcessingError } from \"@fluidframework/container-utils\";\nimport { DeltaQueue } from \"./deltaQueue\";\n/**\n * Manages the flow of both inbound and outbound messages. This class ensures that shared objects receive delta\n * messages in order regardless of possible network conditions or timings causing out of order delivery.\n */\nexport class DeltaManager extends TypedEventEmitter {\n  constructor(serviceProvider, logger, _active, createConnectionManager) {\n    super();\n    this.serviceProvider = serviceProvider;\n    this.logger = logger;\n    this._active = _active;\n    this.pending = [];\n    // The minimum sequence number and last sequence number received from the server\n    this.minSequenceNumber = 0;\n    // There are three numbers we track\n    // * lastQueuedSequenceNumber is the last queued sequence number. If there are gaps in seq numbers, then this number\n    //   is not updated until we cover that gap, so it increases each time by 1.\n    // * lastObservedSeqNumber is  an estimation of last known sequence number for container in storage. It's initially\n    //   populated at web socket connection time (if storage provides that info) and is  updated once ops shows up.\n    //   It's never less than lastQueuedSequenceNumber\n    // * lastProcessedSequenceNumber - last processed sequence number\n    this.lastQueuedSequenceNumber = 0;\n    this.lastObservedSeqNumber = 0;\n    this.lastProcessedSequenceNumber = 0;\n    this.baseTerm = 0;\n    /**\n     * Track down the ops size.\n    */\n    this.opsSize = 0;\n    // The sequence number we initially loaded from\n    this.initSequenceNumber = 0;\n    this.closed = false;\n    this.throttlingIdSet = new Set();\n    this.timeTillThrottling = 0;\n    this.closeAbortController = new AbortController();\n    this.deltaStorageDelayId = uuid();\n    this.deltaStreamDelayId = uuid();\n    this.messageBuffer = [];\n    const props = {\n      incomingOpHandler: (messages, reason) => {\n        try {\n          this.enqueueMessages(messages, reason);\n        } catch (error) {\n          this.logger.sendErrorEvent({\n            eventName: \"EnqueueMessages_Exception\"\n          }, error);\n          this.close(normalizeError(error));\n        }\n      },\n      signalHandler: message => this._inboundSignal.push(message),\n      reconnectionDelayHandler: (delayMs, error) => this.emitDelayInfo(this.deltaStreamDelayId, delayMs, error),\n      closeHandler: error => this.close(error),\n      disconnectHandler: reason => this.disconnectHandler(reason),\n      connectHandler: connection => this.connectHandler(connection),\n      pongHandler: latency => this.emit(\"pong\", latency),\n      readonlyChangeHandler: readonly => safeRaiseEvent(this, this.logger, \"readonly\", readonly)\n    };\n    this.connectionManager = createConnectionManager(props);\n    this._inbound = new DeltaQueue(op => {\n      this.processInboundMessage(op);\n    });\n    this._inbound.on(\"error\", error => {\n      this.close(DataProcessingError.wrapIfUnrecognized(error, \"deltaManagerInboundErrorHandler\", this.lastMessage));\n    });\n    // Inbound signal queue\n    this._inboundSignal = new DeltaQueue(message => {\n      if (this.handler === undefined) {\n        throw new Error(\"Attempted to process an inbound signal without a handler attached\");\n      }\n      this.handler.processSignal({\n        clientId: message.clientId,\n        content: JSON.parse(message.content)\n      });\n    });\n    this._inboundSignal.on(\"error\", error => {\n      this.close(normalizeError(error));\n    });\n    // Initially, all queues are created paused.\n    // - outbound is flipped back and forth in setupNewSuccessfulConnection / disconnectFromDeltaStream\n    // - inbound & inboundSignal are resumed in attachOpHandler() when we have handler setup\n  }\n\n  get active() {\n    return this._active();\n  }\n  get disposed() {\n    return this.closed;\n  }\n  get IDeltaSender() {\n    return this;\n  }\n  get inbound() {\n    return this._inbound;\n  }\n  get inboundSignal() {\n    return this._inboundSignal;\n  }\n  get initialSequenceNumber() {\n    return this.initSequenceNumber;\n  }\n  get lastSequenceNumber() {\n    return this.lastProcessedSequenceNumber;\n  }\n  get lastMessage() {\n    return this.lastProcessedMessage;\n  }\n  get lastKnownSeqNumber() {\n    return this.lastObservedSeqNumber;\n  }\n  get referenceTerm() {\n    return this.baseTerm;\n  }\n  get minimumSequenceNumber() {\n    return this.minSequenceNumber;\n  }\n  /**\n   * Tells if  current connection has checkpoint information.\n   * I.e. we know how far behind the client was at the time of establishing connection\n   */\n  get hasCheckpointSequenceNumber() {\n    // Valid to be called only if we have active connection.\n    assert(this.connectionManager.connected, 0x0df /* \"Missing active connection\" */);\n    return this._checkpointSequenceNumber !== undefined;\n  }\n  // Forwarding connection manager properties / IDeltaManager implementation\n  get maxMessageSize() {\n    return this.connectionManager.maxMessageSize;\n  }\n  get version() {\n    return this.connectionManager.version;\n  }\n  get serviceConfiguration() {\n    return this.connectionManager.serviceConfiguration;\n  }\n  get outbound() {\n    return this.connectionManager.outbound;\n  }\n  get readOnlyInfo() {\n    return this.connectionManager.readOnlyInfo;\n  }\n  get clientDetails() {\n    return this.connectionManager.clientDetails;\n  }\n  submit(type, contents, batch = false, metadata) {\n    const messagePartial = {\n      contents: JSON.stringify(contents),\n      metadata,\n      referenceSequenceNumber: this.lastProcessedSequenceNumber,\n      type\n    };\n    if (!batch) {\n      this.flush();\n    }\n    const message = this.connectionManager.prepareMessageToSend(messagePartial);\n    if (message === undefined) {\n      return -1;\n    }\n    this.opsSize += message.contents.length;\n    this.messageBuffer.push(message);\n    this.emit(\"submitOp\", message);\n    if (!batch) {\n      this.flush();\n    }\n    return message.clientSequenceNumber;\n  }\n  submitSignal(content) {\n    return this.connectionManager.submitSignal(content);\n  }\n  flush() {\n    if (this.messageBuffer.length === 0) {\n      return;\n    }\n    // The prepareFlush event allows listeners to append metadata to the batch prior to submission.\n    this.emit(\"prepareSend\", this.messageBuffer);\n    this.connectionManager.sendMessages(this.messageBuffer);\n    this.messageBuffer = [];\n  }\n  get connectionProps() {\n    return Object.assign({\n      sequenceNumber: this.lastSequenceNumber,\n      opsSize: this.opsSize > 0 ? this.opsSize : undefined\n    }, this.connectionManager.connectionProps);\n  }\n  /**\n   * Log error event with a bunch of internal to DeltaManager information about state of op processing\n   * Used to diagnose connectivity issues related to op processing (i.e. cases where for some reason\n   * we stop processing ops that results in no processing join op and thus moving to connected state)\n   * @param event - Event to log.\n   */\n  logConnectionIssue(event) {\n    var _a;\n    assert(this.connectionManager.connected, 0x238 /* \"called only in connected state\" */);\n    const pendingSorted = this.pending.sort((a, b) => a.sequenceNumber - b.sequenceNumber);\n    this.logger.sendErrorEvent(Object.assign(Object.assign(Object.assign(Object.assign({}, event), {\n      // This directly tells us if fetching ops is in flight, and thus likely the reason of\n      // stalled op processing\n      fetchReason: this.fetchReason,\n      // A bunch of useful sequence numbers to understand if we are holding some ops from processing\n      lastQueuedSequenceNumber: this.lastQueuedSequenceNumber,\n      lastProcessedSequenceNumber: this.lastProcessedSequenceNumber,\n      lastObserved: this.lastObservedSeqNumber\n    }), this.connectionManager.connectionVerboseProps), {\n      pendingOps: this.pending.length,\n      pendingFirst: (_a = pendingSorted[0]) === null || _a === void 0 ? void 0 : _a.sequenceNumber,\n      haveHandler: this.handler !== undefined,\n      inboundLength: this.inbound.length,\n      inboundPaused: this.inbound.paused\n    }));\n  }\n  connectHandler(connection) {\n    this.refreshDelayInfo(this.deltaStreamDelayId);\n    const props = this.connectionManager.connectionVerboseProps;\n    props.connectionLastQueuedSequenceNumber = this.lastQueuedSequenceNumber;\n    props.connectionLastObservedSeqNumber = this.lastObservedSeqNumber;\n    const checkpointSequenceNumber = connection.checkpointSequenceNumber;\n    this._checkpointSequenceNumber = checkpointSequenceNumber;\n    if (checkpointSequenceNumber !== undefined) {\n      this.updateLatestKnownOpSeqNumber(checkpointSequenceNumber);\n    }\n    // We cancel all ops on lost of connectivity, and rely on DDSes to resubmit them.\n    // Semantics are not well defined for batches (and they are broken right now on disconnects anyway),\n    // but it's safe to assume (until better design is put into place) that batches should not exist\n    // across multiple connections. Right now we assume runtime will not submit any ops in disconnected\n    // state. As requirements change, so should these checks.\n    assert(this.messageBuffer.length === 0, 0x0e9 /* \"messageBuffer is not empty on new connection\" */);\n    this.opsSize = 0;\n    this.emit(\"connect\", connection, checkpointSequenceNumber !== undefined ? this.lastObservedSeqNumber - this.lastSequenceNumber : undefined);\n    // If we got some initial ops, then we know the gap and call above fetched ops to fill it.\n    // Same is true for \"write\" mode even if we have no ops - we will get \"join\" own op very very soon.\n    // However if we are connecting as view-only, then there is no good signal to realize if client is behind.\n    // Thus we have to hit storage to see if any ops are there.\n    if (checkpointSequenceNumber !== undefined) {\n      // We know how far we are behind (roughly). If it's non-zero gap, fetch ops right away.\n      if (checkpointSequenceNumber > this.lastQueuedSequenceNumber) {\n        this.fetchMissingDeltas(\"AfterConnection\");\n      }\n      // we do not know the gap, and we will not learn about it if socket is quite - have to ask.\n    } else if (connection.mode === \"read\") {\n      this.fetchMissingDeltas(\"AfterReadConnection\");\n    }\n  }\n  dispose() {\n    throw new Error(\"Not implemented.\");\n  }\n  /**\n   * Sets the sequence number from which inbound messages should be returned\n   */\n  attachOpHandler(minSequenceNumber, sequenceNumber, term, handler, prefetchType = \"none\") {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.initSequenceNumber = sequenceNumber;\n      _this.lastProcessedSequenceNumber = sequenceNumber;\n      _this.baseTerm = term;\n      _this.minSequenceNumber = minSequenceNumber;\n      _this.lastQueuedSequenceNumber = sequenceNumber;\n      _this.lastObservedSeqNumber = sequenceNumber;\n      // We will use same check in other places to make sure all the seq number above are set properly.\n      assert(_this.handler === undefined, 0x0e2 /* \"DeltaManager already has attached op handler!\" */);\n      _this.handler = handler;\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      assert(!!_this.handler, 0x0e3 /* \"Newly set op handler is null/undefined!\" */);\n      // There should be no pending fetch!\n      // This API is called right after attachOpHandler by Container.load().\n      // We might have connection already and it might have called fetchMissingDeltas() from\n      // setupNewSuccessfulConnection. But it should do nothing, because there is no way to fetch ops before\n      // we know snapshot sequence number that is set in attachOpHandler. So all such calls should be noop.\n      assert(_this.fetchReason === undefined, 0x268 /* \"There can't be pending fetch that early in boot sequence!\" */);\n      if (_this.closed) {\n        return;\n      }\n      _this._inbound.resume();\n      _this._inboundSignal.resume();\n      if (prefetchType !== \"none\") {\n        const cacheOnly = prefetchType === \"cached\";\n        yield _this.fetchMissingDeltasCore(`DocumentOpen_${prefetchType}`, cacheOnly);\n        // Keep going with fetching ops from storage once we have all cached ops in.\n        // But do not block load and make this request async / not blocking this api.\n        // Ops processing will start once cached ops are in and and will stop when queue is empty\n        // (which in most cases will happen when we are done processing cached ops)\n        if (cacheOnly) {\n          // fire and forget\n          _this.fetchMissingDeltas(\"PostDocumentOpen\");\n        }\n      }\n      // Ensure there is no need to call this.processPendingOps() at the end of boot sequence\n      assert(_this.fetchReason !== undefined || _this.pending.length === 0, 0x269 /* \"pending ops are not dropped\" */);\n    })();\n  }\n\n  connect(args) {\n    var _a;\n    const fetchOpsFromStorage = (_a = args.fetchOpsFromStorage) !== null && _a !== void 0 ? _a : true;\n    logIfFalse(this.handler !== undefined || !fetchOpsFromStorage, this.logger, \"CantFetchWithoutBaseline\"); // can't fetch if no baseline\n    // Note: There is race condition here.\n    // We want to issue request to storage as soon as possible, to\n    // reduce latency of becoming current, thus this code here.\n    // But there is no ordering between fetching OPs and connection to delta stream\n    // As result, we might be behind by the time we connect to delta stream\n    // In case of r/w connection, that's not an issue, because we will hear our\n    // own \"join\" message and realize any gap client has in ops.\n    // But for view-only connection, we have no such signal, and with no traffic\n    // on the wire, we might be always behind.\n    // See comment at the end of \"connect\" handler\n    if (fetchOpsFromStorage) {\n      this.fetchMissingDeltas(args.reason);\n    }\n    this.connectionManager.connect(args.mode);\n  }\n  getDeltas(from,\n  // inclusive\n  to,\n  // exclusive\n  fetchReason, callback, cacheOnly) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const docService = _this2.serviceProvider();\n      if (docService === undefined) {\n        throw new Error(\"Delta manager is not attached\");\n      }\n      if (_this2.deltaStorage === undefined) {\n        _this2.deltaStorage = yield docService.connectToDeltaStorage();\n      }\n      let cancelFetch;\n      if (to !== undefined) {\n        const lastExpectedOp = to - 1; // make it inclusive!\n        // It is possible that due to asynchrony (including await above), required ops were already\n        // received through delta stream. Validate that before moving forward.\n        if (_this2.lastQueuedSequenceNumber >= lastExpectedOp) {\n          _this2.logger.sendPerformanceEvent(Object.assign({\n            reason: fetchReason,\n            eventName: \"ExtraStorageCall\",\n            early: true,\n            from,\n            to\n          }, _this2.connectionManager.connectionVerboseProps));\n          return;\n        }\n        // Be prepared for the case where webSocket would receive the ops that we are trying to fill through\n        // storage. Ideally it should never happen (i.e. ops on socket are always ordered, and thus once we\n        // detected gap, this gap can't be filled in later on through websocket).\n        // And in practice that does look like the case. The place where this code gets hit is if we lost\n        // connection and reconnected (likely to another box), and new socket's initial ops contains these ops.\n        cancelFetch = op => op.sequenceNumber >= lastExpectedOp;\n      } else {\n        // Unbound requests are made to proactively fetch ops, but also get up to date in cases where socket\n        // is silent (and connection is \"read\", thus we might not have any data on how far client is behind).\n        // Once we have any op coming in from socket, we can cancel it as it's not needed any more.\n        // That said, if we have socket connection, make sure we got ops up to checkpointSequenceNumber!\n        cancelFetch = op => op.sequenceNumber >= _this2.lastObservedSeqNumber;\n      }\n      const controller = new AbortController();\n      let opsFromFetch = false;\n      const opListener = op => {\n        assert(op.sequenceNumber === _this2.lastQueuedSequenceNumber, 0x23a /* \"seq#'s\" */);\n        // Ops that are coming from this request should not cancel itself.\n        // This is useless for known ranges (to is defined) as it means request is over either way.\n        // And it will cancel unbound request too early, not allowing us to learn where the end of the file is.\n        if (!opsFromFetch && cancelFetch(op)) {\n          controller.abort();\n          _this2._inbound.off(\"push\", opListener);\n        }\n      };\n      try {\n        _this2._inbound.on(\"push\", opListener);\n        assert(_this2.closeAbortController.signal.onabort === null, 0x1e8 /* \"reentrancy\" */);\n        _this2.closeAbortController.signal.onabort = () => controller.abort();\n        const stream = _this2.deltaStorage.fetchMessages(from,\n        // inclusive\n        to,\n        // exclusive\n        controller.signal, cacheOnly, fetchReason);\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n          const result = yield stream.read();\n          if (result.done) {\n            break;\n          }\n          try {\n            opsFromFetch = true;\n            callback(result.value);\n          } finally {\n            opsFromFetch = false;\n          }\n        }\n      } finally {\n        _this2.closeAbortController.signal.onabort = null;\n        _this2._inbound.off(\"push\", opListener);\n        assert(!opsFromFetch, 0x289 /* \"logic error\" */);\n      }\n    })();\n  }\n  /**\n   * Closes the connection and clears inbound & outbound queues.\n   */\n  close(error) {\n    if (this.closed) {\n      return;\n    }\n    this.closed = true;\n    this.connectionManager.dispose(error);\n    this.closeAbortController.abort();\n    this._inbound.clear();\n    this._inboundSignal.clear();\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this._inbound.pause();\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this._inboundSignal.pause();\n    // Drop pending messages - this will ensure catchUp() does not go into infinite loop\n    this.pending = [];\n    // This needs to be the last thing we do (before removing listeners), as it causes\n    // Container to dispose context and break ability of data stores / runtime to \"hear\"\n    // from delta manager, including notification (above) about readonly state.\n    this.emit(\"closed\", error);\n    this.removeAllListeners();\n  }\n  refreshDelayInfo(id) {\n    this.throttlingIdSet.delete(id);\n    if (this.throttlingIdSet.size === 0) {\n      this.timeTillThrottling = 0;\n    }\n  }\n  disconnectHandler(reason) {\n    this.messageBuffer.length = 0;\n    this.emit(\"disconnect\", reason);\n  }\n  /**\n   * Emit info about a delay in service communication on account of throttling.\n   * @param id - Id of the connection that is delayed\n   * @param delayMs - Duration of the delay\n   * @param error - error object indicating the throttling\n   */\n  emitDelayInfo(id, delayMs, error) {\n    const timeNow = Date.now();\n    this.throttlingIdSet.add(id);\n    if (delayMs > 0 && timeNow + delayMs > this.timeTillThrottling) {\n      this.timeTillThrottling = timeNow + delayMs;\n      const throttlingWarning = ThrottlingWarning.wrap(error, delayMs / 1000 /* retryAfterSeconds */, this.logger);\n      this.emit(\"throttled\", throttlingWarning);\n    }\n  }\n  // returns parts of message (in string format) that should never change for a given message.\n  // Used for message comparison. It attempts to avoid comparing fields that potentially may differ.\n  // for example, it's not clear if serverMetadata or timestamp property is a property of message or server state.\n  // We only extract the most obvious fields that are sufficient (with high probability) to detect sequence number\n  // reuse.\n  // Also payload goes to telemetry, so no PII, including content!!\n  // Note: It's possible for a duplicate op to be broadcasted and have everything the same except the timestamp.\n  comparableMessagePayload(m) {\n    return `${m.clientId}-${m.type}-${m.minimumSequenceNumber}-${m.referenceSequenceNumber}-${m.timestamp}`;\n  }\n  enqueueMessages(messages, reason, allowGaps = false) {\n    var _a, _b;\n    if (this.handler === undefined) {\n      // We did not setup handler yet.\n      // This happens when we connect to web socket faster than we get attributes for container\n      // and thus faster than attachOpHandler() is called\n      // this.lastProcessedSequenceNumber is still zero, so we can't rely on this.fetchMissingDeltas()\n      // to do the right thing.\n      this.pending = this.pending.concat(messages);\n      return;\n    }\n    // Pending ops should never just hang around for nothing.\n    // This invariant will stay true through this function execution,\n    // so there is no need to process pending ops here.\n    // It's responsibility of\n    // - attachOpHandler()\n    // - fetchMissingDeltas() after it's done with querying storage\n    assert(this.pending.length === 0 || this.fetchReason !== undefined, 0x1e9 /* \"Pending ops\" */);\n    if (messages.length === 0) {\n      return;\n    }\n    const from = messages[0].sequenceNumber;\n    const last = messages[messages.length - 1].sequenceNumber;\n    // Report stats about missing and duplicate ops\n    // This helps better understand why we fetch ops from storage, and thus may delay\n    // getting current / sending ops\n    // It's possible that this batch is already too late - do not bother\n    if (last > this.lastQueuedSequenceNumber) {\n      let prev = from - 1;\n      const initialGap = prev - this.lastQueuedSequenceNumber;\n      let firstMissing;\n      let duplicate = 0;\n      let gap = 0;\n      // Count all gaps and duplicates\n      for (const message of messages) {\n        if (message.sequenceNumber === prev) {\n          duplicate++;\n        } else if (message.sequenceNumber !== prev + 1) {\n          gap++;\n          if (firstMissing === undefined) {\n            firstMissing = prev + 1;\n          }\n        }\n        prev = message.sequenceNumber;\n      }\n      let eventName;\n      // Report if we found some issues\n      if (duplicate !== 0 || gap !== 0 && !allowGaps || initialGap > 0 && this.fetchReason === undefined) {\n        eventName = \"enqueueMessages\";\n        // Also report if we are fetching ops, and same range comes in, thus making this fetch obsolete.\n      } else if (this.fetchReason !== undefined && this.fetchReason !== reason && from <= this.lastQueuedSequenceNumber + 1 && last > this.lastQueuedSequenceNumber) {\n        eventName = \"enqueueMessagesExtraFetch\";\n      }\n      // Report if there is something to report\n      // Do not report when pending fetch is in progress, as such reporting will not\n      // correctly take into account pending ops.\n      if (eventName !== undefined) {\n        this.logger.sendPerformanceEvent(Object.assign({\n          eventName,\n          reason,\n          previousReason: this.prevEnqueueMessagesReason,\n          from,\n          to: last + 1,\n          length: messages.length,\n          fetchReason: this.fetchReason,\n          duplicate: duplicate > 0 ? duplicate : undefined,\n          initialGap: initialGap !== 0 ? initialGap : undefined,\n          gap: gap > 0 ? gap : undefined,\n          firstMissing,\n          dmInitialSeqNumber: this.initialSequenceNumber\n        }, this.connectionManager.connectionVerboseProps));\n      }\n    }\n    this.updateLatestKnownOpSeqNumber(messages[messages.length - 1].sequenceNumber);\n    const n = (_a = this.previouslyProcessedMessage) === null || _a === void 0 ? void 0 : _a.sequenceNumber;\n    assert(n === undefined || n === this.lastQueuedSequenceNumber, 0x0ec /* \"Unexpected value for previously processed message's sequence number\" */);\n    for (const message of messages) {\n      // Check that the messages are arriving in the expected order\n      if (message.sequenceNumber <= this.lastQueuedSequenceNumber) {\n        // Validate that we do not have data loss, i.e. sequencing is reset and started again\n        // with numbers that this client already observed before.\n        if (((_b = this.previouslyProcessedMessage) === null || _b === void 0 ? void 0 : _b.sequenceNumber) === message.sequenceNumber) {\n          const message1 = this.comparableMessagePayload(this.previouslyProcessedMessage);\n          const message2 = this.comparableMessagePayload(message);\n          if (message1 !== message2) {\n            const error = new NonRetryableError(\n            // This looks like a data corruption but the culprit was that the file was overwritten\n            // in storage.  See PR #5882.\n            // Likely to be an issue with Fluid Services. Content does not match previous client\n            // knowledge about this file. If the file is overwritten for any reason, this error can be\n            // hit. One example is that some clients could be submitting ops to two different service\n            // instances such that the same sequence number is reused for two different ops.\n            // pre-0.58 error message: twoMessagesWithSameSeqNumAndDifferentPayload\n            \"Found two messages with the same sequenceNumber but different payloads. Likely to be a \" + \"service issue\", DriverErrorType.fileOverwrittenInStorage, {\n              clientId: this.connectionManager.clientId,\n              sequenceNumber: message.sequenceNumber,\n              message1,\n              message2,\n              driverVersion: undefined\n            });\n            this.close(error);\n          }\n        }\n      } else if (message.sequenceNumber !== this.lastQueuedSequenceNumber + 1) {\n        this.pending.push(message);\n        this.fetchMissingDeltas(reason, message.sequenceNumber);\n      } else {\n        this.lastQueuedSequenceNumber = message.sequenceNumber;\n        this.previouslyProcessedMessage = message;\n        this._inbound.push(message);\n      }\n    }\n    // When / if we report a gap in ops in the future, we want telemetry to correctly reflect source\n    // of prior ops. But if we have some out of order ops (this.pending), then reporting current reason\n    // becomes not accurate, as the gap existed before current batch, so we should just report \"unknown\".\n    this.prevEnqueueMessagesReason = this.pending.length > 0 ? \"unknown\" : reason;\n  }\n  processInboundMessage(message) {\n    const startTime = Date.now();\n    this.lastProcessedMessage = message;\n    // All non-system messages are coming from some client, and should have clientId\n    // System messages may have no clientId (but some do, like propose, noop, summarize)\n    assert(message.clientId !== undefined || !isClientMessage(message), 0x0ed /* \"non-system message have to have clientId\" */);\n    // TODO Remove after SPO picks up the latest build.\n    if (typeof message.contents === \"string\" && message.contents !== \"\" && message.type !== MessageType.ClientLeave) {\n      message.contents = JSON.parse(message.contents);\n    }\n    this.connectionManager.beforeProcessingIncomingOp(message);\n    // Watch the minimum sequence number and be ready to update as needed\n    if (this.minSequenceNumber > message.minimumSequenceNumber) {\n      // pre-0.58 error message: msnMovesBackwards\n      throw new DataCorruptionError(\"Found a lower minimumSequenceNumber (msn) than previously recorded\", Object.assign(Object.assign({}, extractSafePropertiesFromMessage(message)), {\n        clientId: this.connectionManager.clientId\n      }));\n    }\n    this.minSequenceNumber = message.minimumSequenceNumber;\n    if (message.sequenceNumber !== this.lastProcessedSequenceNumber + 1) {\n      // pre-0.58 error message: nonSequentialSequenceNumber\n      throw new DataCorruptionError(\"Found a non-Sequential sequenceNumber\", Object.assign(Object.assign({}, extractSafePropertiesFromMessage(message)), {\n        clientId: this.connectionManager.clientId\n      }));\n    }\n    this.lastProcessedSequenceNumber = message.sequenceNumber;\n    // a bunch of code assumes that this is true\n    assert(this.lastProcessedSequenceNumber <= this.lastObservedSeqNumber, 0x267 /* \"lastObservedSeqNumber should be updated first\" */);\n    // Back-compat for older server with no term\n    if (message.term === undefined) {\n      message.term = 1;\n    }\n    this.baseTerm = message.term;\n    if (this.handler === undefined) {\n      throw new Error(\"Attempted to process an inbound message without a handler attached\");\n    }\n    this.handler.process(message);\n    const endTime = Date.now();\n    // Should be last, after changing this.lastProcessedSequenceNumber above, as many callers\n    // test this.lastProcessedSequenceNumber instead of using op.sequenceNumber itself.\n    this.emit(\"op\", message, endTime - startTime);\n  }\n  /**\n   * Retrieves the missing deltas between the given sequence numbers\n   */\n  fetchMissingDeltas(reasonArg, to) {\n    this.fetchMissingDeltasCore(reasonArg, false /* cacheOnly */, to).catch(error => {\n      this.logger.sendErrorEvent({\n        eventName: \"fetchMissingDeltasException\"\n      }, error);\n    });\n  }\n  /**\n  * Retrieves the missing deltas between the given sequence numbers\n  */\n  fetchMissingDeltasCore(reason, cacheOnly, to) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      // Exit out early if we're already fetching deltas\n      if (_this3.fetchReason !== undefined) {\n        return;\n      }\n      if (_this3.closed) {\n        _this3.logger.sendTelemetryEvent({\n          eventName: \"fetchMissingDeltasClosedConnection\",\n          reason\n        });\n        return;\n      }\n      if (_this3.handler === undefined) {\n        // We do not poses yet any information\n        assert(_this3.lastQueuedSequenceNumber === 0, 0x26b /* \"initial state\" */);\n        return;\n      }\n      try {\n        let from = _this3.lastQueuedSequenceNumber + 1;\n        const n = (_a = _this3.previouslyProcessedMessage) === null || _a === void 0 ? void 0 : _a.sequenceNumber;\n        if (n !== undefined) {\n          // If we already processed at least one op, then we have this.previouslyProcessedMessage populated\n          // and can use it to validate that we are operating on same file, i.e. it was not overwritten.\n          // Knowing about this mechanism, we could ask for op we already observed to increase validation.\n          // This is especially useful when coming out of offline mode or loading from\n          // very old cached (by client / driver) snapshot.\n          assert(n === _this3.lastQueuedSequenceNumber, 0x0f2 /* \"previouslyProcessedMessage\" */);\n          assert(from > 1, 0x0f3 /* \"not positive\" */);\n          from--;\n        }\n        const fetchReason = `${reason}_fetch`;\n        _this3.fetchReason = fetchReason;\n        yield _this3.getDeltas(from, to, fetchReason, messages => {\n          _this3.refreshDelayInfo(_this3.deltaStorageDelayId);\n          _this3.enqueueMessages(messages, fetchReason);\n        }, cacheOnly);\n      } catch (error) {\n        _this3.logger.sendErrorEvent({\n          eventName: \"GetDeltas_Exception\"\n        }, error);\n        _this3.close(normalizeError(error));\n      } finally {\n        _this3.refreshDelayInfo(_this3.deltaStorageDelayId);\n        _this3.fetchReason = undefined;\n        _this3.processPendingOps(reason);\n      }\n    })();\n  }\n  /**\n   * Sorts pending ops and attempts to apply them\n   */\n  processPendingOps(reason) {\n    if (this.closed) {\n      return;\n    }\n    assert(this.handler !== undefined, 0x26c /* \"handler should be installed\" */);\n    const pendingSorted = this.pending.sort((a, b) => a.sequenceNumber - b.sequenceNumber);\n    this.pending = [];\n    // Given that we do not track where these ops came from any more, it's not very\n    // actionably to report gaps in this range.\n    this.enqueueMessages(pendingSorted, `${reason}_pending`, true /* allowGaps */);\n    // Re-entrancy is ignored by fetchMissingDeltas, execution will come here when it's over\n    if (this.fetchReason === undefined) {\n      // See issue #7312 for more details\n      // We observe cases where client gets into situation where it is not aware of missing ops\n      // (i.e. client being behind), and as such, does not attempt to fetch them.\n      // In some cases client may not have enough signal (example - \"read\" connection that is silent -\n      // there is no easy way for client to realize it's behind, see a bit of commentary / logic at the\n      // end of setupNewSuccessfulConnection). In other cases it should be able to learn that info (\"write\"\n      // connection, learn by receiving its own join op), but data suggest it does not happen.\n      // In 50% of these cases we do know we are behind through checkpointSequenceNumber on connection object\n      // and thus can leverage that to trigger recovery. But this is not going to solve all the problems\n      // (the other 50%), and thus these errors below should be looked at even if code below results in\n      // recovery.\n      if (this.lastQueuedSequenceNumber < this.lastObservedSeqNumber) {\n        this.fetchMissingDeltas(\"OpsBehind\");\n      }\n    }\n  }\n  updateLatestKnownOpSeqNumber(seq) {\n    if (this.lastObservedSeqNumber < seq) {\n      this.lastObservedSeqNumber = seq;\n    }\n  }\n}\n//# sourceMappingURL=deltaManager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}