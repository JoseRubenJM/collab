{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { v4 as uuid } from \"uuid\";\nimport { assert } from \"@fluidframework/common-utils\";\nimport { AttachState } from \"@fluidframework/container-definitions\";\nimport { convertToSummaryTreeWithStats, FluidSerializer } from \"@fluidframework/runtime-utils\";\nimport { ChildLogger, EventEmitterWithErrorHandling } from \"@fluidframework/telemetry-utils\";\nimport { SharedObjectHandle } from \"./handle\";\nimport { SummarySerializer } from \"./summarySerializer\";\n/**\n *  Base class from which all shared objects derive\n */\nexport class SharedObject extends EventEmitterWithErrorHandling {\n  /**\n   * @param id - The id of the shared object\n   * @param runtime - The IFluidDataStoreRuntime which contains the shared object\n   * @param attributes - Attributes of the shared object\n   */\n  constructor(id, runtime, attributes) {\n    super();\n    this.id = id;\n    this.runtime = runtime;\n    this.attributes = attributes;\n    /**\n     * Connection state\n     */\n    this._connected = false;\n    /**\n     * True if the dds is bound to its parent.\n     */\n    this._isBoundToContext = false;\n    /**\n     * True while we are summarizing this object's data.\n     */\n    this._isSummarizing = false;\n    this.handle = new SharedObjectHandle(this, id, runtime.IFluidHandleContext);\n    // Runtime could be null since some package hasn't turn on strictNullChecks yet\n    // We should remove the null check once that is done\n    this.logger = ChildLogger.create(\n    // eslint-disable-next-line no-null/no-null\n    runtime !== null ? runtime.logger : undefined, undefined, {\n      sharedObjectId: uuid()\n    });\n    this._serializer = new FluidSerializer(this.runtime.channelsRoutingContext);\n    this.attachListeners();\n  }\n  /**\n   * @param obj - The thing to check if it is a SharedObject\n   * @returns Returns true if the thing is a SharedObject\n   */\n  static is(obj) {\n    var _a;\n    return ((_a = obj) === null || _a === void 0 ? void 0 : _a.ISharedObject) !== undefined;\n  }\n  get ISharedObject() {\n    return this;\n  }\n  get IChannel() {\n    return this;\n  }\n  get IFluidLoadable() {\n    return this;\n  }\n  /**\n   * Gets the connection state\n   * @returns The state of the connection\n   */\n  get connected() {\n    return this._connected;\n  }\n  // Back-compat <= 0.28\n  get url() {\n    return this.id;\n  }\n  get serializer() {\n    /**\n     * During summarize, the SummarySerializer keeps track of IFluidHandles that are serialized. These handles\n     * represent references to other Fluid objects and are used for garbage collection.\n     *\n     * This is fine for now. However, if we implement delay loading in DDss, they may load and de-serialize content\n     * in summarize. When that happens, they may incorrectly hit this assert and we will have to change this.\n     */\n    assert(!this._isSummarizing, \"SummarySerializer should be used for serializing data during summary.\");\n    return this._serializer;\n  }\n  attachListeners() {\n    this.on(\"error\", error => {\n      this.runtime.raiseContainerWarning(error);\n    });\n    // Only listen to these events if not attached.\n    if (!this.isAttached()) {\n      this.runtime.once(\"attaching\", () => {\n        // Calling this will let the dds to do any custom processing based on attached\n        // like starting generating ops.\n        this.didAttach();\n      });\n    }\n  }\n  /**\n   * Not supported - use handles instead\n   */\n  toJSON() {\n    throw new Error(\"Only the handle can be converted to JSON\");\n  }\n  /**\n   * A shared object, after construction, can either be loaded in the case that it is already part of\n   * a shared document. Or later attached if it is being newly added.\n   * @param services - Services used by the shared object\n   */\n  load(services) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (_this.runtime.attachState !== AttachState.Detached) {\n        _this.services = services;\n      }\n      yield _this.loadCore(services.objectStorage);\n      if (_this.runtime.attachState !== AttachState.Detached) {\n        _this.attachDeltaHandler();\n      }\n    })();\n  }\n  /**\n   * Initializes the object as a local, non-shared object. This object can become shared after\n   * it is attached to the document.\n   */\n  initializeLocal() {\n    this.initializeLocalCore();\n  }\n  /**\n   * {@inheritDoc (ISharedObject:interface).bindToContext}\n   */\n  bindToContext() {\n    if (this._isBoundToContext) {\n      return;\n    }\n    this._isBoundToContext = true;\n    this.setOwner();\n    // Allow derived classes to perform custom processing prior to registering this object\n    this.registerCore();\n    this.runtime.bindChannel(this);\n  }\n  /**\n   * {@inheritDoc (ISharedObject:interface).connect}\n   */\n  connect(services) {\n    this.services = services;\n    this.attachDeltaHandler();\n  }\n  /**\n   * {@inheritDoc (ISharedObject:interface).isAttached}\n   */\n  isAttached() {\n    return this.services !== undefined && this.runtime.attachState !== AttachState.Detached;\n  }\n  /**\n   * {@inheritDoc (ISharedObject:interface).summarize}\n   */\n  summarize(fullTree = false, trackState = false) {\n    // Set _isSummarizing to true. This flag is used to ensure that we only use SummarySerializer (created below)\n    // to serialize handles in this object's data. The routes of these serialized handles are outbound routes\n    // to other Fluid objects.\n    assert(!this._isSummarizing, \"Possible re-entrancy! Summary should not already be in progress.\");\n    this._isSummarizing = true;\n    let summaryTree;\n    let gcData;\n    try {\n      const serializer = new SummarySerializer(this.runtime.channelsRoutingContext);\n      const snapshot = this.snapshotCore(serializer);\n      summaryTree = convertToSummaryTreeWithStats(snapshot, fullTree);\n      // Add this channel's garbage collection data to the summarize result. The outbound routes of this channel\n      // are all the routes of all the handles that are tracked by the SummarySerializer above.\n      gcData = {\n        gcNodes: {\n          \"/\": serializer.getSerializedRoutes()\n        }\n      };\n      assert(this._isSummarizing, \"Possible re-entrancy! Summary should have been in progress.\");\n    } finally {\n      this._isSummarizing = false;\n    }\n    return Object.assign(Object.assign({}, summaryTree), {\n      gcData\n    });\n  }\n  /**\n   * {@inheritDoc (ISharedObject:interface).getGCData}\n   */\n  getGCData() {\n    // We run the full summarize logic to get the list of outbound routes from this object. This is a little\n    // expensive but its okay for now. It will be udpated to not use full summarize and make it more efficient.\n    // See: https://github.com/microsoft/FluidFramework/issues/4547\n    // Set _isSummarizing to true. This flag is used to ensure that we only use SummarySerializer (created below)\n    // to serialize handles in this object's data. The routes of these serialized handles are outbound routes\n    // to other Fluid objects.\n    assert(!this._isSummarizing, \"Possible re-entrancy! Summary should not already be in progress.\");\n    this._isSummarizing = true;\n    let gcData;\n    try {\n      const serializer = new SummarySerializer(this.runtime.channelsRoutingContext);\n      this.snapshotCore(serializer);\n      // The GC data for this shared object contains a single GC node. The outbound routes of this node are the\n      // routes of handles serialized during snapshot.\n      gcData = {\n        gcNodes: {\n          \"/\": serializer.getSerializedRoutes()\n        }\n      };\n      assert(this._isSummarizing, \"Possible re-entrancy! Summary should have been in progress.\");\n    } finally {\n      this._isSummarizing = false;\n    }\n    return gcData;\n  }\n  /**\n   * back-compat 0.30 - This is deprecated. summarize() should be used instead.\n   */\n  snapshot() {\n    return this.snapshotCore(this.serializer);\n  }\n  /**\n   * Set the owner of the object if it is an OwnedSharedObject\n   * @returns The owner of the object if it is an OwnedSharedObject, otherwise undefined\n   */\n  setOwner() {\n    return;\n  }\n  /**\n   * Allows the distributed data type to perform custom local loading.\n   */\n  initializeLocalCore() {\n    return;\n  }\n  /**\n   * Allows the distributive data type the ability to perform custom processing once an attach has happened.\n   * Also called after non-local data type get loaded.\n   */\n  didAttach() {\n    return;\n  }\n  /**\n   * Submits a message by the local client to the runtime.\n   * @param content - Content of the message\n   * @param localOpMetadata - The local metadata associated with the message. This is kept locally by the runtime\n   * and not sent to the server. This will be sent back when this message is received back from the server. This is\n   * also sent if we are asked to resubmit the message.\n   */\n  submitLocalMessage(content, localOpMetadata = undefined) {\n    if (this.isAttached()) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.services.deltaConnection.submit(content, localOpMetadata);\n    }\n  }\n  /**\n   * Marks this object as dirty so that it is part of the next summary. It is called by a SharedSummaryBlock\n   * that want to be part of summary but does not generate ops.\n   */\n  dirty() {\n    if (!this.isAttached()) {\n      return;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.services.deltaConnection.dirty();\n  }\n  /**\n   * Called when the object has fully connected to the delta stream\n   * Default implementation for DDS, override if different behavior is required.\n   */\n  onConnect() {}\n  /**\n   * Called when a message has to be resubmitted. This typically happens after a reconnection for unacked messages.\n   * The default implementation here is to resubmit the same message. The client can override if different behavior\n   * is required. It can choose to resubmit the same message, submit different / multiple messages or not submit\n   * anything at all.\n   * @param content - The content of the original message.\n   * @param localOpMetadata - The local metadata associated with the original message.\n   */\n  reSubmitCore(content, localOpMetadata) {\n    this.submitLocalMessage(content, localOpMetadata);\n  }\n  /**\n   * Promises that are waiting for an ack from the server before resolving should use this instead of new Promise.\n   * It ensures that if something changes that will interrupt that ack (e.g. the FluidDataStoreRuntime disposes),\n   * the Promise will reject.\n   * If runtime is disposed when this call is made, executor is not run and promise is rejected right away.\n   */\n  newAckBasedPromise(executor) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      let rejectBecauseDispose;\n      return new Promise((resolve, reject) => {\n        rejectBecauseDispose = () => reject(new Error(\"FluidDataStoreRuntime disposed while this ack-based Promise was pending\"));\n        if (_this2.runtime.disposed) {\n          rejectBecauseDispose();\n          return;\n        }\n        _this2.runtime.on(\"dispose\", rejectBecauseDispose);\n        executor(resolve, reject);\n      }).finally(() => {\n        // Note: rejectBecauseDispose will never be undefined here\n        _this2.runtime.off(\"dispose\", rejectBecauseDispose);\n      });\n    })();\n  }\n  /**\n   * Report ignorable errors in code logic or data integrity to the logger.\n   * Hosting app / container may want to optimize out these call sites and make them no-op.\n   * It may also show assert dialog in non-production builds of application.\n   * @param condition - If false, assert is logged\n   * @param message - Actual message to log; ideally should be unique message to identify call site\n   */\n  debugAssert(condition, event) {\n    this.logger.debugAssert(condition, event);\n  }\n  attachDeltaHandler() {\n    // Services should already be there in case we are attaching delta handler.\n    assert(this.services !== undefined, \"Services should be there to attach delta handler\");\n    this._isBoundToContext = true;\n    // Allows objects to do any custom processing if it is attached.\n    this.didAttach();\n    // attachDeltaHandler is only called after services is assigned\n    this.services.deltaConnection.attach({\n      process: (message, local, localOpMetadata) => {\n        this.process(message, local, localOpMetadata);\n      },\n      setConnectionState: connected => {\n        this.setConnectionState(connected);\n      },\n      reSubmit: (content, localOpMetadata) => {\n        this.reSubmit(content, localOpMetadata);\n      }\n    });\n    // Trigger initial state\n    // attachDeltaHandler is only called after services is assigned\n    this.setConnectionState(this.services.deltaConnection.connected);\n  }\n  /**\n   * Set the state of connection to services.\n   * @param connected - true if connected, false otherwise.\n   */\n  setConnectionState(connected) {\n    if (this._connected === connected) {\n      // Not changing state, nothing the same.\n      return;\n    }\n    // Should I change the state at the end? So that we *can't* send new stuff before we send old?\n    this._connected = connected;\n    if (!connected) {\n      // Things that are true now...\n      // - if we had a connection we can no longer send messages over it\n      // - if we had outbound messages some may or may not be ACK'd. Won't know until next message\n      //\n      // - nack could get a new msn - but might as well do it in the join?\n      this.onDisconnect();\n    } else {\n      // Call this for now so that DDSes like ConsensesOrderedCollection that maintain their own pending\n      // messages will work.\n      this.onConnect();\n    }\n  }\n  /**\n   * Handles a message being received from the remote delta server.\n   * @param message - The message to process\n   * @param local - Whether the message originated from the local client\n   * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n   * For messages from a remote client, this will be undefined.\n   */\n  process(message, local, localOpMetadata) {\n    this.emit(\"pre-op\", message, local, this);\n    this.processCore(message, local, localOpMetadata);\n    this.emit(\"op\", message, local, this);\n  }\n  /**\n   * Called when a message has to be resubmitted. This typically happens for unacked messages after a\n   * reconnection.\n   * @param content - The content of the original message.\n   * @param localOpMetadata - The local metadata associated with the original message.\n   */\n  reSubmit(content, localOpMetadata) {\n    this.reSubmitCore(content, localOpMetadata);\n  }\n}\n//# sourceMappingURL=sharedObject.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}