{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport * as MergeTree from \"@fluidframework/merge-tree\";\nimport { SharedSegmentSequence } from \"./sequence\";\nimport { SharedStringFactory } from \"./sequenceFactory\";\n/**\n * The Shared String is a specialized data structure for handling collaborative\n *  text. It is based on a more general Sequence data structure but has\n * additional features that make working with text easier.\n *\n * In addition to text, a Shared String can also contain markers. Markers can be\n * used to store metadata at positions within the text, like the details of an\n * image or Fluid object that should be rendered with the text.\n *\n */\nexport class SharedString extends SharedSegmentSequence {\n  constructor(document, id, attributes) {\n    super(document, id, attributes, SharedStringFactory.segmentFromSpec);\n    this.id = id;\n    this.mergeTreeTextHelper = this.client.createTextHelper();\n  }\n  /**\n   * Create a new shared string\n   *\n   * @param runtime - data store runtime the new shared string belongs to\n   * @param id - optional name of the shared string\n   * @returns newly create shared string (but not attached yet)\n   */\n  static create(runtime, id) {\n    return runtime.createChannel(id, SharedStringFactory.Type);\n  }\n  /**\n   * Get a factory for SharedString to register with the data store.\n   *\n   * @returns a factory that creates and load SharedString\n   */\n  static getFactory() {\n    return new SharedStringFactory();\n  }\n  get ISharedString() {\n    return this;\n  }\n  /**\n   * Inserts a marker at a relative postition\n   *\n   * @param relativePos1 - The relative postition to insert the marker at\n   * @param refType - The reference type of the marker\n   * @param props - The properties of the marker\n   */\n  insertMarkerRelative(relativePos1, refType, props) {\n    const segment = new MergeTree.Marker(refType);\n    if (props) {\n      segment.addProperties(props);\n    }\n    const pos = this.posFromRelativePos(relativePos1);\n    const insertOp = this.client.insertSegmentLocal(pos, segment);\n    if (insertOp) {\n      this.submitSequenceMessage(insertOp);\n    }\n  }\n  /**\n   * Inserts a marker at the postition\n   *\n   * @param pos - The postition to insert the marker at\n   * @param refType - The reference type of the marker\n   * @param props - The properties of the marker\n   */\n  insertMarker(pos, refType, props) {\n    const segment = new MergeTree.Marker(refType);\n    if (props) {\n      segment.addProperties(props);\n    }\n    const insertOp = this.client.insertSegmentLocal(pos, segment);\n    if (insertOp) {\n      this.submitSequenceMessage(insertOp);\n    }\n    return insertOp;\n  }\n  /**\n   * Inserts the text at the postition\n   *\n   * @param relativePos1 - The relative postition to insert the text at\n   * @param text - The text to insert\n   * @param props - The properties of text\n   */\n  insertTextRelative(relativePos1, text, props) {\n    const segment = new MergeTree.TextSegment(text);\n    if (props) {\n      segment.addProperties(props);\n    }\n    const pos = this.posFromRelativePos(relativePos1);\n    const insertOp = this.client.insertSegmentLocal(pos, segment);\n    if (insertOp) {\n      this.submitSequenceMessage(insertOp);\n    }\n  }\n  /**\n   * Inserts the text at the postition\n   *\n   * @param pos - The  postition to insert the text at\n   * @param text - The text to insert\n   * @param props - The properties of text\n   */\n  insertText(pos, text, props) {\n    const segment = new MergeTree.TextSegment(text);\n    if (props) {\n      segment.addProperties(props);\n    }\n    const insertOp = this.client.insertSegmentLocal(pos, segment);\n    if (insertOp) {\n      this.submitSequenceMessage(insertOp);\n    }\n  }\n  /**\n   * Replaces a range with the provided text.\n   *\n   * @param start - The inclusive start of the range to replace\n   * @param end - The exclusive end of the range to replace\n   * @param text - The text to replace the range with\n   * @param props - Optional. The properties of the replacement text\n   */\n  replaceText(start, end, text, props) {\n    this.replaceRange(start, end, MergeTree.TextSegment.make(text, props));\n  }\n  removeText(start, end) {\n    return this.removeRange(start, end);\n  }\n  /**\n   * Annotates the marker with the provided properties\n   * and calls the callback on concensus.\n   *\n   * @param marker - The marker to annotate\n   * @param props - The properties to annotate the marker with\n   * @param consensusCallback - The callback called when consensus is reached\n   */\n  annotateMarkerNotifyConsensus(marker, props, callback) {\n    const annotateOp = this.client.annotateMarkerNotifyConsensus(marker, props, callback);\n    if (annotateOp) {\n      this.submitSequenceMessage(annotateOp);\n    }\n  }\n  /**\n   * Annotates the marker with the provided properties\n   *\n   * @param marker - The marker to annotate\n   * @param props - The properties to annotate the marker with\n   * @param combiningOp - Optional. Specifies how to combine values for the property, such as \"incr\" for increment.\n   */\n  annotateMarker(marker, props, combiningOp) {\n    const annotateOp = this.client.annotateMarker(marker, props, combiningOp);\n    if (annotateOp) {\n      this.submitSequenceMessage(annotateOp);\n    }\n  }\n  findTile(startPos, tileLabel, preceding = true) {\n    return this.client.findTile(startPos, tileLabel, preceding);\n  }\n  getTextAndMarkers(label) {\n    const segmentWindow = this.client.getCollabWindow();\n    return this.mergeTreeTextHelper.getTextAndMarkers(segmentWindow.currentSeq, segmentWindow.clientId, label);\n  }\n  getText(start, end) {\n    const segmentWindow = this.client.getCollabWindow();\n    return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, \"\", start, end);\n  }\n  /**\n   * Adds spaces for markers and handles, so that position calculations account for them\n   */\n  getTextWithPlaceholders() {\n    const segmentWindow = this.client.getCollabWindow();\n    return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, \" \");\n  }\n  getTextRangeWithPlaceholders(start, end) {\n    const segmentWindow = this.client.getCollabWindow();\n    return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, \" \", start, end);\n  }\n  getTextRangeWithMarkers(start, end) {\n    const segmentWindow = this.client.getCollabWindow();\n    return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, \"*\", start, end);\n  }\n  getMarkerFromId(id) {\n    return this.client.getMarkerFromId(id);\n  }\n}\n//# sourceMappingURL=sharedString.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}