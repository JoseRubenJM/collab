{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { performance } from \"@fluidframework/common-utils\";\n/**\n * DeltaScheduler is responsible for the scheduling of inbound delta queue in cases where there\n * is more than one op a particular run of the queue. It does not schedule if there is just one\n * op or just one batch in the run. It does the following two things:\n * 1. If the ops have been processed for more than a specific amount of time, it pauses the queue\n *    and calls setTimeout to schedule a resume of the queue. This ensures that we don't block\n *    the JS thread for a long time processing ops synchronously (for example, when catching up\n *    ops right after boot or catching up ops / delayed realizing data stores by summarizer).\n * 2. If we scheduled a particular run of the queue, it logs telemetry for the number of ops\n *    processed, the time and number of turns it took to process the ops.\n */\nexport let DeltaScheduler = /*#__PURE__*/(() => {\n  class DeltaScheduler {\n    constructor(deltaManager, logger) {\n      this.logger = logger;\n      // The increase in time for processing ops after each turn.\n      this.processingTimeIncrement = 10;\n      this.totalProcessingTime = DeltaScheduler.processingTime;\n      // This keeps track of whether the delta scheduler is scheduling a particular run of the\n      // the inbound delta queue. Basically, every time the delta queue starts processing with\n      // more than one op, this will be set to true until the run completes.\n      this.isScheduling = false;\n      // This keeps track of the number of times inbound queue has been scheduled. After a particular\n      // count, we log telemetry for the number of ops processed, the time and number of turns it took\n      // to process the ops.\n      this.schedulingCount = 0;\n      this.deltaManager = deltaManager;\n      this.deltaManager.inbound.on(\"idle\", () => {\n        this.inboundQueueIdle();\n      });\n    }\n    batchBegin() {\n      if (!this.processingStartTime) {\n        this.processingStartTime = performance.now();\n      }\n    }\n    batchEnd() {\n      if (this.shouldRunScheduler()) {\n        if (!this.isScheduling) {\n          this.isScheduling = true;\n          // Every 2000th time we are scheduling the inbound queue, we log telemetry for the\n          // number of ops processed, the time and number of turns it took to process the ops.\n          if (this.schedulingCount % 2000 === 0) {\n            this.schedulingLog = {\n              numberOfOps: this.deltaManager.inbound.length,\n              numberOfTurns: 1,\n              totalProcessingTime: 0\n            };\n          }\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const elapsedTime = performance.now() - this.processingStartTime;\n        if (elapsedTime > this.totalProcessingTime) {\n          // We have processed ops for more than the total processing time. So, pause the\n          // queue, yield the thread and schedule a resume.\n          // eslint-disable-next-line @typescript-eslint/no-floating-promises\n          this.deltaManager.inbound.systemPause();\n          setTimeout(() => {\n            this.deltaManager.inbound.systemResume();\n          });\n          this.processingStartTime = undefined;\n          // Increase the total processing time. Keep doing this after each turn until all the ops have\n          // been processed. This way we keep the responsiveness at the beginning while also making sure\n          // that all the ops process fairly quickly.\n          this.totalProcessingTime += this.processingTimeIncrement;\n          // If we are logging the telemetry this time, update the telemetry log object.\n          if (this.schedulingLog) {\n            this.schedulingLog.numberOfTurns++;\n            this.schedulingLog.totalProcessingTime += elapsedTime;\n          }\n        }\n      }\n    }\n    inboundQueueIdle() {\n      if (this.schedulingLog) {\n        // Add the time taken for processing the final ops to the total processing time in the\n        // telemetry log object.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.schedulingLog.totalProcessingTime += performance.now() - this.processingStartTime;\n        this.logger.sendTelemetryEvent({\n          eventName: \"InboundOpsProcessingTime\",\n          numberOfOps: this.schedulingLog.numberOfOps,\n          numberOfTurns: this.schedulingLog.numberOfTurns,\n          processingTime: this.schedulingLog.totalProcessingTime\n        });\n        this.schedulingLog = undefined;\n      }\n      // If we scheduled this batch of the inbound queue, increment the counter that tracks the\n      // number of times we have done this.\n      if (this.isScheduling) {\n        this.isScheduling = false;\n        this.schedulingCount++;\n      }\n      // Reset the processing times.\n      this.processingStartTime = undefined;\n      this.totalProcessingTime = DeltaScheduler.processingTime;\n    }\n    /**\n     * This function tells whether we should run the scheduler.\n     */\n    shouldRunScheduler() {\n      // If there are still ops in the queue after the one we are processing now, we should\n      // run the scheduler.\n      return this.deltaManager.inbound.length > 0;\n    }\n  }\n  // The time for processing ops in a single turn.\n\n  //# sourceMappingURL=deltaScheduler.js.map\n  DeltaScheduler.processingTime = 20;\n  return DeltaScheduler;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}