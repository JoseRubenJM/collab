{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { fromBase64ToUtf8 } from \"@fluidframework/common-utils\";\nimport { addBlobToTree } from \"@fluidframework/protocol-base\";\nimport { MessageType } from \"@fluidframework/protocol-definitions\";\nimport { SharedObject } from \"@fluidframework/shared-object-base\";\nimport { debug } from \"./debug\";\nimport { MapKernel } from \"./mapKernel\";\nimport { pkgVersion } from \"./packageVersion\";\nconst snapshotFileName = \"header\";\n/**\n * The factory that defines the map.\n * @sealed\n */\nexport class MapFactory {\n  /**\n  * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.\"type\"}\n  */\n  get type() {\n    return MapFactory.Type;\n  }\n  /**\n  * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}\n  */\n  get attributes() {\n    return MapFactory.Attributes;\n  }\n  /**\n  * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}\n  */\n  load(runtime, id, services, attributes) {\n    return _asyncToGenerator(function* () {\n      const map = new SharedMap(id, runtime, attributes);\n      yield map.load(services);\n      return map;\n    })();\n  }\n  /**\n  * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.create}\n  */\n  create(runtime, id) {\n    const map = new SharedMap(id, runtime, MapFactory.Attributes);\n    map.initializeLocal();\n    return map;\n  }\n}\n/**\n* {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.\"type\"}\n*/\nMapFactory.Type = \"https://graph.microsoft.com/types/map\";\n/**\n* {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}\n*/\nMapFactory.Attributes = {\n  type: MapFactory.Type,\n  snapshotFormatVersion: \"0.2\",\n  packageVersion: pkgVersion\n};\n/**\n * The SharedMap distributed data structure can be used to store key-value pairs. It provides the same API for setting\n * and retrieving values that JavaScript developers are accustomed to with the\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map | Map} built-in object.\n * However, the keys of a SharedMap must be strings.\n */\nexport class SharedMap extends SharedObject {\n  /**\n  * Do not call the constructor. Instead, you should use the {@link SharedMap.create | create method}.\n  *\n  * @param id - String identifier.\n  * @param runtime - Data store runtime.\n  * @param attributes - The attributes for the map.\n  */\n  constructor(id, runtime, attributes) {\n    super(id, runtime, attributes);\n    /**\n    * String representation for the class.\n    */\n    this[Symbol.toStringTag] = \"SharedMap\";\n    this.kernel = new MapKernel(this.serializer, this.handle, (op, localOpMetadata) => this.submitLocalMessage(op, localOpMetadata), () => this.isAttached(), [], this);\n  }\n  /**\n   * Create a new shared map.\n   * @param runtime - The data store runtime that the new shared map belongs to.\n   * @param id - Optional name of the shared map.\n   * @returns Newly created shared map.\n   *\n   * @example\n   * To create a `SharedMap`, call the static create method:\n   *\n   * ```typescript\n   * const myMap = SharedMap.create(this.runtime, id);\n   * ```\n   *\n   */\n  static create(runtime, id) {\n    return runtime.createChannel(id, MapFactory.Type);\n  }\n  /**\n   * Get a factory for SharedMap to register with the data store.\n   * @returns A factory that creates SharedMaps and loads them from storage.\n   */\n  static getFactory() {\n    return new MapFactory();\n  }\n  /**\n  * {@inheritDoc MapKernel.keys}\n  */\n  keys() {\n    return this.kernel.keys();\n  }\n  /**\n  * {@inheritDoc MapKernel.entries}\n  */\n  entries() {\n    return this.kernel.entries();\n  }\n  /**\n  * {@inheritDoc MapKernel.values}\n  */\n  values() {\n    return this.kernel.values();\n  }\n  /**\n  * Get an iterator over the entries in this map.\n  * @returns The iterator\n  */\n  [Symbol.iterator]() {\n    return this.kernel.entries();\n  }\n  /**\n  * {@inheritDoc MapKernel.size}\n  */\n  get size() {\n    return this.kernel.size;\n  }\n  /**\n  * {@inheritDoc MapKernel.forEach}\n  */\n  forEach(callbackFn) {\n    this.kernel.forEach(callbackFn);\n  }\n  /**\n  * {@inheritDoc ISharedMap.get}\n  */\n  get(key) {\n    return this.kernel.get(key);\n  }\n  /**\n  * {@inheritDoc ISharedMap.wait}\n  */\n  wait(key) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.kernel.wait(key);\n    })();\n  }\n  /**\n  * {@inheritDoc MapKernel.has}\n  */\n  has(key) {\n    return this.kernel.has(key);\n  }\n  /**\n  * {@inheritDoc ISharedMap.set}\n  */\n  set(key, value) {\n    this.kernel.set(key, value);\n    return this;\n  }\n  /**\n  * {@inheritDoc MapKernel.delete}\n  */\n  delete(key) {\n    return this.kernel.delete(key);\n  }\n  /**\n  * {@inheritDoc MapKernel.clear}\n  */\n  clear() {\n    this.kernel.clear();\n  }\n  /**\n  * {@inheritDoc @fluidframework/shared-object-base#SharedObject.snapshotCore}\n  */\n  snapshotCore(serializer) {\n    let currentSize = 0;\n    let counter = 0;\n    let headerBlob = {};\n    const blobs = [];\n    const tree = {\n      entries: [],\n      id: null\n    };\n    const data = this.kernel.getSerializedStorage(serializer);\n    // If single property exceeds this size, it goes into its own blob\n    const MinValueSizeSeparateSnapshotBlob = 8 * 1024;\n    // Maximum blob size for multiple map properties\n    // Should be bigger than MinValueSizeSeparateSnapshotBlob\n    const MaxSnapshotBlobSize = 16 * 1024;\n    // Partitioning algorithm:\n    // 1) Split large (over MinValueSizeSeparateSnapshotBlob = 8K) properties into their own blobs.\n    //    Naming (across snapshots) of such blob does not have to be stable across snapshots,\n    //    As de-duping process (in driver) should not care about paths, only content.\n    // 2) Split remaining properties into blobs of MaxSnapshotBlobSize (16K) size.\n    //    This process does not produce stable partitioning. This means\n    //    modification (including addition / deletion) of property can shift properties across blobs\n    //    and result in non-incremental snapshot.\n    //    This can be improved in the future, without being format breaking change, as loading sequence\n    //    loads all blobs at once and partitioning schema has no impact on that process.\n    for (const key of Object.keys(data)) {\n      const value = data[key];\n      if (value.value && value.value.length >= MinValueSizeSeparateSnapshotBlob) {\n        const blobName = `blob${counter}`;\n        counter++;\n        blobs.push(blobName);\n        const content = {\n          [key]: {\n            type: value.type,\n            value: JSON.parse(value.value)\n          }\n        };\n        addBlobToTree(tree, blobName, content);\n      } else {\n        currentSize += value.type.length + 21; // Approximation cost of property header\n        if (value.value) {\n          currentSize += value.value.length;\n        }\n        if (currentSize > MaxSnapshotBlobSize) {\n          const blobName = `blob${counter}`;\n          counter++;\n          blobs.push(blobName);\n          addBlobToTree(tree, blobName, headerBlob);\n          headerBlob = {};\n          currentSize = 0;\n        }\n        headerBlob[key] = {\n          type: value.type,\n          value: value.value === undefined ? undefined : JSON.parse(value.value)\n        };\n      }\n    }\n    const header = {\n      blobs,\n      content: headerBlob\n    };\n    addBlobToTree(tree, snapshotFileName, header);\n    return tree;\n  }\n  getSerializableStorage() {\n    return this.kernel.getSerializableStorage(this.serializer);\n  }\n  /**\n  * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}\n  */\n  loadCore(storage) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const header = yield storage.read(snapshotFileName);\n      const data = fromBase64ToUtf8(header);\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      const json = JSON.parse(data);\n      const newFormat = json;\n      if (Array.isArray(newFormat.blobs)) {\n        _this2.kernel.populateFromSerializable(newFormat.content);\n        yield Promise.all(newFormat.blobs.map( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (value) {\n            const blob = yield storage.read(value);\n            const blobData = fromBase64ToUtf8(blob);\n            _this2.kernel.populateFromSerializable(JSON.parse(blobData));\n          });\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }()));\n      } else {\n        _this2.kernel.populateFromSerializable(json);\n      }\n    })();\n  }\n  /**\n  * {@inheritDoc @fluidframework/shared-object-base#SharedObject.onDisconnect}\n  */\n  onDisconnect() {\n    debug(`Map ${this.id} is now disconnected`);\n  }\n  /**\n    * {@inheritDoc @fluidframework/shared-object-base#SharedObject.reSubmitCore}\n    */\n  reSubmitCore(content, localOpMetadata) {\n    this.kernel.trySubmitMessage(content, localOpMetadata);\n  }\n  /**\n  * {@inheritDoc @fluidframework/shared-object-base#SharedObject.processCore}\n  */\n  processCore(message, local, localOpMetadata) {\n    if (message.type === MessageType.Operation) {\n      this.kernel.tryProcessMessage(message, local, localOpMetadata);\n    }\n  }\n  /**\n  * {@inheritDoc @fluidframework/shared-object-base#SharedObject.registerCore}\n  */\n  registerCore() {\n    for (const value of this.values()) {\n      if (SharedObject.is(value)) {\n        value.bindToContext();\n      }\n    }\n  }\n}\n//# sourceMappingURL=map.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}