{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { BaseSegment, glc, MergeTree } from \"./mergeTree\";\nimport { LocalReferenceCollection } from \"./localReference\";\nexport let TextSegment = /*#__PURE__*/(() => {\n  class TextSegment extends BaseSegment {\n    constructor(text) {\n      super();\n      this.text = text;\n      this.type = TextSegment.type;\n      this.cachedLength = text.length;\n    }\n    static is(segment) {\n      return segment.type === TextSegment.type;\n    }\n    static make(text, props) {\n      const tseg = new TextSegment(text);\n      if (props) {\n        tseg.addProperties(props);\n      }\n      return tseg;\n    }\n    static fromJSONObject(spec) {\n      if (typeof spec === \"string\") {\n        return new TextSegment(spec);\n      } else if (spec && typeof spec === \"object\" && \"text\" in spec) {\n        const textSpec = spec;\n        return TextSegment.make(textSpec.text, textSpec.props);\n      }\n      return undefined;\n    }\n    toJSONObject() {\n      // To reduce snapshot/ops size, we serialize a TextSegment as a plain 'string' if it is\n      // not annotated.\n      return this.properties ? {\n        text: this.text,\n        props: this.properties\n      } : this.text;\n    }\n    clone(start = 0, end) {\n      const text = this.text.substring(start, end);\n      const b = TextSegment.make(text, this.properties);\n      this.cloneInto(b);\n      return b;\n    }\n    canAppend(segment) {\n      return !this.text.endsWith(\"\\n\") && TextSegment.is(segment) && (this.cachedLength <= MergeTree.TextSegmentGranularity || segment.cachedLength <= MergeTree.TextSegmentGranularity);\n    }\n    toString() {\n      return this.text;\n    }\n    append(segment) {\n      if (TextSegment.is(segment)) {\n        // Note: Must call 'appendLocalRefs' before modifying this segment's length as\n        // 'this.cachedLength' is used to adjust the offsets of the local refs.\n        LocalReferenceCollection.append(this, segment);\n        this.text += segment.text;\n        this.cachedLength = this.text.length;\n      } else {\n        throw new Error(\"can only append text segment\");\n      }\n    }\n    // TODO: retain removed text for undo\n    // returns true if entire string removed\n    removeRange(start, end) {\n      let remnantString = \"\";\n      const len = this.text.length;\n      if (start > 0) {\n        remnantString += this.text.substring(0, start);\n      }\n      if (end < len) {\n        remnantString += this.text.substring(end);\n      }\n      this.text = remnantString;\n      this.cachedLength = remnantString.length;\n      return remnantString.length === 0;\n    }\n    createSplitSegmentAt(pos) {\n      if (pos > 0) {\n        const remainingText = this.text.substring(pos);\n        this.text = this.text.substring(0, pos);\n        this.cachedLength = this.text.length;\n        const leafSegment = new TextSegment(remainingText);\n        return leafSegment;\n      }\n    }\n  }\n  TextSegment.type = \"TextSegment\";\n  return TextSegment;\n})();\nexport class MergeTreeTextHelper {\n  constructor(mergeTree) {\n    this.mergeTree = mergeTree;\n    this.gatherText = (segment, pos, refSeq, clientId, start, end, accumText) => {\n      if (TextSegment.is(segment)) {\n        if (MergeTree.traceGatherText) {\n          console.log(`@cli ${this.mergeTree.getLongClientId(this.mergeTree.collabWindow.clientId)} ` + `gather seg seq ${segment.seq} rseq ${segment.removedSeq} text ${segment.text}`);\n        }\n        let beginTags = \"\";\n        let endTags = \"\";\n        if (accumText.parallelArrays) {\n          // TODO: let clients pass in function to get tag\n          const tags = [];\n          const initTags = [];\n          if (segment.properties && segment.properties[\"font-weight\"]) {\n            tags.push(\"b\");\n          }\n          if (segment.properties && segment.properties[\"text-decoration\"]) {\n            tags.push(\"u\");\n          }\n          const remTags = [];\n          if (tags.length > 0) {\n            for (const tag of tags) {\n              if (!accumText.tagsInProgress.includes(tag)) {\n                beginTags += `<${tag}>`;\n                initTags.push(tag);\n              }\n            }\n            for (const accumTag of accumText.tagsInProgress) {\n              if (!tags.includes(accumTag)) {\n                endTags += `</${accumTag}>`;\n                remTags.push(accumTag);\n              }\n            }\n            for (const initTag of initTags.reverse()) {\n              accumText.tagsInProgress.push(initTag);\n            }\n          } else {\n            for (const accumTag of accumText.tagsInProgress) {\n              endTags += `</${accumTag}>`;\n              remTags.push(accumTag);\n            }\n          }\n          for (const remTag of remTags) {\n            const remdex = accumText.tagsInProgress.indexOf(remTag);\n            if (remdex >= 0) {\n              accumText.tagsInProgress.splice(remdex, 1);\n            }\n          }\n        }\n        accumText.textSegment.text += endTags;\n        accumText.textSegment.text += beginTags;\n        if (start <= 0 && end >= segment.text.length) {\n          accumText.textSegment.text += segment.text;\n        } else {\n          if (start < 0) {\n            // eslint-disable-next-line no-param-reassign\n            start = 0;\n          }\n          if (end >= segment.text.length) {\n            accumText.textSegment.text += segment.text.substring(start);\n          } else {\n            accumText.textSegment.text += segment.text.substring(start, end);\n          }\n        }\n      } else {\n        if (accumText.placeholder && accumText.placeholder.length > 0) {\n          if (accumText.placeholder === \"*\") {\n            const marker = segment;\n            accumText.textSegment.text += `\\n${marker.toString()}`;\n          } else {\n            for (let i = 0; i < segment.cachedLength; i++) {\n              accumText.textSegment.text += accumText.placeholder;\n            }\n          }\n        } else if (accumText.parallelArrays) {\n          const marker = segment;\n          if (marker.hasTileLabel(accumText.parallelMarkerLabel)) {\n            accumText.parallelMarkers.push(marker);\n            accumText.parallelText.push(accumText.textSegment.text);\n            accumText.textSegment.text = \"\";\n          }\n        }\n      }\n      return true;\n    };\n  }\n  getTextAndMarkers(refSeq, clientId, label, start, end) {\n    const range = this.getValidRange(start, end, refSeq, clientId);\n    const accum = {\n      parallelArrays: true,\n      parallelMarkerLabel: label,\n      parallelMarkers: [],\n      parallelText: [],\n      tagsInProgress: [],\n      textSegment: new TextSegment(\"\")\n    };\n    if (MergeTree.traceGatherText) {\n      console.log(`get text on cli ${glc(this.mergeTree, this.mergeTree.collabWindow.clientId)} ` + `ref cli ${glc(this.mergeTree, clientId)} refSeq ${refSeq}`);\n    }\n    this.mergeTree.mapRange({\n      leaf: this.gatherText\n    }, refSeq, clientId, accum, range.start, range.end);\n    return {\n      parallelText: accum.parallelText,\n      parallelMarkers: accum.parallelMarkers\n    };\n  }\n  getText(refSeq, clientId, placeholder = \"\", start, end) {\n    const range = this.getValidRange(start, end, refSeq, clientId);\n    const accum = {\n      textSegment: new TextSegment(\"\"),\n      placeholder\n    };\n    if (MergeTree.traceGatherText) {\n      console.log(`get text on cli ${glc(this.mergeTree, this.mergeTree.collabWindow.clientId)} ` + `ref cli ${glc(this.mergeTree, clientId)} refSeq ${refSeq}`);\n    }\n    this.mergeTree.mapRange({\n      leaf: this.gatherText\n    }, refSeq, clientId, accum, range.start, range.end);\n    return accum.textSegment.text;\n  }\n  getValidRange(start, end, refSeq, clientId) {\n    const range = {\n      end,\n      start\n    };\n    if (range.start === undefined) {\n      range.start = 0;\n    }\n    if (range.end === undefined) {\n      range.end = this.mergeTree.getLength(refSeq, clientId);\n    }\n    return range;\n  }\n}\n//# sourceMappingURL=textSegment.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}