{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n// eslint-disable-next-line import/no-internal-modules\nimport cloneDeep from \"lodash/cloneDeep\";\nimport { assert } from \"./assert\";\n/**\n * Helper class that keeps track of the relation between two ranges in a 1:N fashion. Primary\n * is continuous and always maps to a single value in secondary above the base value. The range\n * defines an increasing step function.\n *\n * Used by deli to keep track of the branch map\n */\nexport class RangeTracker {\n  constructor(primary, secondary) {\n    if (typeof primary === \"number\") {\n      this.ranges = [{\n        length: 0,\n        primary,\n        secondary\n      }];\n      this.lastPrimary = primary;\n      this.lastSecondary = secondary;\n    } else {\n      this.ranges = cloneDeep(primary.ranges);\n      this.lastPrimary = primary.lastPrimary;\n      this.lastSecondary = primary.lastSecondary;\n    }\n  }\n  get base() {\n    return this.ranges[0].primary;\n  }\n  /**\n   * Getter for the last primary that was added\n   *\n   * @returns last primary that was added\n   */\n  get primaryHead() {\n    return this.lastPrimary;\n  }\n  /**\n   * Getter for the last secondary that was added\n   *\n   * @returns last secondary that was added\n   */\n  get secondaryHead() {\n    return this.lastSecondary;\n  }\n  /**\n   * Returns a serialized form of the RangeTracker\n   */\n  serialize() {\n    return {\n      lastPrimary: this.lastPrimary,\n      lastSecondary: this.lastSecondary,\n      ranges: cloneDeep(this.ranges)\n    };\n  }\n  /**\n   * Add a primary, secondary pair to the range\n   *\n   * @param primary - the primary number in the range\n   * @param secondary - the secondary number in the range\n   */\n  add(primary, secondary) {\n    // Both values must continuously be increasing - we won't always track the last value we saw so we do so\n    // below to check invariants\n    assert(primary >= this.lastPrimary, 0x003 /* \"Primary to add to range < last primary!\" */);\n    if (this.lastSecondary !== undefined) {\n      assert(secondary >= this.lastSecondary, 0x004 /* \"Secondary to add to range < last secondary!\" */);\n    }\n\n    this.lastPrimary = primary;\n    this.lastSecondary = secondary;\n    // Get quicker references to the head of the range\n    const head = this.ranges[this.ranges.length - 1];\n    const primaryHead = head.primary + head.length;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const secondaryHead = head.secondary + head.length;\n    // Same secondary indicates this is not a true inflection point - we can ignore it\n    if (secondary === secondaryHead) {\n      return;\n    }\n    // New secondary - need to update the ranges\n    if (primary === primaryHead) {\n      // Technically this code path has us supporting N:N ranges. But we simply overwrite duplicate values to\n      // preserve 1:N since you can only lookup from the primary to a secondary\n      if (head.length === 0) {\n        // No range represented - we can simply update secondary with the overwritten value\n        head.secondary = secondary;\n      } else {\n        // The values in the range before this one are valid - but we need to create a new one for this update\n        head.length--;\n        this.ranges.push({\n          length: 0,\n          primary,\n          secondary\n        });\n      }\n    } else {\n      if (primaryHead + 1 === primary && secondaryHead + 1 === secondary) {\n        // Extend the length if both increase by the same amount\n        head.length++;\n      } else {\n        // Insert a new node\n        this.ranges.push({\n          length: 0,\n          primary,\n          secondary\n        });\n      }\n    }\n  }\n  /**\n   * Get the closest range to the primary\n   *\n   * @param primary - the primary value to look for\n   * @returns the closest range to the primary\n   */\n  get(primary) {\n    assert(primary >= this.ranges[0].primary, 0x005 /* \"Target primary to retrieve < first range's primary!\" */);\n    // Find the first range where the starting position is greater than the primary. Our target range is\n    // the one before it.\n    let index = 1;\n    for (; index < this.ranges.length; index++) {\n      if (primary < this.ranges[index].primary) {\n        break;\n      }\n    }\n    assert(primary >= this.ranges[index - 1].primary, 0x006 /* \"Target primary to retrieve < last range's primary!\" */);\n    // If the difference is within the stored range use it - otherwise add in the length - 1 as the highest\n    // stored secondary value to use.\n    const closestRange = this.ranges[index - 1];\n    return (\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      Math.min(primary - closestRange.primary, closestRange.length) + closestRange.secondary\n    );\n  }\n  /**\n   * Update the range of primary\n   *\n   * @param primary - the primary value to update\n   */\n  updateBase(primary) {\n    assert(primary >= this.ranges[0].primary, 0x007 /* \"Target primary to update < first range's primary!\" */);\n    // Walk the ranges looking for the first one that is greater than the primary. Primary is then within the\n    // previous index by definition (since it's less than the current index's primary but greather than the\n    // previous index's primary) and we know primary must be greater than the base.\n    let index = 1;\n    for (; index < this.ranges.length; index++) {\n      if (primary < this.ranges[index].primary) {\n        break;\n      }\n    }\n    assert(primary >= this.ranges[index - 1].primary, 0x008 /* \"Target primary to update < last range's primary!\" */);\n    // Update the last range values\n    const range = this.ranges[index - 1];\n    const delta = primary - range.primary;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    range.secondary = range.secondary + Math.min(delta, range.length);\n    range.length = Math.max(range.length - delta, 0);\n    range.primary = primary;\n    // And remove unnecessary ranges\n    this.ranges = index - 1 > 0 ? this.ranges.slice(index - 1) : this.ranges;\n    // Assert that the lowest value is now the input to this method\n    assert(primary === this.ranges[0].primary, 0x009 /* \"After update, target primary is not first range's primary!\" */);\n  }\n}\n//# sourceMappingURL=rangeTracker.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}