{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { EventEmitter } from \"events\";\nimport { assert } from \"@fluidframework/common-utils\";\nimport { FluidObjectHandle, mixinRequestHandler } from \"@fluidframework/datastore\";\nimport { LoaderHeader, AttachState } from \"@fluidframework/container-definitions\";\nimport { SharedMap } from \"@fluidframework/map\";\nimport { ConsensusRegisterCollection } from \"@fluidframework/register-collection\";\nimport debug from \"debug\";\nimport { v4 as uuid } from \"uuid\";\n// Note: making sure this ID is unique and does not collide with storage provided clientID\nconst UnattachedClientId = `${uuid()}_unattached`;\nclass AgentScheduler extends EventEmitter {\n  constructor(runtime, context, scheduler) {\n    super();\n    this.runtime = runtime;\n    this.context = context;\n    this.scheduler = scheduler;\n    // Set of tasks registered by this client.\n    // Has no relationship with lists below.\n    // The only requirement here - a task can be registered by a client only once.\n    // Other clients can pick these tasks.\n    this.registeredTasks = new Set();\n    // List of all tasks client is capable of running (essentially expressed desire to run)\n    // Client will proactively attempt to pick them up these tasks if they are not assigned to other clients.\n    // This is a strict superset of tasks running in the client.\n    this.locallyRunnableTasks = new Map();\n    // Set of registered tasks client is currently running.\n    // It's subset of this.locallyRunnableTasks\n    this.runningTasks = new Set();\n  }\n  static load(runtime, context) {\n    return _asyncToGenerator(function* () {\n      let root;\n      let scheduler;\n      if (!runtime.existing) {\n        root = SharedMap.create(runtime, \"root\");\n        root.bindToContext();\n        scheduler = ConsensusRegisterCollection.create(runtime);\n        scheduler.bindToContext();\n        root.set(\"scheduler\", scheduler.handle);\n      } else {\n        root = yield runtime.getChannel(\"root\");\n        const handle = yield root.wait(\"scheduler\");\n        assert(handle !== undefined);\n        scheduler = yield handle.get();\n      }\n      const agentScheduler = new AgentScheduler(runtime, context, scheduler);\n      agentScheduler.initialize();\n      return agentScheduler;\n    })();\n  }\n  get IAgentScheduler() {\n    return this;\n  }\n  get clientId() {\n    if (this.runtime.attachState === AttachState.Detached) {\n      return UnattachedClientId;\n    }\n    const clientId = this.runtime.clientId;\n    assert(!!clientId);\n    return clientId;\n  }\n  register(...taskUrls) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      for (const taskUrl of taskUrls) {\n        if (_this.registeredTasks.has(taskUrl)) {\n          return Promise.reject(new Error(`${taskUrl} is already registered`));\n        }\n      }\n      const unregisteredTasks = [];\n      for (const taskUrl of taskUrls) {\n        _this.registeredTasks.add(taskUrl);\n        // Only register for a new task.\n        const currentClient = _this.getTaskClientId(taskUrl);\n        if (currentClient === undefined) {\n          unregisteredTasks.push(taskUrl);\n        }\n      }\n      return _this.registerCore(unregisteredTasks);\n    })();\n  }\n  pick(taskId, worker) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.locallyRunnableTasks.has(taskId)) {\n        return Promise.reject(new Error(`${taskId} is already attempted`));\n      }\n      _this2.locallyRunnableTasks.set(taskId, worker);\n      // Note: we are not checking for this.context.deltaManager.clientDetails.capabilities.interactive\n      // in isActive(). This check is done by users of this class - containerRuntime.ts (for \"leader\") and\n      // TaskManager. In the future, as new usage shows up, we may need to reconsider that.\n      // I'm adding assert here to catch that case and make decision on which way we go - push requirements\n      // to consumers to make a choice, or centrally make this call here.\n      assert(_this2.context.deltaManager.clientDetails.capabilities.interactive);\n      // Check the current status and express interest if it's a new one (undefined) or currently unpicked (null).\n      if (_this2.isActive()) {\n        const currentClient = _this2.getTaskClientId(taskId);\n        if (currentClient === undefined || currentClient === null) {\n          debug(`Requesting ${taskId}`);\n          yield _this2.writeCore(taskId, _this2.clientId);\n        }\n      }\n    })();\n  }\n  release(...taskUrls) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const active = _this3.isActive();\n      for (const taskUrl of taskUrls) {\n        if (!_this3.locallyRunnableTasks.has(taskUrl)) {\n          return Promise.reject(new Error(`${taskUrl} was never registered`));\n        }\n        // Note - the assumption is - we are connected.\n        // If not - all tasks should have been dropped already on disconnect / attachment\n        assert(active);\n        if (_this3.getTaskClientId(taskUrl) !== _this3.clientId) {\n          return Promise.reject(new Error(`${taskUrl} was never picked`));\n        }\n      }\n      return _this3.releaseCore([...taskUrls]);\n    })();\n  }\n  pickedTasks() {\n    return Array.from(this.runningTasks.values());\n  }\n  registerCore(taskUrls) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (taskUrls.length > 0) {\n        const registersP = [];\n        for (const taskUrl of taskUrls) {\n          debug(`Registering ${taskUrl}`);\n          registersP.push(_this4.writeCore(taskUrl, null));\n        }\n        yield Promise.all(registersP);\n        // The registers should have up to date results now. Check the status.\n        for (const taskUrl of taskUrls) {\n          const taskStatus = _this4.getTaskClientId(taskUrl);\n          // Task should be either registered (null) or picked up.\n          assert(taskStatus !== undefined, `Unsuccessful registration`);\n          if (taskStatus === null) {\n            debug(`Registered ${taskUrl}`);\n          } else {\n            debug(`${taskStatus} is running ${taskUrl}`);\n          }\n        }\n      }\n    })();\n  }\n  releaseCore(taskUrls) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      if (taskUrls.length > 0) {\n        const releasesP = [];\n        for (const taskUrl of taskUrls) {\n          debug(`Releasing ${taskUrl}`);\n          // Remove from local map so that it can be picked later.\n          _this5.locallyRunnableTasks.delete(taskUrl);\n          releasesP.push(_this5.writeCore(taskUrl, null));\n        }\n        yield Promise.all(releasesP);\n      }\n    })();\n  }\n  clearTasks(taskUrls) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      assert(_this6.isActive());\n      const clearP = [];\n      for (const taskUrl of taskUrls) {\n        debug(`Clearing ${taskUrl}`);\n        clearP.push(_this6.writeCore(taskUrl, null));\n      }\n      yield Promise.all(clearP);\n    })();\n  }\n  getTaskClientId(url) {\n    return this.scheduler.read(url);\n  }\n  writeCore(key, clientId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      yield _this7.scheduler.write(key, clientId);\n    })();\n  }\n  initialize() {\n    var _this8 = this;\n    const quorum = this.runtime.getQuorum();\n    // A client left the quorum. Iterate and clear tasks held by that client.\n    // Ideally a leader should do this cleanup. But it's complicated when a leader itself leaves.\n    // Probably okay for now to have every client try to do this.\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    quorum.on(\"removeMember\", /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (clientId) {\n        assert(_this8.runtime.objectsRoutingContext.isAttached);\n        // Cleanup only if connected. If not, cleanup will happen in initializeCore() that runs on connection.\n        if (_this8.isActive()) {\n          const leftTasks = [];\n          for (const taskUrl of _this8.scheduler.keys()) {\n            if (_this8.getTaskClientId(taskUrl) === clientId) {\n              leftTasks.push(taskUrl);\n            }\n          }\n          yield _this8.clearTasks(leftTasks);\n        }\n      });\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    // Listeners for new/released tasks. All clients will try to grab at the same time.\n    // May be we want a randomized timer (Something like raft) to reduce chattiness?\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    this.scheduler.on(\"atomicChanged\", /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (key, currentClient) {\n        // Check if this client was chosen.\n        if (_this8.isActive() && currentClient === _this8.clientId) {\n          _this8.onNewTaskAssigned(key);\n        } else {\n          yield _this8.onTaskReassigned(key, currentClient);\n        }\n      });\n      return function (_x2, _x3) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n    if (this.isActive()) {\n      this.initializeCore();\n    }\n    this.runtime.on(\"connected\", () => {\n      if (this.isActive()) {\n        this.initializeCore();\n      }\n    });\n    if (this.runtime.attachState === AttachState.Detached) {\n      this.runtime.waitAttached().then(() => {\n        this.clearRunningTasks();\n      }).catch(error => {\n        this.sendErrorEvent(\"AgentScheduler_clearRunningTasks\", error);\n      });\n    }\n    this.runtime.on(\"disconnected\", () => {\n      if (this.runtime.attachState !== AttachState.Detached) {\n        this.clearRunningTasks();\n      }\n    });\n  }\n  onNewTaskAssigned(key) {\n    assert(!this.runningTasks.has(key), \"task is already running\");\n    this.runningTasks.add(key);\n    const worker = this.locallyRunnableTasks.get(key);\n    if (worker === undefined) {\n      this.sendErrorEvent(\"AgentScheduler_UnwantedChange\", undefined, key);\n    } else {\n      this.emit(\"picked\", key);\n      worker().catch(error => {\n        this.sendErrorEvent(\"AgentScheduler_FailedWork\", error, key);\n      });\n    }\n  }\n  onTaskReassigned(key, currentClient) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      if (_this9.runningTasks.has(key)) {\n        _this9.runningTasks.delete(key);\n        _this9.emit(\"released\", key);\n      }\n      assert(currentClient !== undefined, \"client is undefined\");\n      if (_this9.isActive()) {\n        // attempt to pick up task if we are connected.\n        // If not, initializeCore() will do it when connected\n        if (currentClient === null) {\n          if (_this9.locallyRunnableTasks.has(key)) {\n            debug(`Requesting ${key}`);\n            yield _this9.writeCore(key, _this9.clientId);\n          }\n        }\n        // Check if the op came from dropped client\n        // This could happen when \"old\" ops are submitted on reconnection.\n        // They carry \"old\" ref seq number, but if write is not contested, it will get accepted\n        else if (_this9.runtime.getQuorum().getMember(currentClient) === undefined) {\n          yield _this9.writeCore(key, null);\n        }\n      }\n    })();\n  }\n  isActive() {\n    // Scheduler should be active in detached container.\n    if (this.runtime.attachState === AttachState.Detached) {\n      return true;\n    }\n    if (!this.runtime.connected) {\n      return false;\n    }\n    // Note: we are not checking for this.context.deltaManager.clientDetails.capabilities.interactive\n    // here. This is done by users of this class - containerRuntime.ts (for \"leader\") and TaskManager.\n    // In the future, as new usage shows up, we may need to reconsider that.\n    // I'm adding assert in pick() to catch that case and make decision on which way we go - push requirements\n    // to consumers to make a choice, or centrally make this call here.\n    return this.context.deltaManager.active;\n  }\n  initializeCore() {\n    // Nobody released the tasks held by last client in previous session.\n    // Check to see if this client needs to do this.\n    const clearCandidates = [];\n    const tasks = [];\n    for (const [taskUrl] of this.locallyRunnableTasks) {\n      if (!this.getTaskClientId(taskUrl)) {\n        debug(`Requesting ${taskUrl}`);\n        tasks.push(this.writeCore(taskUrl, this.clientId));\n      }\n    }\n    for (const taskUrl of this.scheduler.keys()) {\n      const currentClient = this.getTaskClientId(taskUrl);\n      if (currentClient && this.runtime.getQuorum().getMember(currentClient) === undefined) {\n        clearCandidates.push(taskUrl);\n      }\n    }\n    tasks.push(this.clearTasks(clearCandidates));\n    Promise.all(tasks).catch(error => {\n      this.sendErrorEvent(\"AgentScheduler_InitError\", error);\n    });\n  }\n  clearRunningTasks() {\n    const tasks = this.runningTasks;\n    this.runningTasks = new Set();\n    if (this.isActive()) {\n      // Clear all tasks with UnattachedClientId (if was unattached) and reapply for tasks with new clientId\n      // If we are simply disconnected, then proper cleanup will be done on connection.\n      this.initializeCore();\n    }\n    for (const task of tasks) {\n      this.emit(\"lost\", task);\n    }\n  }\n  sendErrorEvent(eventName, error, key) {\n    this.runtime.logger.sendErrorEvent({\n      eventName,\n      key\n    }, error);\n  }\n}\nexport class TaskManager {\n  constructor(scheduler, runtime, context) {\n    this.scheduler = scheduler;\n    this.runtime = runtime;\n    this.context = context;\n    this.taskUrl = \"_tasks\";\n    this.taskMap = new Map();\n    this.innerHandle = new FluidObjectHandle(this, \"\", this.runtime.objectsRoutingContext);\n  }\n  static load(runtime, context) {\n    return _asyncToGenerator(function* () {\n      const agentScheduler = yield AgentScheduler.load(runtime, context);\n      return new TaskManager(agentScheduler, runtime, context);\n    })();\n  }\n  get IAgentScheduler() {\n    return this.scheduler;\n  }\n  get handle() {\n    return this.innerHandle;\n  }\n  get IFluidHandle() {\n    return this.innerHandle;\n  }\n  get IFluidLoadable() {\n    return this;\n  }\n  get IFluidRouter() {\n    return this;\n  }\n  get ITaskManager() {\n    return this;\n  }\n  request(request) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      if (request.url === \"\" || request.url === \"/\") {\n        return {\n          status: 200,\n          mimeType: \"fluid/object\",\n          value: _this10\n        };\n      } else if (!request.url.startsWith(_this10.taskUrl)) {\n        return {\n          status: 404,\n          mimeType: \"text/plain\",\n          value: `${request.url} not found`\n        };\n      } else {\n        const trimmedUrl = request.url.substr(_this10.taskUrl.length);\n        const taskUrl = trimmedUrl.length > 0 && trimmedUrl.startsWith(\"/\") ? trimmedUrl.substr(1) : \"\";\n        if (taskUrl === \"\" || !_this10.taskMap.has(taskUrl)) {\n          return {\n            status: 404,\n            mimeType: \"text/plain\",\n            value: `${request.url} not found`\n          };\n        } else {\n          return {\n            status: 200,\n            mimeType: \"fluid/object\",\n            value: _this10.taskMap.get(taskUrl)\n          };\n        }\n      }\n    })();\n  }\n  /**\n   * {@inheritDoc ITaskManager.register}\n   */\n  register(...tasks) {\n    for (const task of tasks) {\n      this.taskMap.set(task.id, task.instance);\n    }\n  }\n  /**\n   * {@inheritDoc ITaskManager.pick}\n   */\n  pick(taskId, worker) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this11.context.deltaManager.clientDetails.capabilities.interactive) {\n        return Promise.reject(new Error(\"Picking not allowed on secondary copy\"));\n      } else if (_this11.runtime.attachState !== AttachState.Attached) {\n        return Promise.reject(new Error(\"Picking not allowed in detached container in task manager\"));\n      } else {\n        const fullUrl = `/${_this11.runtime.id}/${_this11.taskUrl}/${taskId}`;\n        return _this11.scheduler.pick(fullUrl, /*#__PURE__*/_asyncToGenerator(function* () {\n          return _this11.runTask(fullUrl, worker !== undefined ? worker : false);\n        }));\n      }\n    })();\n  }\n  runTask(url, worker) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const request = {\n        headers: {\n          [LoaderHeader.cache]: false,\n          [LoaderHeader.clientDetails]: {\n            capabilities: {\n              interactive: false\n            },\n            type: \"agent\"\n          },\n          [LoaderHeader.reconnect]: false,\n          [LoaderHeader.sequenceNumber]: _this12.context.deltaManager.lastSequenceNumber,\n          [LoaderHeader.executionContext]: worker ? \"worker\" : undefined\n        },\n        url\n      };\n      const response = yield _this12.runtime.loader.request(request);\n      if (response.status !== 200 || response.mimeType !== \"fluid/object\") {\n        return Promise.reject(new Error(`Invalid agent route: ${url}`));\n      }\n      const fluidObject = response.value;\n      const agent = fluidObject.IFluidRunnable;\n      if (agent === undefined) {\n        return Promise.reject(new Error(\"Fluid object does not implement IFluidRunnable\"));\n      }\n      return agent.run();\n    })();\n  }\n}\nexport let TaskManagerFactory = /*#__PURE__*/(() => {\n  class TaskManagerFactory {\n    constructor() {\n      this.type = TaskManagerFactory.type;\n    }\n    get IFluidDataStoreFactory() {\n      return this;\n    }\n    static get registryEntry() {\n      return [this.type, Promise.resolve(new TaskManagerFactory())];\n    }\n    instantiateDataStore(context) {\n      return _asyncToGenerator(function* () {\n        const mapFactory = SharedMap.getFactory();\n        const consensusRegisterCollectionFactory = ConsensusRegisterCollection.getFactory();\n        const dataTypes = new Map();\n        dataTypes.set(mapFactory.type, mapFactory);\n        dataTypes.set(consensusRegisterCollectionFactory.type, consensusRegisterCollectionFactory);\n        const runtimeClass = mixinRequestHandler( /*#__PURE__*/function () {\n          var _ref4 = _asyncToGenerator(function* (request) {\n            const router = yield routerP;\n            return router.request(request);\n          });\n          return function (_x4) {\n            return _ref4.apply(this, arguments);\n          };\n        }());\n        const runtime = new runtimeClass(context, dataTypes);\n        const routerP = TaskManager.load(runtime, context);\n        return runtime;\n      })();\n    }\n  }\n  TaskManagerFactory.type = \"_scheduler\";\n  //# sourceMappingURL=scheduler.js.map\n  return TaskManagerFactory;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}