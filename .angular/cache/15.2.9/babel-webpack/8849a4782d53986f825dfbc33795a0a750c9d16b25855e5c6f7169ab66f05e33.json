{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n// eslint-disable-next-line import/no-internal-modules\nimport cloneDeep from \"lodash/cloneDeep\";\nimport { assert, Deferred, doIfNotDisposed, EventForwarder, TypedEventEmitter } from \"@fluidframework/common-utils\";\n/**\n * Appends a deferred and rejection count to a sequenced proposal. For locally generated promises this allows us to\n * attach a Deferred which we will resolve once the proposal is either accepted or rejected.\n */\nclass PendingProposal {\n  constructor(sendReject, sequenceNumber, key, value, rejections, deferred) {\n    this.sendReject = sendReject;\n    this.sequenceNumber = sequenceNumber;\n    this.key = key;\n    this.value = value;\n    this.deferred = deferred;\n    this.canReject = true;\n    this.rejections = new Set(rejections);\n  }\n  reject() {\n    if (!this.canReject) {\n      throw new Error(\"Can no longer reject this proposal\");\n    }\n    this.sendReject(this.sequenceNumber);\n  }\n  get rejectionDisabled() {\n    return !this.canReject;\n  }\n  disableRejection() {\n    this.canReject = false;\n  }\n  addRejection(clientId) {\n    assert(!this.rejections.has(clientId), `!this.rejections.has(${clientId})`);\n    this.rejections.add(clientId);\n  }\n}\n/**\n * A quorum represents all clients currently within the collaboration window. As well as the values\n * they have agreed upon and any pending proposals.\n */\nexport class Quorum extends TypedEventEmitter {\n  constructor(minimumSequenceNumber, members, proposals, values, sendProposal, sendReject) {\n    super();\n    this.minimumSequenceNumber = minimumSequenceNumber;\n    this.sendProposal = sendProposal;\n    this.sendReject = sendReject;\n    this.isDisposed = false;\n    // Locally generated proposals\n    this.localProposals = new Map();\n    this.members = new Map(members);\n    this.proposals = new Map(proposals.map(([, proposal, rejections]) => {\n      return [proposal.sequenceNumber, new PendingProposal(this.sendReject, proposal.sequenceNumber, proposal.key, proposal.value, rejections)];\n    }));\n    this.values = new Map(values);\n    this.pendingCommit = new Map(values.filter(value => value[1].commitSequenceNumber === -1));\n  }\n  get disposed() {\n    return this.isDisposed;\n  }\n  close() {\n    this.removeAllListeners();\n  }\n  snapshot() {\n    const serializedProposals = Array.from(this.proposals).map(([sequenceNumber, proposal]) => [sequenceNumber, {\n      sequenceNumber,\n      key: proposal.key,\n      value: proposal.value\n    }, Array.from(proposal.rejections)]);\n    const snapshot = {\n      members: [...this.members],\n      proposals: serializedProposals,\n      values: [...this.values]\n    };\n    return cloneDeep(snapshot);\n  }\n  /**\n   * Returns whether the quorum has achieved a consensus for the given key.\n   */\n  has(key) {\n    return this.values.has(key);\n  }\n  /**\n   * Returns the consensus value for the given key\n   */\n  get(key) {\n    const keyMap = this.values.get(key);\n    if (keyMap !== undefined) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return keyMap.value;\n    }\n  }\n  /**\n   * Returns additional data about the approved consensus value\n   */\n  getApprovalData(key) {\n    const proposal = this.values.get(key);\n    return proposal ? cloneDeep(proposal) : undefined;\n  }\n  /**\n   * Adds a new client to the quorum\n   */\n  addMember(clientId, details) {\n    assert(!this.members.has(clientId), `!this.members.has(${clientId})`);\n    this.members.set(clientId, details);\n    this.emit(\"addMember\", clientId, details);\n  }\n  /**\n   * Removes a client from the quorum\n   */\n  removeMember(clientId) {\n    assert(this.members.has(clientId), `this.members.has(${clientId})`);\n    this.members.delete(clientId);\n    this.emit(\"removeMember\", clientId);\n  }\n  /**\n   * Retrieves all the members in the quorum\n   */\n  getMembers() {\n    return new Map(this.members);\n  }\n  /**\n   * Retrieves a specific member of the quorum\n   */\n  getMember(clientId) {\n    return this.members.get(clientId);\n  }\n  /**\n   * Proposes a new value. Returns a promise that will resolve when the proposal is either accepted or rejected.\n   *\n   * TODO: Right now we will only submit proposals for connected clients and not attempt to resubmit on any\n   * nack/disconnect. The correct answer for this should become more clear as we build scenarios on top of the loader.\n   */\n  propose(key, value) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const clientSequenceNumber = _this.sendProposal(key, value);\n      if (clientSequenceNumber < 0) {\n        _this.emit(\"error\", {\n          eventName: \"ProposalInDisconnectedState\",\n          key\n        });\n        return Promise.reject(new Error(\"Can't proposal in disconnected state\"));\n      }\n      const deferred = new Deferred();\n      _this.localProposals.set(clientSequenceNumber, deferred);\n      return deferred.promise;\n    })();\n  }\n  /**\n   * Begins tracking a new proposal\n   */\n  addProposal(key, value, sequenceNumber, local, clientSequenceNumber) {\n    assert(!this.proposals.has(sequenceNumber), `!this.proposals.has(${sequenceNumber})`);\n    assert(!local || this.localProposals.has(clientSequenceNumber), `!${local} || this.localProposals.has(${clientSequenceNumber})`);\n    const proposal = new PendingProposal(this.sendReject, sequenceNumber, key, value, [], local ? this.localProposals.get(clientSequenceNumber) : undefined);\n    this.proposals.set(sequenceNumber, proposal);\n    // Emit the event - which will also provide clients an opportunity to reject the proposal. We require\n    // clients to make a rejection decision at the time of receiving the proposal and so disable rejecting it\n    // after we have emitted the event.\n    this.emit(\"addProposal\", proposal);\n    proposal.disableRejection();\n    if (local) {\n      this.localProposals.delete(clientSequenceNumber);\n    }\n  }\n  /**\n   * Rejects the given proposal\n   */\n  rejectProposal(clientId, sequenceNumber) {\n    // Proposals require unanimous approval so any rejection results in a rejection of the proposal. For error\n    // detection we will keep a rejected proposal in the pending list until the MSN advances so that we can\n    // track the total number of rejections.\n    assert(this.proposals.has(sequenceNumber), `this.proposals.has(${sequenceNumber})`);\n    const proposal = this.proposals.get(sequenceNumber);\n    if (proposal !== undefined) {\n      proposal.addRejection(clientId);\n    }\n    // We will emit approval and rejection messages once the MSN advances past the sequence number of the\n    // proposal. This will allow us to convey all clients who rejected the proposal.\n    return;\n  }\n  /**\n   * Updates the minimum sequence number. If the MSN advances past the sequence number for any proposal without\n   * a rejection then it becomes an accepted consensus value.  If the MSN advances past the sequence number\n   * that the proposal was accepted, then it becomes a committed consensus value.\n   * Returns true if immediate no-op is required.\n   */\n  updateMinimumSequenceNumber(message) {\n    const value = message.minimumSequenceNumber;\n    if (this.minimumSequenceNumber !== undefined) {\n      if (value < this.minimumSequenceNumber) {\n        this.emit(\"error\", {\n          currentValue: this.minimumSequenceNumber,\n          eventName: \"QuorumMinSeqNumberError\",\n          newValue: value\n        });\n      }\n      if (value <= this.minimumSequenceNumber) {\n        return false;\n      }\n    }\n    this.minimumSequenceNumber = value;\n    let immediateNoOp = false;\n    // Accept proposals and reject proposals whose sequenceNumber is <= the minimumSequenceNumber\n    // Return a sorted list of approved proposals. We sort so that we apply them in their sequence number order\n    // TODO this can be optimized if necessary to avoid the linear search+sort\n    const completed = [];\n    for (const [sequenceNumber, proposal] of this.proposals) {\n      if (sequenceNumber <= this.minimumSequenceNumber) {\n        completed.push(proposal);\n      }\n    }\n    completed.sort((a, b) => a.sequenceNumber - b.sequenceNumber);\n    for (const proposal of completed) {\n      const approved = proposal.rejections.size === 0;\n      // If it was a local proposal - resolve the promise\n      if (proposal.deferred) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n        approved ? proposal.deferred.resolve() : proposal.deferred.reject(`Rejected by ${Array.from(proposal.rejections)}`);\n      }\n      if (approved) {\n        const committedProposal = {\n          approvalSequenceNumber: message.sequenceNumber,\n          commitSequenceNumber: -1,\n          key: proposal.key,\n          sequenceNumber: proposal.sequenceNumber,\n          value: proposal.value\n        };\n        // TODO do we want to notify when a proposal doesn't make it to the commit phase - i.e. because\n        // a new proposal was made before it made it to the committed phase? For now we just will never\n        // emit this message\n        this.values.set(committedProposal.key, committedProposal);\n        this.pendingCommit.set(committedProposal.key, committedProposal);\n        // Send no-op on approval to expedite commit\n        // accept means that all clients have seen the proposal and nobody has rejected it\n        // commit means that all clients have seen that the proposal was accepted by everyone\n        immediateNoOp = true;\n        this.emit(\"approveProposal\", committedProposal.sequenceNumber, committedProposal.key, committedProposal.value, committedProposal.approvalSequenceNumber);\n      } else {\n        this.emit(\"rejectProposal\", proposal.sequenceNumber, proposal.key, proposal.value, Array.from(proposal.rejections));\n      }\n      this.proposals.delete(proposal.sequenceNumber);\n    }\n    // Move values to the committed stage and notify\n    if (this.pendingCommit.size > 0) {\n      Array.from(this.pendingCommit.values()).filter(pendingCommit => pendingCommit.approvalSequenceNumber <= value).sort((a, b) => a.sequenceNumber - b.sequenceNumber).forEach(pendingCommit => {\n        pendingCommit.commitSequenceNumber = message.sequenceNumber;\n        this.emit(\"commitProposal\", pendingCommit.sequenceNumber, pendingCommit.key, pendingCommit.value, pendingCommit.approvalSequenceNumber, pendingCommit.commitSequenceNumber);\n        this.pendingCommit.delete(pendingCommit.key);\n      });\n    }\n    return immediateNoOp;\n  }\n  setConnectionState(connected, clientId) {\n    if (!connected) {\n      this.localProposals.forEach(deferral => {\n        deferral.reject(\"Client got disconnected\");\n      });\n      this.localProposals.clear();\n    }\n  }\n  dispose() {\n    throw new Error(\"Not implemented.\");\n    this.isDisposed = true;\n  }\n}\n/**\n * Proxies Quorum events.\n */\nexport class QuorumProxy extends EventForwarder {\n  constructor(quorum) {\n    super(quorum);\n    this.propose = doIfNotDisposed(this, quorum.propose.bind(quorum));\n    this.has = doIfNotDisposed(this, quorum.has.bind(quorum));\n    this.get = doIfNotDisposed(this, quorum.get.bind(quorum));\n    this.getApprovalData = doIfNotDisposed(this, quorum.getApprovalData.bind(quorum));\n    this.getMembers = doIfNotDisposed(this, quorum.getMembers.bind(quorum));\n    this.getMember = doIfNotDisposed(this, quorum.getMember.bind(quorum));\n  }\n}\n//# sourceMappingURL=quorum.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}