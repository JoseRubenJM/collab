{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { BindState, AttachState } from \"@fluidframework/container-definitions\";\nimport { assert, Deferred, TypedEventEmitter, unreachableCase } from \"@fluidframework/common-utils\";\nimport { ChildLogger, raiseConnectedEvent } from \"@fluidframework/telemetry-utils\";\nimport { buildSnapshotTree, readAndParseFromBlobs } from \"@fluidframework/driver-utils\";\nimport { CreateSummarizerNodeSource } from \"@fluidframework/runtime-definitions\";\nimport { convertSnapshotTreeToSummaryTree, convertSummaryTreeToITree, FluidSerializer, generateHandleContextPath, RequestParser, SummaryTreeBuilder } from \"@fluidframework/runtime-utils\";\nimport { GCDataBuilder } from \"@fluidframework/garbage-collector\";\nimport { v4 as uuid } from \"uuid\";\nimport { summarizeChannel } from \"./channelContext\";\nimport { LocalChannelContext } from \"./localChannelContext\";\nimport { RemoteChannelContext } from \"./remoteChannelContext\";\nexport var DataStoreMessageType = /*#__PURE__*/(() => {\n  (function (DataStoreMessageType) {\n    // Creates a new channel\n    DataStoreMessageType[\"Attach\"] = \"attach\";\n    DataStoreMessageType[\"ChannelOp\"] = \"op\";\n  })(DataStoreMessageType || (DataStoreMessageType = {}));\n  return DataStoreMessageType;\n})();\n/**\n * Base data store class\n */\nexport class FluidDataStoreRuntime extends TypedEventEmitter {\n  constructor(dataStoreContext, sharedObjectRegistry) {\n    var _a;\n    super();\n    this.dataStoreContext = dataStoreContext;\n    this.sharedObjectRegistry = sharedObjectRegistry;\n    this.serializer = new FluidSerializer(this.IFluidHandleContext);\n    this._disposed = false;\n    this.contexts = new Map();\n    this.contextsDeferred = new Map();\n    this.pendingAttach = new Map();\n    // This is used to break the recursion while attaching the graph. Also tells the attach state of the graph.\n    this.graphAttachState = AttachState.Detached;\n    this.deferredAttached = new Deferred();\n    this.localChannelContextQueue = new Map();\n    this.notBoundedChannelContextSet = new Set();\n    this.logger = ChildLogger.create(dataStoreContext.containerRuntime.logger, undefined, {\n      dataStoreId: uuid()\n    });\n    this.documentId = dataStoreContext.documentId;\n    this.id = dataStoreContext.id;\n    this.existing = dataStoreContext.existing;\n    this.options = dataStoreContext.options;\n    this.deltaManager = dataStoreContext.deltaManager;\n    this.quorum = dataStoreContext.getQuorum();\n    this.audience = dataStoreContext.getAudience();\n    const tree = dataStoreContext.baseSnapshot;\n    // Must always receive the data store type inside of the attributes\n    if (((_a = tree) === null || _a === void 0 ? void 0 : _a.trees) !== undefined) {\n      Object.keys(tree.trees).forEach(path => {\n        // Issue #4414\n        if (path === \"_search\") {\n          return;\n        }\n        let channelContext;\n        // If already exists on storage, then create a remote channel. However, if it is case of rehydrating a\n        // container from snapshot where we load detached container from a snapshot, isLocalDataStore would be\n        // true. In this case create a LocalChannelContext.\n        if (dataStoreContext.isLocalDataStore) {\n          const channelAttributes = readAndParseFromBlobs(tree.trees[path].blobs, tree.trees[path].blobs[\".attributes\"]);\n          channelContext = new LocalChannelContext(path, this.sharedObjectRegistry, channelAttributes.type, this, this.dataStoreContext, this.dataStoreContext.storage, (content, localOpMetadata) => this.submitChannelOp(path, content, localOpMetadata), address => this.setChannelDirty(address), tree.trees[path]);\n          // This is the case of rehydrating a detached container from snapshot. Now due to delay loading of\n          // data store, if the data store is loaded after the container is attached, then we missed marking\n          // the channel as attached. So mark it now. Otherwise add it to local channel context queue, so\n          // that it can be mark attached later with the data store.\n          if (dataStoreContext.attachState !== AttachState.Detached) {\n            channelContext.markAttached();\n          } else {\n            this.localChannelContextQueue.set(path, channelContext);\n          }\n        } else {\n          channelContext = new RemoteChannelContext(this, dataStoreContext, dataStoreContext.storage, (content, localOpMetadata) => this.submitChannelOp(path, content, localOpMetadata), address => this.setChannelDirty(address), path, tree.trees[path], this.sharedObjectRegistry, undefined /* extraBlobs */, this.dataStoreContext.getCreateChildSummarizerNodeFn(path, {\n            type: CreateSummarizerNodeSource.FromSummary\n          }));\n        }\n        const deferred = new Deferred();\n        deferred.resolve(channelContext);\n        this.contexts.set(path, channelContext);\n        this.contextsDeferred.set(path, deferred);\n      });\n    }\n    this.attachListener();\n    // If exists on storage or loaded from a snapshot, it should already be binded.\n    this.bindState = this.existing ? BindState.Bound : BindState.NotBound;\n    this._attachState = dataStoreContext.attachState;\n    // If it's existing we know it has been attached.\n    if (this.existing) {\n      this.deferredAttached.resolve();\n    }\n  }\n  /**\n   * Loads the data store runtime\n   * @param context - The data store context\n   * @param sharedObjectRegistry - The registry of shared objects used by this data store\n   * @param activeCallback - The callback called when the data store runtime in active\n   * @param dataStoreRegistry - The registry of data store created and used by this data store\n   */\n  static load(context, sharedObjectRegistry) {\n    return new FluidDataStoreRuntime(context, sharedObjectRegistry);\n  }\n  get IFluidRouter() {\n    return this;\n  }\n  get connected() {\n    return this.dataStoreContext.connected;\n  }\n  get leader() {\n    return this.dataStoreContext.leader;\n  }\n  get clientId() {\n    return this.dataStoreContext.clientId;\n  }\n  get clientDetails() {\n    return this.dataStoreContext.containerRuntime.clientDetails;\n  }\n  get loader() {\n    return this.dataStoreContext.loader;\n  }\n  get isAttached() {\n    return this.attachState !== AttachState.Detached;\n  }\n  get attachState() {\n    return this._attachState;\n  }\n  /**\n   * @deprecated - 0.21 back-compat\n   */\n  get path() {\n    return this.id;\n  }\n  get absolutePath() {\n    return generateHandleContextPath(this.id, this.routeContext);\n  }\n  get routeContext() {\n    return this.dataStoreContext.containerRuntime.IFluidHandleContext;\n  }\n  get IFluidSerializer() {\n    return this.serializer;\n  }\n  get IFluidHandleContext() {\n    return this;\n  }\n  get rootRoutingContext() {\n    return this;\n  }\n  get channelsRoutingContext() {\n    return this;\n  }\n  get objectsRoutingContext() {\n    return this;\n  }\n  get disposed() {\n    return this._disposed;\n  }\n  dispose() {\n    if (this._disposed) {\n      return;\n    }\n    this._disposed = true;\n    this.emit(\"dispose\");\n    this.removeAllListeners();\n  }\n  resolveHandle(request) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.request(request);\n    })();\n  }\n  request(request) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const parser = RequestParser.create(request);\n      const id = parser.pathParts[0];\n      if (id === \"_channels\" || id === \"_custom\") {\n        return _this2.request(parser.createSubRequest(1));\n      }\n      // Check for a data type reference first\n      if (_this2.contextsDeferred.has(id) && parser.isLeaf(1)) {\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const value = yield _this2.contextsDeferred.get(id).promise;\n          const channel = yield value.getChannel();\n          return {\n            mimeType: \"fluid/object\",\n            status: 200,\n            value: channel\n          };\n        } catch (error) {\n          _this2.logger.sendErrorEvent({\n            eventName: \"GetChannelFailedInRequest\"\n          }, error);\n          return {\n            status: 500,\n            mimeType: \"text/plain\",\n            value: `Failed to get Channel with id:[${id}] error:{${error}}`\n          };\n        }\n      }\n      // Otherwise defer to an attached request handler\n      if (_this2.requestHandler === undefined) {\n        return {\n          status: 404,\n          mimeType: \"text/plain\",\n          value: `${request.url} not found`\n        };\n      } else {\n        return _this2.requestHandler(parser);\n      }\n    })();\n  }\n  /**\n   * @deprecated\n   * Please use mixinRequestHandler() to override default behavior or request()\n   * // back-compat: remove in 0.30+\n   */\n  registerRequestHandler(handler) {\n    this.requestHandler = handler;\n  }\n  getChannel(id) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      _this3.verifyNotClosed();\n      // TODO we don't assume any channels (even root) in the runtime. If you request a channel that doesn't exist\n      // we will never resolve the promise. May want a flag to getChannel that doesn't wait for the promise if\n      // it doesn't exist\n      if (!_this3.contextsDeferred.has(id)) {\n        _this3.contextsDeferred.set(id, new Deferred());\n      }\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const context = yield _this3.contextsDeferred.get(id).promise;\n      const channel = yield context.getChannel();\n      return channel;\n    })();\n  }\n  createChannel(id = uuid(), type) {\n    this.verifyNotClosed();\n    assert(!this.contexts.has(id), \"createChannel() with existing ID\");\n    this.notBoundedChannelContextSet.add(id);\n    const context = new LocalChannelContext(id, this.sharedObjectRegistry, type, this, this.dataStoreContext, this.dataStoreContext.storage, (content, localOpMetadata) => this.submitChannelOp(id, content, localOpMetadata), address => this.setChannelDirty(address), undefined);\n    this.contexts.set(id, context);\n    if (this.contextsDeferred.has(id)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.contextsDeferred.get(id).resolve(context);\n    } else {\n      const deferred = new Deferred();\n      deferred.resolve(context);\n      this.contextsDeferred.set(id, deferred);\n    }\n    assert(!!context.channel, \"Channel should be loaded when created!!\");\n    return context.channel;\n  }\n  /**\n   * Binds a channel with the runtime. If the runtime is attached we will attach the channel right away.\n   * If the runtime is not attached we will defer the attach until the runtime attaches.\n   * @param channel - channel to be registered.\n   */\n  bindChannel(channel) {\n    assert(this.notBoundedChannelContextSet.has(channel.id), \"Channel to be binded should be in not bounded set\");\n    this.notBoundedChannelContextSet.delete(channel.id);\n    // If our data store is attached, then attach the channel.\n    if (this.isAttached) {\n      this.attachChannel(channel);\n      return;\n    } else {\n      this.bind(channel.handle);\n      // If our data store is local then add the channel to the queue\n      if (!this.localChannelContextQueue.has(channel.id)) {\n        this.localChannelContextQueue.set(channel.id, this.contexts.get(channel.id));\n      }\n    }\n  }\n  attachGraph() {\n    if (this.graphAttachState !== AttachState.Detached) {\n      return;\n    }\n    this.graphAttachState = AttachState.Attaching;\n    if (this.boundhandles !== undefined) {\n      this.boundhandles.forEach(handle => {\n        handle.attachGraph();\n      });\n      this.boundhandles = undefined;\n    }\n    // Flush the queue to set any pre-existing channels to local\n    this.localChannelContextQueue.forEach(channel => {\n      // When we are attaching the data store we don't need to send attach for the registered services.\n      // This is because they will be captured as part of the Attach data store snapshot\n      channel.markAttached();\n    });\n    this.localChannelContextQueue.clear();\n    this.bindToContext();\n    this.graphAttachState = AttachState.Attached;\n  }\n  /**\n   * Binds this runtime to the container\n   * This includes the following:\n   * 1. Sending an Attach op that includes all existing state\n   * 2. Attaching the graph if the data store becomes attached.\n   */\n  bindToContext() {\n    if (this.bindState !== BindState.NotBound) {\n      return;\n    }\n    this.bindState = BindState.Binding;\n    // Attach the runtime to the container via this callback\n    // back-compat: remove argument ans cast in 0.30.\n    this.dataStoreContext.bindToContext(this);\n    this.bindState = BindState.Bound;\n  }\n  bind(handle) {\n    // If the data store is already attached or its graph is already in attaching or attached state,\n    // then attach the incoming handle too.\n    if (this.isAttached || this.graphAttachState !== AttachState.Detached) {\n      handle.attachGraph();\n      return;\n    }\n    if (this.boundhandles === undefined) {\n      this.boundhandles = new Set();\n    }\n    this.boundhandles.add(handle);\n  }\n  setConnectionState(connected, clientId) {\n    this.verifyNotClosed();\n    for (const [, object] of this.contexts) {\n      object.setConnectionState(connected, clientId);\n    }\n    raiseConnectedEvent(this.logger, this, connected, clientId);\n  }\n  getQuorum() {\n    return this.quorum;\n  }\n  getAudience() {\n    return this.audience;\n  }\n  uploadBlob(blob) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      _this4.verifyNotClosed();\n      return _this4.dataStoreContext.uploadBlob(blob);\n    })();\n  }\n  process(message, local, localOpMetadata) {\n    this.verifyNotClosed();\n    switch (message.type) {\n      case DataStoreMessageType.Attach:\n        {\n          const attachMessage = message.contents;\n          const id = attachMessage.id;\n          // If a non-local operation then go and create the object\n          // Otherwise mark it as officially attached.\n          if (local) {\n            assert(this.pendingAttach.has(id), \"Unexpected attach (local) channel OP\");\n            this.pendingAttach.delete(id);\n          } else {\n            assert(!this.contexts.has(id), `Unexpected attach channel OP,\n                        is in pendingAttach set: ${this.pendingAttach.has(id)},\n                        is local channel contexts: ${this.contexts.get(id) instanceof LocalChannelContext}`);\n            const flatBlobs = new Map();\n            const snapshotTree = buildSnapshotTree(attachMessage.snapshot.entries, flatBlobs);\n            const remoteChannelContext = new RemoteChannelContext(this, this.dataStoreContext, this.dataStoreContext.storage, (content, localContentMetadata) => this.submitChannelOp(id, content, localContentMetadata), address => this.setChannelDirty(address), id, snapshotTree, this.sharedObjectRegistry, flatBlobs, this.dataStoreContext.getCreateChildSummarizerNodeFn(id, {\n              type: CreateSummarizerNodeSource.FromAttach,\n              sequenceNumber: message.sequenceNumber,\n              snapshot: attachMessage.snapshot\n            }), attachMessage.type);\n            this.contexts.set(id, remoteChannelContext);\n            if (this.contextsDeferred.has(id)) {\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              this.contextsDeferred.get(id).resolve(remoteChannelContext);\n            } else {\n              const deferred = new Deferred();\n              deferred.resolve(remoteChannelContext);\n              this.contextsDeferred.set(id, deferred);\n            }\n          }\n          break;\n        }\n      case DataStoreMessageType.ChannelOp:\n        this.processChannelOp(message, local, localOpMetadata);\n        break;\n      default:\n    }\n    this.emit(\"op\", message);\n  }\n  processSignal(message, local) {\n    this.emit(\"signal\", message, local);\n  }\n  isChannelAttached(id) {\n    return (\n      // Added in createChannel\n      // Removed when bindChannel is called\n      !this.notBoundedChannelContextSet.has(id)\n      // Added in bindChannel only if this is not attached yet\n      // Removed when this is attached by calling attachGraph\n      && !this.localChannelContextQueue.has(id)\n      // Added in attachChannel called by bindChannel\n      // Removed when attach op is broadcast\n      && !this.pendingAttach.has(id)\n    );\n  }\n  // back-compat for N-2 <= 0.28, remove when N-2 >= 0.29\n  snapshotInternal(fullTree = false) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const summaryTree = yield _this5.summarize(fullTree);\n      const tree = convertSummaryTreeToITree(summaryTree.summary);\n      return tree.entries;\n    })();\n  }\n  /**\n   * Returns the outbound routes of this channel. Currently, all contexts in this channel are considered\n   * referenced and are hence outbound. This will change when we have root and non-root channel contexts.\n   * The only root contexts will be considered as referenced.\n   */\n  getOutboundRoutes() {\n    const outboundRoutes = [];\n    for (const [contextId] of this.contexts) {\n      outboundRoutes.push(`${this.absolutePath}/${contextId}`);\n    }\n    return outboundRoutes;\n  }\n  /**\n   * Updates the GC nodes of this channel. It does the following:\n   * - Adds a back route to self to all its child GC nodes.\n   * - Adds a node for this channel.\n   * @param builder - The builder that contains the GC nodes for this channel's children.\n   */\n  updateGCNodes(builder) {\n    // Add a back route to self in each child's GC nodes. If any child is referenced, then its parent should\n    // be considered referenced as well.\n    builder.addRouteToAllNodes(this.absolutePath);\n    // Get the outbound routes and add a GC node for this channel.\n    builder.addNode(\"/\", this.getOutboundRoutes());\n  }\n  getGCData() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const builder = new GCDataBuilder();\n      // Iterate over each channel context and get their GC data.\n      yield Promise.all(Array.from(_this6.contexts).filter(([contextId, _]) => {\n        // Get GC data only for attached contexts. Detached contexts are not connected in the GC reference\n        // graph so any references they might have won't be connected as well.\n        return _this6.isChannelAttached(contextId);\n      }).map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* ([contextId, context]) {\n          const contextGCData = yield context.getGCData();\n          // Prefix the child's id to the ids of its GC nodes. This gradually builds the id of each node to be\n          // a path from the root.\n          builder.prefixAndAddNodes(contextId, contextGCData.gcNodes);\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n      _this6.updateGCNodes(builder);\n      return builder.getGCData();\n    })();\n  }\n  /**\n   * Returns a summary at the current sequence number.\n   * @param fullTree - true to bypass optimizations and force a full summary tree\n   * @param trackState - This tells whether we should track state from this summary.\n   */\n  summarize(fullTree = false, trackState = true) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const gcDataBuilder = new GCDataBuilder();\n      const summaryBuilder = new SummaryTreeBuilder();\n      // Iterate over each data store and ask it to summarize\n      yield Promise.all(Array.from(_this7.contexts).filter(([contextId, _]) => {\n        const isAttached = _this7.isChannelAttached(contextId);\n        // We are not expecting local dds! Summary may not capture local state.\n        assert(isAttached, \"Not expecting detached channels during summarize\");\n        // If the object is registered - and we have received the sequenced op creating the object\n        // (i.e. it has a base mapping) - then we go ahead and summarize\n        return isAttached;\n      }).map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* ([contextId, context]) {\n          const contextSummary = yield context.summarize(fullTree, trackState);\n          summaryBuilder.addWithStats(contextId, contextSummary);\n          // back-compat 0.31 - Older versions will not have GC data in summary.\n          if (contextSummary.gcData !== undefined) {\n            // Prefix the child's id to the ids of its GC nodes. This gradually builds the id of each node\n            // to be a path from the root.\n            gcDataBuilder.prefixAndAddNodes(contextId, contextSummary.gcData.gcNodes);\n          }\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }()));\n      _this7.updateGCNodes(gcDataBuilder);\n      return Object.assign(Object.assign({}, summaryBuilder.getSummaryTree()), {\n        gcData: gcDataBuilder.getGCData()\n      });\n    })();\n  }\n  getAttachSummary() {\n    this.attachGraph();\n    const gcDataBuilder = new GCDataBuilder();\n    const summaryBuilder = new SummaryTreeBuilder();\n    // Craft the .attributes file for each shared object\n    for (const [contextId, context] of this.contexts) {\n      if (!(context instanceof LocalChannelContext)) {\n        throw new Error(\"Should only be called with local channel handles\");\n      }\n      if (!this.notBoundedChannelContextSet.has(contextId)) {\n        let summaryTree;\n        if (context.isLoaded) {\n          const contextSummary = context.getAttachSummary();\n          assert(contextSummary.summary.type === 1 /* Tree */, \"getAttachSummary should always return a tree\");\n          summaryTree = {\n            stats: contextSummary.stats,\n            summary: contextSummary.summary\n          };\n          // back-compat 0.31 - Older versions will not have GC data in summary.\n          if (contextSummary.gcData !== undefined) {\n            // Prefix the child's id to the ids of its GC nodest. This gradually builds the id of each node\n            // to be a path from the root.\n            gcDataBuilder.prefixAndAddNodes(contextId, contextSummary.gcData.gcNodes);\n          }\n        } else {\n          // If this channel is not yet loaded, then there should be no changes in the snapshot from which\n          // it was created as it is detached container. So just use the previous snapshot.\n          assert(!!this.dataStoreContext.baseSnapshot, \"BaseSnapshot should be there as detached container loaded from snapshot\");\n          summaryTree = convertSnapshotTreeToSummaryTree(this.dataStoreContext.baseSnapshot.trees[contextId]);\n        }\n        summaryBuilder.addWithStats(contextId, summaryTree);\n      }\n    }\n    this.updateGCNodes(gcDataBuilder);\n    return Object.assign(Object.assign({}, summaryBuilder.getSummaryTree()), {\n      gcData: gcDataBuilder.getGCData()\n    });\n  }\n  submitMessage(type, content, localOpMetadata) {\n    this.submit(type, content, localOpMetadata);\n  }\n  submitSignal(type, content) {\n    this.verifyNotClosed();\n    return this.dataStoreContext.submitSignal(type, content);\n  }\n  /**\n   * Will return when the data store is attached.\n   */\n  waitAttached() {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      return _this8.deferredAttached.promise;\n    })();\n  }\n  raiseContainerWarning(warning) {\n    this.dataStoreContext.raiseContainerWarning(warning);\n  }\n  /**\n   * Attach channel should only be called after the data store has been attached\n   */\n  attachChannel(channel) {\n    this.verifyNotClosed();\n    // If this handle is already attached no need to attach again.\n    if (channel.handle.isAttached) {\n      return;\n    }\n    channel.handle.attachGraph();\n    assert(this.isAttached, \"Data store should be attached to attach the channel.\");\n    // Get the object snapshot only if the data store is Bound and its graph is attached too,\n    // because if the graph is attaching, then it would get included in the data store snapshot.\n    if (this.bindState === BindState.Bound && this.graphAttachState === AttachState.Attached) {\n      const summarizeResult = summarizeChannel(channel, true /* fullTree */, false /* trackState */);\n      // Attach message needs the summary in ITree format. Convert the ISummaryTree into an ITree.\n      const snapshot = convertSummaryTreeToITree(summarizeResult.summary);\n      const message = {\n        id: channel.id,\n        snapshot,\n        type: channel.attributes.type\n      };\n      this.pendingAttach.set(channel.id, message);\n      this.submit(DataStoreMessageType.Attach, message);\n    }\n    const context = this.contexts.get(channel.id);\n    context.markAttached();\n  }\n  submitChannelOp(address, contents, localOpMetadata) {\n    const envelope = {\n      address,\n      contents\n    };\n    this.submit(DataStoreMessageType.ChannelOp, envelope, localOpMetadata);\n  }\n  submit(type, content, localOpMetadata = undefined) {\n    this.verifyNotClosed();\n    this.dataStoreContext.submitMessage(type, content, localOpMetadata);\n  }\n  /**\n   * For messages of type MessageType.Operation, finds the right channel and asks it to resubmit the message.\n   * For all other messages, just submit it again.\n   * This typically happens when we reconnect and there are unacked messages.\n   * @param content - The content of the original message.\n   * @param localOpMetadata - The local metadata associated with the original message.\n   */\n  reSubmit(type, content, localOpMetadata) {\n    this.verifyNotClosed();\n    switch (type) {\n      case DataStoreMessageType.ChannelOp:\n        {\n          // For Operations, find the right channel and trigger resubmission on it.\n          const envelope = content;\n          const channelContext = this.contexts.get(envelope.address);\n          assert(!!channelContext, \"There should be a channel context for the op\");\n          channelContext.reSubmit(envelope.contents, localOpMetadata);\n          break;\n        }\n      case DataStoreMessageType.Attach:\n        // For Attach messages, just submit them again.\n        this.submit(type, content, localOpMetadata);\n        break;\n      default:\n        unreachableCase(type);\n    }\n  }\n  setChannelDirty(address) {\n    this.verifyNotClosed();\n    this.dataStoreContext.setChannelDirty(address);\n  }\n  processChannelOp(message, local, localOpMetadata) {\n    this.verifyNotClosed();\n    const envelope = message.contents;\n    const transformed = Object.assign(Object.assign({}, message), {\n      contents: envelope.contents\n    });\n    const channelContext = this.contexts.get(envelope.address);\n    assert(!!channelContext, \"Channel not found\");\n    channelContext.processOp(transformed, local, localOpMetadata);\n    return channelContext;\n  }\n  attachListener() {\n    this.setMaxListeners(Number.MAX_SAFE_INTEGER);\n    this.dataStoreContext.on(\"leader\", () => {\n      this.emit(\"leader\");\n    });\n    this.dataStoreContext.on(\"notleader\", () => {\n      this.emit(\"notleader\");\n    });\n    this.dataStoreContext.once(\"attaching\", () => {\n      assert(this.bindState !== BindState.NotBound, \"Data store attaching should not occur if it is not bound\");\n      this._attachState = AttachState.Attaching;\n      // This promise resolution will be moved to attached event once we fix the scheduler.\n      this.deferredAttached.resolve();\n      this.emit(\"attaching\");\n    });\n    this.dataStoreContext.once(\"attached\", () => {\n      assert(this.bindState === BindState.Bound, \"Data store should only be attached after it is bound\");\n      this._attachState = AttachState.Attached;\n      this.emit(\"attached\");\n    });\n  }\n  verifyNotClosed() {\n    if (this._disposed) {\n      throw new Error(\"Runtime is closed\");\n    }\n  }\n}\n/**\n * Mixin class that adds request handler to FluidDataStoreRuntime\n * Request handler is only called when data store can't resolve request, i.e. for custom requests.\n * @param Base - base class, inherits from FluidDataStoreRuntime\n * @param requestHandler - request handler to mix in\n */\nexport function mixinRequestHandler(requestHandler, Base = FluidDataStoreRuntime) {\n  return class RuntimeWithRequestHandler extends Base {\n    request(request) {\n      var _superprop_getRequest = () => super.request,\n        _this9 = this;\n      return _asyncToGenerator(function* () {\n        const response = yield _superprop_getRequest().call(_this9, request);\n        if (response.status === 404) {\n          return requestHandler(request, _this9);\n        }\n        return response;\n      })();\n    }\n  };\n}\n/**\n * Mixin class that adds await for DataObject to finish initialization before we proceed to summary.\n * @param Base - base class, inherits from FluidDataStoreRuntime\n */\nexport function mixinSummaryHandler(handler, Base = FluidDataStoreRuntime) {\n  return class RuntimeWithSummarizerHandler extends Base {\n    addBlob(summary, path, content) {\n      const firstName = path.shift();\n      if (firstName === undefined) {\n        throw new Error(\"Path can't be empty\");\n      }\n      let blob = {\n        type: 2 /* Blob */,\n        content\n      };\n      summary.stats.blobNodeCount++;\n      summary.stats.totalBlobSize += content.length;\n      for (const name of path.reverse()) {\n        blob = {\n          type: 1 /* Tree */,\n          tree: {\n            [name]: blob\n          }\n        };\n        summary.stats.treeNodeCount++;\n      }\n      summary.summary.tree[firstName] = blob;\n    }\n    summarize(...args) {\n      var _superprop_getSummarize = () => super.summarize,\n        _this10 = this;\n      return _asyncToGenerator(function* () {\n        const summary = yield _superprop_getSummarize().call(_this10, ...args);\n        const content = yield handler(_this10);\n        _this10.addBlob(summary, content.path, content.content);\n        return summary;\n      })();\n    }\n  };\n}\n//# sourceMappingURL=dataStoreRuntime.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}