{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { DataCorruptionError } from \"@fluidframework/container-utils\";\nimport { FlushMode } from \"@fluidframework/runtime-definitions\";\nimport Deque from \"double-ended-queue\";\n/**\n * PendingStateManager is responsible for maintaining the messages that have not been sent or have not yet been\n * acknowledged by the server. It also maintains the batch information for both automatically and manually flushed\n * batches along with the messages.\n * When the Container reconnects, it replays the pending states, which includes setting the FlushMode, manual flushing\n * of messages and triggering resubmission of unacked ops.\n *\n * It verifies that all the ops are acked, are received in the right order and batch information is correct.\n */\nexport class PendingStateManager {\n  constructor(containerRuntime) {\n    this.containerRuntime = containerRuntime;\n    this.pendingStates = new Deque();\n    // Maintains the count of messages that are currently unacked.\n    this.pendingMessagesCount = 0;\n    // Indicates whether we are processing a batch.\n    this.isProcessingBatch = false;\n  }\n  get connected() {\n    return this.containerRuntime.connected;\n  }\n  /**\n   * Called to check if there are any pending messages in the pending state queue.\n   * @returns A boolean indicating whether there are messages or not.\n   */\n  hasPendingMessages() {\n    return this.pendingMessagesCount !== 0;\n  }\n  /**\n   * Called when a message is submitted locally. Adds the message and the associated details to the pending state\n   * queue.\n   * @param type - The container message type.\n   * @param clientSequenceNumber - The clientSequenceNumber associated with the message.\n   * @param content - The message content.\n   * @param localOpMetadata - The local metadata associated with the message.\n   */\n  onSubmitMessage(type, clientSequenceNumber, content, localOpMetadata, opMetadata) {\n    const pendingMessage = {\n      type: \"message\",\n      messageType: type,\n      clientSequenceNumber,\n      content,\n      localOpMetadata,\n      opMetadata\n    };\n    this.pendingStates.push(pendingMessage);\n    this.pendingMessagesCount++;\n  }\n  /**\n   * Called when the FlushMode is updated. Adds the FlushMode to the pending state queue.\n   * @param flushMode - The flushMode that was updated.\n   */\n  onFlushModeUpdated(flushMode) {\n    var _a, _b;\n    if (flushMode === FlushMode.Automatic) {\n      const previousState = this.pendingStates.peekBack();\n      // We don't have to track a previous \"flush\" state because FlushMode.Automatic flushes the messages. So,\n      // just tracking this FlushMode.Automatic is enough.\n      if (((_a = previousState) === null || _a === void 0 ? void 0 : _a.type) === \"flush\") {\n        this.pendingStates.removeBack();\n      }\n      // If no messages were sent between FlushMode.Manual and FlushMode.Automatic, then we do not have to track\n      // both these states. Remove FlushMode.Manual from the pending queue and return.\n      if (((_b = previousState) === null || _b === void 0 ? void 0 : _b.type) === \"flushMode\" && previousState.flushMode === FlushMode.Manual) {\n        this.pendingStates.removeBack();\n        return;\n      }\n    }\n    const pendingFlushMode = {\n      type: \"flushMode\",\n      flushMode\n    };\n    this.pendingStates.push(pendingFlushMode);\n  }\n  /**\n   * Called when flush() is called on the ContainerRuntime to manually flush messages.\n   */\n  onFlush() {\n    var _a;\n    // If the FlushMode is Automatic, we should not track this flush call as it is only applicable when FlushMode\n    // is Manual.\n    if (this.containerRuntime.flushMode === FlushMode.Automatic) {\n      return;\n    }\n    // If the previous state is not a message, we don't have to track this flush call as there is nothing to flush.\n    const previousState = this.pendingStates.peekBack();\n    if (((_a = previousState) === null || _a === void 0 ? void 0 : _a.type) !== \"message\") {\n      return;\n    }\n    // Note that because of the checks above and the checks in onFlushModeUpdated(), we can be sure that a \"flush\"\n    // state always has a \"message\" before and after it. So, it marks the end of a batch and the beginning of a\n    // new one.\n    const pendingFlush = {\n      type: \"flush\"\n    };\n    this.pendingStates.push(pendingFlush);\n  }\n  /**\n   * Processes a local message once its ack'd by the server. It verifies that there was no data corruption and that\n   * the batch information was preserved for batch messages.\n   * @param message - The messsage that got ack'd and needs to be processed.\n   */\n  processPendingLocalMessage(message) {\n    // Pre-processing part - This may be the start of a batch.\n    this.maybeProcessBatchBegin(message);\n    // Get the next state from the pending queue and verify that it is of type \"message\".\n    const pendingState = this.peekNextPendingState();\n    assert(pendingState.type === \"message\", \"No pending message found for this remote message\");\n    this.pendingStates.shift();\n    // Processing part - Verify that there has been no data corruption.\n    // The clientSequenceNumber of the incoming message must match that of the pending message.\n    if (pendingState.clientSequenceNumber !== message.clientSequenceNumber) {\n      // Close the container because this indicates data corruption.\n      const error = new DataCorruptionError(\"Unexpected ack received\", {\n        clientId: message.clientId,\n        sequenceNumber: message.sequenceNumber,\n        clientSequenceNumber: message.clientSequenceNumber,\n        expectedClientSequenceNumber: pendingState.clientSequenceNumber\n      });\n      this.containerRuntime.closeFn(error);\n      return;\n    }\n    this.pendingMessagesCount--;\n    // Post-processing part - If we are processing a batch then this could be the last message in the batch.\n    if (this.isProcessingBatch) {\n      this.maybeProcessBatchEnd(message);\n    }\n    return pendingState.localOpMetadata;\n  }\n  /**\n   * This message could be the first message in batch. If so, set batch state marking the beginning of a batch.\n   * @param message - The message that is being processed.\n   */\n  maybeProcessBatchBegin(message) {\n    const pendingState = this.peekNextPendingState();\n    if (pendingState.type !== \"flush\" && pendingState.type !== \"flushMode\") {\n      return;\n    }\n    // If the pending state is of type \"flushMode\", it must be Manual since Automatic flush mode is processed\n    // after a message is processed and not before.\n    if (pendingState.type === \"flushMode\") {\n      assert(pendingState.flushMode === FlushMode.Manual, \"Flush mode should be manual when processing batch begin\");\n    }\n    // We should not already be processing a batch and there should be no pending batch begin message.\n    assert(!this.isProcessingBatch && this.pendingBatchBeginMessage === undefined, \"The pending batch state indicates we are already processing a batch\");\n    // Set the pending batch state indicating we have started processing a batch.\n    this.pendingBatchBeginMessage = message;\n    this.isProcessingBatch = true;\n    // Remove this pending state from the queue as we have processed it.\n    this.pendingStates.shift();\n  }\n  maybeProcessBatchEnd(message) {\n    var _a, _b;\n    const nextPendingState = this.peekNextPendingState();\n    if (nextPendingState.type !== \"flush\" && nextPendingState.type !== \"flushMode\") {\n      return;\n    }\n    // If the next pending state is of type \"flushMode\", it must be Automatic and if so, we need to remove it from\n    // the queue.\n    // Note that we do not remove the type \"flush\" from the queue because it indicates the end of one batch and the\n    // beginning of a new one. So, it will removed when the next batch begin is processed.\n    if (nextPendingState.type === \"flushMode\") {\n      assert(nextPendingState.flushMode === FlushMode.Automatic, \"Flush mode is set to Manual in the middle of processing a batch\");\n      this.pendingStates.shift();\n    }\n    // There should be a pending batch begin message.\n    assert(this.pendingBatchBeginMessage !== undefined, \"There is no pending batch begin message\");\n    // Get the batch begin metadata from the first message in the batch.\n    const batchBeginMetadata = (_a = this.pendingBatchBeginMessage.metadata) === null || _a === void 0 ? void 0 : _a.batch;\n    // There could be just a single message in the batch. If so, it should not have any batch metadata. If there\n    // are multiple messages in the batch, verify that we got the correct batch begin and end metadata.\n    if (this.pendingBatchBeginMessage === message) {\n      assert(batchBeginMetadata === undefined, \"Batch with single message should not have batch metadata\");\n    } else {\n      // Get the batch metadata from the last message in the batch.\n      const batchEndMetadata = (_b = message.metadata) === null || _b === void 0 ? void 0 : _b.batch;\n      assert(batchBeginMetadata === true, \"Did not receive batch begin metadata\");\n      assert(batchEndMetadata === false, \"Did not receive batch end metadata\");\n    }\n    // Clear the pending batch state now that we have processed the entire batch.\n    this.pendingBatchBeginMessage = undefined;\n    this.isProcessingBatch = false;\n  }\n  /**\n   * Returns the next pending state from the pending state queue.\n   */\n  peekNextPendingState() {\n    const nextPendingState = this.pendingStates.peekFront();\n    assert(!!nextPendingState, \"No pending state found for the remote message\");\n    return nextPendingState;\n  }\n  /**\n   * Called when the Container's connection state changes. If the Container gets connected, it replays all the pending\n   * states in its queue. This includes setting the FlushMode and trigerring resubmission of unacked ops.\n   */\n  replayPendingStates() {\n    assert(this.connected, \"The connection state is not consistent with the runtime\");\n    // This assert suggests we are about to send same ops twice, which will result in data loss.\n    assert(this.clientId !== this.containerRuntime.clientId, \"replayPendingStates called twice for same clientId!\");\n    this.clientId = this.containerRuntime.clientId;\n    let pendingStatesCount = this.pendingStates.length;\n    if (pendingStatesCount === 0) {\n      return;\n    }\n    // Reset the pending message count because all these messages will be removed from the queue.\n    this.pendingMessagesCount = 0;\n    // Save the current FlushMode so that we can revert it back after replaying the states.\n    const savedFlushMode = this.containerRuntime.flushMode;\n    // Process exactly `pendingStatesCount` items in the queue as it represents the number of states that were\n    // pending when we connected. This is important because the `reSubmitFn` might add more items in the queue\n    // which must not be replayed.\n    while (pendingStatesCount > 0) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const pendingState = this.pendingStates.shift();\n      switch (pendingState.type) {\n        case \"message\":\n          {\n            this.containerRuntime.reSubmitFn(pendingState.messageType, pendingState.content, pendingState.localOpMetadata, pendingState.opMetadata);\n          }\n          break;\n        case \"flushMode\":\n          {\n            this.containerRuntime.setFlushMode(pendingState.flushMode);\n          }\n          break;\n        case \"flush\":\n          {\n            this.containerRuntime.flush();\n          }\n          break;\n        default:\n          break;\n      }\n      pendingStatesCount--;\n    }\n    // Revert the FlushMode.\n    this.containerRuntime.setFlushMode(savedFlushMode);\n  }\n}\n//# sourceMappingURL=pendingStateManager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}