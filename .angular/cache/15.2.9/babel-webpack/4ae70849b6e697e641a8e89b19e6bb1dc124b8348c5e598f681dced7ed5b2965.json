{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { AttachmentTreeEntry } from \"@fluidframework/protocol-base\";\nimport { generateHandleContextPath } from \"@fluidframework/runtime-utils\";\n/**\n * This class represents blob (long string)\n * This object is used only when creating (writing) new blob and serialization purposes.\n * De-serialization process goes through FluidObjectHandle and request flow:\n * DataObject.request() recognizes requests in the form of `/blobs/<id>`\n * and loads blob.\n */\nexport class BlobHandle {\n  constructor(path, routeContext, get, attachGraph) {\n    this.path = path;\n    this.routeContext = routeContext;\n    this.get = get;\n    this.attachGraph = attachGraph;\n    this.absolutePath = generateHandleContextPath(path, this.routeContext);\n  }\n  get IFluidHandle() {\n    return this;\n  }\n  get isAttached() {\n    return true;\n  }\n  bind(handle) {\n    throw new Error(\"Cannot bind to blob handle\");\n  }\n}\nexport let BlobManager = /*#__PURE__*/(() => {\n  class BlobManager {\n    constructor(routeContext, getStorage, sendBlobAttachOp) {\n      this.routeContext = routeContext;\n      this.getStorage = getStorage;\n      this.sendBlobAttachOp = sendBlobAttachOp;\n      this.blobIds = new Set();\n    }\n    getBlob(blobId) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        return new BlobHandle(`${BlobManager.basePath}/${blobId}`, _this.routeContext, /*#__PURE__*/_asyncToGenerator(function* () {\n          return _this.getStorage().readBlob(blobId);\n        }), () => null);\n      })();\n    }\n    createBlob(blob) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        const response = yield _this2.getStorage().createBlob(blob);\n        const handle = new BlobHandle(`${BlobManager.basePath}/${response.id}`, _this2.routeContext, /*#__PURE__*/_asyncToGenerator(function* () {\n          return _this2.getStorage().readBlob(response.id);\n        }), () => _this2.sendBlobAttachOp(response.id));\n        return handle;\n      })();\n    }\n    addBlobId(blobId) {\n      this.blobIds.add(blobId);\n    }\n    /**\n     * Load a set of previously attached blob IDs from a previous snapshot. Note\n     * that BlobManager tracking and reporting attached blobs is a temporary\n     * solution since storage expects attached blobs to be reported and any that\n     * are not reported as attached may be GCed. In the future attached blob\n     * IDs will be collected at summarization time, and runtime will not care\n     * about the existence or specific formatting of this tree in returned\n     * snapshots.\n     *\n     * @param blobsTree - Tree containing IDs of previously attached blobs. This\n     * corresponds to snapshot() below. We look for the IDs in the blob entries\n     * of the tree since the both the r11s and SPO drivers replace the\n     * attachment types returned in snapshot() with blobs.\n     */\n    load(blobsTree) {\n      if (blobsTree) {\n        Object.values(blobsTree.blobs).map(entry => this.addBlobId(entry));\n      }\n    }\n    snapshot() {\n      const entries = [...this.blobIds].map(id => new AttachmentTreeEntry(id, id));\n      return {\n        entries\n      };\n    }\n  }\n  BlobManager.basePath = \"_blobs\";\n  //# sourceMappingURL=blobManager.js.map\n  return BlobManager;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}