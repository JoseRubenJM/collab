{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Used to give increasing delay times for throttling a single functionality.\n * Delay is based on previous attempts within specified time window, subtracting delay time.\n */\nexport class Throttler {\n  constructor( /** Width of sliding delay window in milliseconds. */\n  delayWindowMs, /** Maximum delay allowed in milliseconds. */\n  maxDelayMs,\n  /**\n   * Delay function used to calculate what the delay should be.\n   * The input is the number of attempts that occurred within the sliding window.\n   * The result is the calculated delay in milliseconds.\n   */\n  delayFn) {\n    this.delayWindowMs = delayWindowMs;\n    this.maxDelayMs = maxDelayMs;\n    this.delayFn = delayFn;\n    this.startTimes = [];\n  }\n  get numAttempts() {\n    return this.startTimes.length;\n  }\n  /**\n   * Gets all attempt start times after compensating for the delay times\n   * by adding the delay times to the actual times.\n   */\n  getAttempts() {\n    return [...this.startTimes];\n  }\n  /**\n   * Latest attempt time after compensating for the delay time itself\n   * by adding the delay time to the actual time.\n   */\n  get latestAttemptTime() {\n    return this.startTimes.length > 0 ? this.startTimes[this.startTimes.length - 1] : undefined;\n  }\n  getDelay() {\n    const now = Date.now();\n    const latestAttemptTime = this.latestAttemptTime;\n    if (latestAttemptTime !== undefined) {\n      // If getDelay was called sooner than the most recent delay,\n      // subtract the remaining time, since we previously added it.\n      const earlyMs = latestAttemptTime - now;\n      if (earlyMs > 0) {\n        this.startTimes = this.startTimes.map(t => t - earlyMs);\n      }\n    }\n    // Remove all attempts that have already fallen out of the window.\n    this.startTimes = this.startTimes.filter(t => now - t < this.delayWindowMs);\n    // Compute delay, but do not exceed the specified max delay.\n    const delayMs = Math.min(this.delayFn(this.startTimes.length), this.maxDelayMs);\n    // Record this attempt start time.\n    this.startTimes.push(now);\n    // Account for the delay time, by effectively removing it from the delay window.\n    this.startTimes = this.startTimes.map(t => t + delayMs);\n    if (delayMs === this.maxDelayMs) {\n      // We hit max delay, so adding more won't affect anything.\n      // Shift off oldest time to stop this array from growing forever.\n      this.startTimes.shift();\n    }\n    return delayMs;\n  }\n}\n/**\n * Helper function to generate simple exponential throttle functions.\n * f(n) = [coefficient] x ([multiplier]^n) + [flatOffset]\n * where n = number of attempts, and f(n) = delay time in milliseconds.\n * If not provided, coefficient will default to 1, multiplier to 2,\n * minimum delay to 0, and the offset to 0, yielding:\n * 0 ms, 2 ms, 4 ms, 8 ms, ..., 2^n ms\n * where M = multiplier; an exponential back-off.\n * Use initialDelay to decide what should happen when numAttempts is 0,\n * leave it undefined to not special case.\n */\nexport const formExponentialFn = ({\n  multiplier = 2,\n  coefficient = 1,\n  offset = 0,\n  initialDelay = undefined\n} = {}) => numAttempts => Math.max(0, numAttempts <= 0 && initialDelay !== undefined ? initialDelay : coefficient * Math.pow(multiplier, numAttempts) + offset);\n/** f(n) = C x (B^(n+A)) + F = (C x B^A) x B^n + F */\nexport const formExponentialFnWithAttemptOffset = (attemptOffset, {\n  multiplier = 2,\n  coefficient = 1,\n  offset = 0,\n  initialDelay = undefined\n} = {}) => formExponentialFn({\n  multiplier,\n  coefficient: coefficient * Math.pow(multiplier, attemptOffset),\n  offset,\n  initialDelay\n});\n/**\n * Helper function to generate simple linear throttle functions.\n * f(n) = [coefficient] x n + [flatOffset]\n * where n = number of attempts, and f(n) = delay time in milliseconds.\n * If not provided, coefficient will default to 1, and offset to 0, yielding:\n * 0 ms, 1 ms, 2 ms, 3 ms, ..., n ms delays; a linear back-off.\n */\nexport const formLinearFn = ({\n  coefficient = 1,\n  offset = 0\n} = {}) => numAttempts => Math.max(0, coefficient * numAttempts + offset);\n/** f(n) = C x (n+A) + F = C x n + (C x A + F) */\nexport const formLinearFnWithAttemptOffset = (attemptOffset, {\n  coefficient = 1,\n  offset = 0\n} = {}) => formLinearFn({\n  coefficient,\n  offset: coefficient * attemptOffset + offset\n});\n//# sourceMappingURL=throttler.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}