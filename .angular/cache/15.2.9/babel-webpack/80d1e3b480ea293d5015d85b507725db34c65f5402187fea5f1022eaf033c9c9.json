{"ast":null,"code":"\"use strict\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MockContainerRuntimeFactoryForReconnection = exports.MockContainerRuntimeForReconnection = void 0;\nconst uuid_1 = require(\"uuid\");\nconst common_utils_1 = require(\"@fluidframework/common-utils\");\nconst mocks_1 = require(\"./mocks\");\n/**\n * Specalized implementation of MockContainerRuntime for testing ops during reconnection.\n */\nclass MockContainerRuntimeForReconnection extends mocks_1.MockContainerRuntime {\n  constructor(dataStoreRuntime, factory) {\n    super(dataStoreRuntime, factory);\n    /**\n     * Contains messages from other clients that were sequenced while this runtime was marked as disconnected.\n     */\n    this.pendingRemoteMessages = [];\n    this._connected = true;\n  }\n  get connected() {\n    return this._connected;\n  }\n  set connected(connected) {\n    if (this._connected === connected) {\n      return;\n    }\n    this._connected = connected;\n    if (connected) {\n      for (const remoteMessage of this.pendingRemoteMessages) {\n        this.process(remoteMessage);\n      }\n      this.pendingRemoteMessages.length = 0;\n      this.clientSequenceNumber = 0;\n      // We should get a new clientId on reconnection.\n      this.clientId = (0, uuid_1.v4)();\n      // Update the clientId in FluidDataStoreRuntime.\n      this.dataStoreRuntime.clientId = this.clientId;\n      this.factory.quorum.addMember(this.clientId, {});\n      // On reconnection, ask the DDSes to resubmit pending messages.\n      this.reSubmitMessages();\n    } else {\n      const factory = this.factory;\n      // On disconnection, clear any outstanding messages for this client because it will be resent.\n      factory.clearOutstandingClientMessages(this.clientId);\n      this.factory.quorum.removeMember(this.clientId);\n    }\n    // Let the DDSes know that the connection state changed.\n    this.deltaConnections.forEach(dc => {\n      dc.setConnectionState(this.connected);\n    });\n  }\n  process(message) {\n    if (this.connected) {\n      super.process(message);\n    } else {\n      this.pendingRemoteMessages.push(message);\n    }\n  }\n  submit(messageContent, localOpMetadata) {\n    // Submit messages only if we are connection, otherwise, just add it to the pending queue.\n    if (this.connected) {\n      return super.submit(messageContent, localOpMetadata);\n    }\n    this.addPendingMessage(messageContent, localOpMetadata, -1);\n    return -1;\n  }\n  reSubmitMessages() {\n    let messageCount = this.pendingMessages.length;\n    while (messageCount > 0) {\n      const pendingMessage = this.pendingMessages.shift();\n      (0, common_utils_1.assert)(pendingMessage !== undefined, \"this is impossible due to the above length check\");\n      this.deltaConnections.forEach(dc => {\n        dc.reSubmit(pendingMessage.content, pendingMessage.localOpMetadata);\n      });\n      messageCount--;\n    }\n  }\n}\nexports.MockContainerRuntimeForReconnection = MockContainerRuntimeForReconnection;\n/**\n * Specalized implementation of MockContainerRuntimeFactory for testing ops during reconnection.\n */\nclass MockContainerRuntimeFactoryForReconnection extends mocks_1.MockContainerRuntimeFactory {\n  createContainerRuntime(dataStoreRuntime) {\n    const containerRuntime = new MockContainerRuntimeForReconnection(dataStoreRuntime, this);\n    this.runtimes.push(containerRuntime);\n    return containerRuntime;\n  }\n  clearOutstandingClientMessages(clientId) {\n    // Delete all the messages for client with the given clientId.\n    this.messages = this.messages.filter(message => {\n      return message.clientId !== clientId;\n    });\n  }\n}\nexports.MockContainerRuntimeFactoryForReconnection = MockContainerRuntimeFactoryForReconnection;\n//# sourceMappingURL=mocksForReconnection.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}