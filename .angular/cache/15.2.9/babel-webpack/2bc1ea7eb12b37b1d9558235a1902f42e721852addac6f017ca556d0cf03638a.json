{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, fromBase64ToUtf8, IsoBuffer, Uint8ArrayToString, unreachableCase } from \"@fluidframework/common-utils\";\nimport { AttachmentTreeEntry, BlobTreeEntry, TreeTreeEntry } from \"@fluidframework/protocol-base\";\nimport { TreeEntry } from \"@fluidframework/protocol-definitions\";\n/**\n * Combines summary stats by adding their totals together.\n * Returns empty stats if called without args.\n * @param stats - stats to merge\n */\nexport function mergeStats(...stats) {\n  const results = {\n    treeNodeCount: 0,\n    blobNodeCount: 0,\n    handleNodeCount: 0,\n    totalBlobSize: 0\n  };\n  for (const stat of stats) {\n    results.treeNodeCount += stat.treeNodeCount;\n    results.blobNodeCount += stat.blobNodeCount;\n    results.handleNodeCount += stat.handleNodeCount;\n    results.totalBlobSize += stat.totalBlobSize;\n  }\n  return results;\n}\nexport function getBlobSize(content) {\n  if (typeof content === \"string\") {\n    return IsoBuffer.from(content, \"utf8\").byteLength;\n  } else {\n    return content.byteLength;\n  }\n}\nfunction calculateStatsCore(summaryObject, stats) {\n  switch (summaryObject.type) {\n    case 1 /* Tree */:\n      {\n        stats.treeNodeCount++;\n        for (const value of Object.values(summaryObject.tree)) {\n          calculateStatsCore(value, stats);\n        }\n        return;\n      }\n    case 3 /* Handle */:\n      {\n        stats.handleNodeCount++;\n        return;\n      }\n    case 2 /* Blob */:\n      {\n        stats.blobNodeCount++;\n        stats.totalBlobSize += getBlobSize(summaryObject.content);\n        return;\n      }\n    default:\n      return;\n  }\n}\nexport function calculateStats(summary) {\n  const stats = mergeStats();\n  calculateStatsCore(summary, stats);\n  return stats;\n}\nexport function addBlobToSummary(summary, key, content) {\n  const blob = {\n    type: 2 /* Blob */,\n    content\n  };\n  summary.summary.tree[key] = blob;\n  summary.stats.blobNodeCount++;\n  summary.stats.totalBlobSize += getBlobSize(content);\n}\nexport function addTreeToSummary(summary, key, summarizeResult) {\n  summary.summary.tree[key] = summarizeResult.summary;\n  summary.stats = mergeStats(summary.stats, summarizeResult.stats);\n}\nexport class SummaryTreeBuilder {\n  constructor() {\n    this.attachmentCounter = 0;\n    this.summaryTree = {};\n    this.summaryStats = mergeStats();\n    this.summaryStats.treeNodeCount++;\n  }\n  get summary() {\n    return {\n      type: 1 /* Tree */,\n      tree: Object.assign({}, this.summaryTree)\n    };\n  }\n  get stats() {\n    return Object.assign({}, this.summaryStats);\n  }\n  addBlob(key, content) {\n    // Prevent cloning by directly referencing underlying private properties\n    addBlobToSummary({\n      summary: {\n        type: 1 /* Tree */,\n        tree: this.summaryTree\n      },\n      stats: this.summaryStats\n    }, key, content);\n  }\n  addHandle(key, handleType, handle) {\n    this.summaryTree[key] = {\n      type: 3 /* Handle */,\n      handleType,\n      handle\n    };\n    this.summaryStats.handleNodeCount++;\n  }\n  addWithStats(key, summarizeResult) {\n    this.summaryTree[key] = summarizeResult.summary;\n    this.summaryStats = mergeStats(this.summaryStats, summarizeResult.stats);\n  }\n  addAttachment(id) {\n    this.summaryTree[this.attachmentCounter++] = {\n      id,\n      type: 4 /* Attachment */\n    };\n  }\n\n  getSummaryTree() {\n    return {\n      summary: this.summary,\n      stats: this.stats\n    };\n  }\n}\n/**\n * Converts snapshot ITree to ISummaryTree format and tracks stats.\n * @param snapshot - snapshot in ITree format\n * @param fullTree - true to never use handles, even if id is specified\n */\nexport function convertToSummaryTreeWithStats(snapshot, fullTree = false) {\n  const builder = new SummaryTreeBuilder();\n  for (const entry of snapshot.entries) {\n    switch (entry.type) {\n      case TreeEntry.Blob:\n        {\n          const blob = entry.value;\n          let content;\n          if (blob.encoding === \"base64\") {\n            content = IsoBuffer.from(blob.contents, \"base64\");\n          } else {\n            content = blob.contents;\n          }\n          builder.addBlob(entry.path, content);\n          break;\n        }\n      case TreeEntry.Tree:\n        {\n          const subtree = convertToSummaryTree(entry.value, fullTree);\n          builder.addWithStats(entry.path, subtree);\n          break;\n        }\n      case TreeEntry.Attachment:\n        {\n          const id = entry.value.id;\n          builder.addAttachment(id);\n          break;\n        }\n      case TreeEntry.Commit:\n        throw new Error(\"Should not have Commit TreeEntry in summary\");\n      default:\n        throw new Error(\"Unexpected TreeEntry type\");\n    }\n  }\n  return builder.getSummaryTree();\n}\n/**\n * Converts snapshot ITree to ISummaryTree format and tracks stats.\n * @param snapshot - snapshot in ITree format\n * @param fullTree - true to never use handles, even if id is specified\n */\nexport function convertToSummaryTree(snapshot, fullTree = false) {\n  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n  if (snapshot.id && !fullTree) {\n    const stats = mergeStats();\n    stats.handleNodeCount++;\n    return {\n      summary: {\n        handle: snapshot.id,\n        handleType: 1 /* Tree */,\n        type: 3 /* Handle */\n      },\n\n      stats\n    };\n  } else {\n    return convertToSummaryTreeWithStats(snapshot, fullTree);\n  }\n}\n/**\n * Converts ISnapshotTree to ISummaryTree format and tracks stats. This snapshot tree was\n * was taken by serialize api in detached container.\n * @param snapshot - snapshot in ISnapshotTree format\n */\nexport function convertSnapshotTreeToSummaryTree(snapshot) {\n  assert(Object.keys(snapshot.commits).length === 0, \"There should not be commit tree entries in snapshot\");\n  const builder = new SummaryTreeBuilder();\n  for (const [key, value] of Object.entries(snapshot.blobs)) {\n    // The entries in blobs are supposed to be blobPath -> blobId and blobId -> blobValue\n    // and we want to push blobPath to blobValue in tree entries.\n    if (snapshot.blobs[value] !== undefined) {\n      const decoded = fromBase64ToUtf8(snapshot.blobs[value]);\n      builder.addBlob(key, decoded);\n    }\n  }\n  for (const [key, tree] of Object.entries(snapshot.trees)) {\n    const subtree = convertSnapshotTreeToSummaryTree(tree);\n    builder.addWithStats(key, subtree);\n  }\n  return builder.getSummaryTree();\n}\n/**\n * Utility to convert serialized snapshot taken in detached container to format where we can use it to\n * attach the container.\n * @param serializedSnapshotTree - serialized snapshot tree to be converted to summary tree for attach.\n */\nexport function convertContainerToDriverSerializedFormat(serializedSnapshotTree) {\n  const snapshotTree = JSON.parse(serializedSnapshotTree);\n  const summaryTree = convertSnapshotTreeToSummaryTree(snapshotTree).summary;\n  const appSummaryTree = {\n    type: 1 /* Tree */,\n    tree: {}\n  };\n  const entries = Object.entries(summaryTree.tree);\n  for (const [key, subTree] of entries) {\n    if (key !== \".protocol\") {\n      appSummaryTree.tree[key] = subTree;\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete summaryTree.tree[key];\n    }\n  }\n  summaryTree.tree[\".app\"] = appSummaryTree;\n  return summaryTree;\n}\n/**\n * Converts ISummaryTree to ITree format. This is needed for back-compat while we get rid of snapshot.\n * @param summaryTree - summary tree in ISummaryTree format\n */\nexport function convertSummaryTreeToITree(summaryTree) {\n  const entries = [];\n  for (const [key, value] of Object.entries(summaryTree.tree)) {\n    switch (value.type) {\n      case 2 /* Blob */:\n        {\n          let parsedContent;\n          let encoding = \"utf-8\";\n          if (typeof value.content === \"string\") {\n            parsedContent = value.content;\n          } else {\n            parsedContent = Uint8ArrayToString(value.content, \"base64\");\n            encoding = \"base64\";\n          }\n          entries.push(new BlobTreeEntry(key, parsedContent, encoding));\n          break;\n        }\n      case 1 /* Tree */:\n        {\n          entries.push(new TreeTreeEntry(key, convertSummaryTreeToITree(value)));\n          break;\n        }\n      case 4 /* Attachment */:\n        {\n          entries.push(new AttachmentTreeEntry(key, value.id));\n          break;\n        }\n      case 0 /* Commit */:\n        {\n          throw new Error(\"Should not have Commit type in summary tree\");\n        }\n      case 3 /* Handle */:\n        {\n          throw new Error(\"Should not have Handle type in summary tree\");\n        }\n      default:\n        unreachableCase(value, \"Unexpected summary tree type\");\n    }\n  }\n  return {\n    entries,\n    // eslint-disable-next-line no-null/no-null\n    id: null\n  };\n}\n//# sourceMappingURL=summaryUtils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}