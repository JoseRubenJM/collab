{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { makeHandlesSerializable, parseHandles, ValueType } from \"@fluidframework/shared-object-base\";\nimport { assert, TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport { LocalValueMaker, makeSerializable } from \"./localValues\";\n/**\n * A SharedMap is a map-like distributed data structure.\n */\nexport class MapKernel {\n  /**\n   * Create a new shared map kernel.\n   * @param serializer - The serializer to serialize / parse handles\n   * @param handle - The handle of the shared object using the kernel\n   * @param submitMessage - A callback to submit a message through the shared object\n   * @param isAttached - To query whether the shared object should generate ops\n   * @param valueTypes - The value types to register\n   * @param eventEmitter - The object that will emit map events\n   */\n  constructor(serializer, handle, submitMessage, isAttached, valueTypes, eventEmitter = new TypedEventEmitter()) {\n    this.serializer = serializer;\n    this.handle = handle;\n    this.submitMessage = submitMessage;\n    this.isAttached = isAttached;\n    this.eventEmitter = eventEmitter;\n    /**\n     * Mapping of op types to message handlers.\n     */\n    this.messageHandlers = new Map();\n    /**\n     * The in-memory data the map is storing.\n     */\n    this.data = new Map();\n    /**\n     * Keys that have been modified locally but not yet ack'd from the server.\n     */\n    this.pendingKeys = new Map();\n    /**\n     * This is used to assign a unique id to every outgoing operation and helps in tracking unack'd ops.\n     */\n    this.pendingMessageId = -1;\n    /**\n     * If a clear has been performed locally but not yet ack'd from the server, then this stores the pending id\n     * of that clear operation. Otherwise, is -1.\n     */\n    this.pendingClearMessageId = -1;\n    this.localValueMaker = new LocalValueMaker(serializer);\n    this.messageHandlers = this.getMessageHandlers();\n    for (const type of valueTypes) {\n      this.localValueMaker.registerValueType(type);\n    }\n  }\n  /**\n   * The number of key/value pairs stored in the map.\n   */\n  get size() {\n    return this.data.size;\n  }\n  /**\n   * Get an iterator over the keys in this map.\n   * @returns The iterator\n   */\n  keys() {\n    return this.data.keys();\n  }\n  /**\n   * Get an iterator over the entries in this map.\n   * @returns The iterator\n   */\n  entries() {\n    const localEntriesIterator = this.data.entries();\n    const iterator = {\n      next() {\n        const nextVal = localEntriesIterator.next();\n        if (nextVal.done) {\n          return {\n            value: undefined,\n            done: true\n          };\n        } else {\n          // Unpack the stored value\n          return {\n            value: [nextVal.value[0], nextVal.value[1].value],\n            done: false\n          };\n        }\n      },\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n    return iterator;\n  }\n  /**\n   * Get an iterator over the values in this map.\n   * @returns The iterator\n   */\n  values() {\n    const localValuesIterator = this.data.values();\n    const iterator = {\n      next() {\n        const nextVal = localValuesIterator.next();\n        if (nextVal.done) {\n          return {\n            value: undefined,\n            done: true\n          };\n        } else {\n          // Unpack the stored value\n          return {\n            value: nextVal.value.value,\n            done: false\n          };\n        }\n      },\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n    return iterator;\n  }\n  /**\n   * Get an iterator over the entries in this map.\n   * @returns The iterator\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Executes the given callback on each entry in the map.\n   * @param callbackFn - Callback function\n   */\n  forEach(callbackFn) {\n    this.data.forEach((localValue, key, m) => {\n      callbackFn(localValue.value, key, m);\n    });\n  }\n  /**\n   * {@inheritDoc ISharedMap.get}\n   */\n  get(key) {\n    if (!this.data.has(key)) {\n      return undefined;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const localValue = this.data.get(key);\n    return localValue.value;\n  }\n  /**\n   * {@inheritDoc ISharedMap.wait}\n   */\n  wait(key) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // Return immediately if the value already exists\n      if (_this.has(key)) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return _this.get(key);\n      }\n      // Otherwise subscribe to changes\n      return new Promise(resolve => {\n        const callback = changed => {\n          if (key === changed.key) {\n            // eslint-disable-next-line max-len\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-unnecessary-type-assertion\n            resolve(_this.get(changed.key));\n            _this.eventEmitter.removeListener(\"valueChanged\", callback);\n          }\n        };\n        _this.eventEmitter.on(\"valueChanged\", callback);\n      });\n    })();\n  }\n  /**\n   * Check if a key exists in the map.\n   * @param key - The key to check\n   * @returns True if the key exists, false otherwise\n   */\n  has(key) {\n    return this.data.has(key);\n  }\n  /**\n   * {@inheritDoc ISharedMap.set}\n   */\n  set(key, value) {\n    // Undefined/null keys can't be serialized to JSON in the manner we currently snapshot.\n    if (key === undefined || key === null) {\n      throw new Error(\"Undefined and null keys are not supported\");\n    }\n    // Create a local value and serialize it.\n    const localValue = this.localValueMaker.fromInMemory(value);\n    const serializableValue = makeSerializable(localValue, this.serializer, this.handle);\n    // Set the value locally.\n    this.setCore(key, localValue, true, null);\n    // If we are not attached, don't submit the op.\n    if (!this.isAttached()) {\n      return;\n    }\n    const op = {\n      key,\n      type: \"set\",\n      value: serializableValue\n    };\n    this.submitMapKeyMessage(op);\n  }\n  /**\n   * {@inheritDoc IValueTypeCreator.createValueType}\n   */\n  createValueType(key, type, params) {\n    // Create a local value and serialize it.\n    const localValue = this.localValueMaker.makeValueType(type, this.makeMapValueOpEmitter(key), params);\n    // TODO ideally we could use makeSerialized in this case as well. But the interval\n    // collection has assumptions of attach being called prior. Given the IFluidSerializer it\n    // may be possible to remove custom value type serialization entirely.\n    const transformedValue = makeHandlesSerializable(params, this.serializer, this.handle);\n    // Set the value locally.\n    this.setCore(key, localValue, true, null);\n    // If we are not attached, don't submit the op.\n    if (!this.isAttached()) {\n      return this;\n    }\n    // This is a special form of serialized valuetype only used for set, containing info for initialization.\n    // After initialization, the serialized form will need to come from the .store of the value type's factory.\n    const serializableValue = {\n      type,\n      value: transformedValue\n    };\n    const op = {\n      key,\n      type: \"set\",\n      value: serializableValue\n    };\n    this.submitMapKeyMessage(op);\n    return this;\n  }\n  /**\n   * Delete a key from the map.\n   * @param key - Key to delete\n   * @returns True if the key existed and was deleted, false if it did not exist\n   */\n  delete(key) {\n    // Delete the key locally first.\n    const successfullyRemoved = this.deleteCore(key, true, null);\n    // If we are not attached, don't submit the op.\n    if (!this.isAttached()) {\n      return successfullyRemoved;\n    }\n    const op = {\n      key,\n      type: \"delete\"\n    };\n    this.submitMapKeyMessage(op);\n    return successfullyRemoved;\n  }\n  /**\n   * Clear all data from the map.\n   */\n  clear() {\n    // Clear the data locally first.\n    this.clearCore(true, null);\n    // If we are not attached, don't submit the op.\n    if (!this.isAttached()) {\n      return;\n    }\n    const op = {\n      type: \"clear\"\n    };\n    this.submitMapClearMessage(op);\n  }\n  /**\n   * Serializes the data stored in the shared map to a JSON string\n   * @param serializer - The serializer to use to serialize handles in its values.\n   * @returns A JSON string containing serialized map data\n   */\n  getSerializedStorage(serializer) {\n    const serializableMapData = {};\n    this.data.forEach((localValue, key) => {\n      serializableMapData[key] = localValue.makeSerialized(serializer, this.handle);\n    });\n    return serializableMapData;\n  }\n  getSerializableStorage(serializer) {\n    const serializableMapData = {};\n    this.data.forEach((localValue, key) => {\n      serializableMapData[key] = makeSerializable(localValue, serializer, this.handle);\n    });\n    return serializableMapData;\n  }\n  serialize(serializer) {\n    return JSON.stringify(this.getSerializableStorage(serializer));\n  }\n  /**\n   * Populate the kernel with the given map data.\n   * @param data - A JSON string containing serialized map data\n   */\n  populateFromSerializable(json) {\n    for (const [key, serializable] of Object.entries(json)) {\n      const localValue = {\n        key,\n        value: this.makeLocal(key, serializable)\n      };\n      this.data.set(localValue.key, localValue.value);\n    }\n  }\n  populate(json) {\n    this.populateFromSerializable(JSON.parse(json));\n  }\n  /**\n   * Submit the given op if a handler is registered.\n   * @param op - The operation to attempt to submit\n   * @param localOpMetadata - The local metadata associated with the op. This is kept locally by the runtime\n   * and not sent to the server. This will be sent back when this message is received back from the server. This is\n   * also sent if we are asked to resubmit the message.\n   * @returns True if the operation was submitted, false otherwise.\n   */\n  trySubmitMessage(op, localOpMetadata) {\n    const type = op.type;\n    if (this.messageHandlers.has(type)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.messageHandlers.get(type).submit(op, localOpMetadata);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Process the given op if a handler is registered.\n   * @param message - The message to process\n   * @param local - Whether the message originated from the local client\n   * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n   * For messages from a remote client, this will be undefined.\n   * @returns True if the operation was processed, false otherwise.\n   */\n  tryProcessMessage(message, local, localOpMetadata) {\n    const op = message.contents;\n    if (this.messageHandlers.has(op.type)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.messageHandlers.get(op.type).process(op, local, message, localOpMetadata);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Set implementation used for both locally sourced sets as well as incoming remote sets.\n   * @param key - The key being set\n   * @param value - The value being set\n   * @param local - Whether the message originated from the local client\n   * @param op - The message if from a remote set, or null if from a local set\n   */\n  setCore(key, value, local, op) {\n    const previousValue = this.get(key);\n    this.data.set(key, value);\n    const event = {\n      key,\n      previousValue\n    };\n    this.eventEmitter.emit(\"valueChanged\", event, local, op, this.eventEmitter);\n  }\n  /**\n   * Clear implementation used for both locally sourced clears as well as incoming remote clears.\n   * @param local - Whether the message originated from the local client\n   * @param op - The message if from a remote clear, or null if from a local clear\n   */\n  clearCore(local, op) {\n    this.data.clear();\n    this.eventEmitter.emit(\"clear\", local, op, this.eventEmitter);\n  }\n  /**\n   * Delete implementation used for both locally sourced deletes as well as incoming remote deletes.\n   * @param key - The key being deleted\n   * @param local - Whether the message originated from the local client\n   * @param op - The message if from a remote delete, or null if from a local delete\n   * @returns True if the key existed and was deleted, false if it did not exist\n   */\n  deleteCore(key, local, op) {\n    const previousValue = this.get(key);\n    const successfullyRemoved = this.data.delete(key);\n    if (successfullyRemoved) {\n      const event = {\n        key,\n        previousValue\n      };\n      this.eventEmitter.emit(\"valueChanged\", event, local, op, this.eventEmitter);\n    }\n    return successfullyRemoved;\n  }\n  /**\n   * Clear all keys in memory in response to a remote clear, but retain keys we have modified but not yet been ack'd.\n   */\n  clearExceptPendingKeys() {\n    // Assuming the pendingKeys is small and the map is large\n    // we will get the value for the pendingKeys and clear the map\n    const temp = new Map();\n    this.pendingKeys.forEach((value, key) => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      temp.set(key, this.data.get(key));\n    });\n    this.data.clear();\n    temp.forEach((value, key) => {\n      this.data.set(key, value);\n    });\n  }\n  /**\n   * The remote ISerializableValue we're receiving (either as a result of a load or an incoming set op) will\n   * have the information we need to create a real object, but will not be the real object yet.  For example,\n   * we might know it's a map and the map's ID but not have the actual map or its data yet.  makeLocal's\n   * job is to convert that information into a real object for local usage.\n   * @param key - The key that the caller intends to store the local value into (used for ops later).  But\n   * doesn't actually store the local value into that key.  So better not lie!\n   * @param serializable - The remote information that we can convert into a real object\n   * @returns The local value that was produced\n   */\n  makeLocal(key, serializable) {\n    if (serializable.type === ValueType[ValueType.Plain] || serializable.type === ValueType[ValueType.Shared]) {\n      return this.localValueMaker.fromSerializable(serializable);\n    } else {\n      return this.localValueMaker.fromSerializableValueType(serializable, this.makeMapValueOpEmitter(key));\n    }\n  }\n  /**\n   * If our local operations that have not yet been ack'd will eventually overwrite an incoming operation, we should\n   * not process the incoming operation.\n   * @param op - Operation to check\n   * @param local - Whether the message originated from the local client\n   * @param message - The message\n   * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n   * For messages from a remote client, this will be undefined.\n   * @returns True if the operation should be processed, false otherwise\n   */\n  needProcessKeyOperation(op, local, message, localOpMetadata) {\n    if (this.pendingClearMessageId !== -1) {\n      if (local) {\n        assert(localOpMetadata !== undefined && localOpMetadata < this.pendingClearMessageId, \"Received out of order op when there is an unackd clear message\");\n      }\n      // If we have an unack'd clear, we can ignore all ops.\n      return false;\n    }\n    if (this.pendingKeys.has(op.key)) {\n      // Found an unack'd op. Clear it from the map if the pendingMessageId in the map matches this message's\n      // and don't process the op.\n      if (local) {\n        assert(localOpMetadata !== undefined, `pendingMessageId is missing from the local client's ${op.type} operation`);\n        const pendingMessageId = localOpMetadata;\n        const pendingKeyMessageId = this.pendingKeys.get(op.key);\n        if (pendingKeyMessageId === pendingMessageId) {\n          this.pendingKeys.delete(op.key);\n        }\n      }\n      return false;\n    }\n    // If we don't have a NACK op on the key, we need to process the remote ops.\n    return !local;\n  }\n  /**\n   * Get the message handlers for the map.\n   * @returns A map of string op names to IMapMessageHandlers for those ops\n   */\n  getMessageHandlers() {\n    const messageHandlers = new Map();\n    messageHandlers.set(\"clear\", {\n      process: (op, local, message, localOpMetadata) => {\n        if (local) {\n          assert(localOpMetadata !== undefined, \"pendingMessageId is missing from the local client's clear operation\");\n          const pendingMessageId = localOpMetadata;\n          if (this.pendingClearMessageId === pendingMessageId) {\n            this.pendingClearMessageId = -1;\n          }\n          return;\n        }\n        if (this.pendingKeys.size !== 0) {\n          this.clearExceptPendingKeys();\n          return;\n        }\n        this.clearCore(local, message);\n      },\n      submit: (op, localOpMetadata) => {\n        // We don't reuse the metadata but send a new one on each submit.\n        this.submitMapClearMessage(op);\n      }\n    });\n    messageHandlers.set(\"delete\", {\n      process: (op, local, message, localOpMetadata) => {\n        if (!this.needProcessKeyOperation(op, local, message, localOpMetadata)) {\n          return;\n        }\n        this.deleteCore(op.key, local, message);\n      },\n      submit: (op, localOpMetadata) => {\n        // We don't reuse the metadata but send a new one on each submit.\n        this.submitMapKeyMessage(op);\n      }\n    });\n    messageHandlers.set(\"set\", {\n      process: (op, local, message, localOpMetadata) => {\n        if (!this.needProcessKeyOperation(op, local, message, localOpMetadata)) {\n          return;\n        }\n        // needProcessKeyOperation should have returned false if local is true\n        const context = this.makeLocal(op.key, op.value);\n        this.setCore(op.key, context, local, message);\n      },\n      submit: (op, localOpMetadata) => {\n        // We don't reuse the metadata but send a new one on each submit.\n        this.submitMapKeyMessage(op);\n      }\n    });\n    // Ops with type \"act\" describe actions taken by custom value type handlers of whatever item is\n    // being addressed.  These custom handlers can be retrieved from the ValueTypeLocalValue which has\n    // stashed its valueType (and therefore its handlers).  We also emit a valueChanged for anyone\n    // watching for manipulations of that item.\n    messageHandlers.set(\"act\", {\n      process: (op, local, message, localOpMetadata) => {\n        // Local value might not exist if we deleted it\n        const localValue = this.data.get(op.key);\n        if (!localValue) {\n          return;\n        }\n        const handler = localValue.getOpHandler(op.value.opName);\n        const previousValue = localValue.value;\n        const translatedValue = parseHandles(op.value.value, this.serializer);\n        handler.process(previousValue, translatedValue, local, message);\n        const event = {\n          key: op.key,\n          previousValue\n        };\n        this.eventEmitter.emit(\"valueChanged\", event, local, message, this.eventEmitter);\n      },\n      submit: (op, localOpMetadata) => {\n        this.submitMessage(op, localOpMetadata);\n      }\n    });\n    return messageHandlers;\n  }\n  /**\n   * Submit a clear message to remote clients.\n   * @param op - The clear message\n   */\n  submitMapClearMessage(op) {\n    const pendingMessageId = ++this.pendingMessageId;\n    this.submitMessage(op, pendingMessageId);\n    this.pendingClearMessageId = pendingMessageId;\n  }\n  /**\n   * Submit a map key message to remote clients.\n   * @param op - The map key message\n   */\n  submitMapKeyMessage(op) {\n    const pendingMessageId = ++this.pendingMessageId;\n    this.submitMessage(op, pendingMessageId);\n    this.pendingKeys.set(op.key, pendingMessageId);\n  }\n  /**\n   * Create an emitter for a value type to emit ops from the given key.\n   * @alpha\n   * @param key - The key of the map that the value type will be stored on\n   * @returns A value op emitter for the given key\n   */\n  makeMapValueOpEmitter(key) {\n    const emit = (opName, previousValue, params) => {\n      const translatedParams = makeHandlesSerializable(params, this.serializer, this.handle);\n      const op = {\n        key,\n        type: \"act\",\n        value: {\n          opName,\n          value: translatedParams\n        }\n      };\n      // Send the localOpMetadata as undefined because we don't care about the ack.\n      this.submitMessage(op, undefined /* localOpMetadata */);\n      const event = {\n        key,\n        previousValue\n      };\n      this.eventEmitter.emit(\"valueChanged\", event, true, null, this.eventEmitter);\n    };\n    return {\n      emit\n    };\n  }\n}\n//# sourceMappingURL=mapKernel.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}