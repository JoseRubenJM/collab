{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { fromBase64ToUtf8 } from \"@fluidframework/common-utils\";\nimport { MapKernel } from \"@fluidframework/map\";\nimport { FileMode, MessageType, TreeEntry } from \"@fluidframework/protocol-definitions\";\nimport { SharedObject } from \"@fluidframework/shared-object-base\";\nimport { debug } from \"./debug\";\nimport { IntervalCollectionValueType } from \"./intervalCollection\";\nimport { pkgVersion } from \"./packageVersion\";\nconst snapshotFileName = \"header\";\n/**\n * The factory that defines the SharedIntervalCollection\n */\nexport class SharedIntervalCollectionFactory {\n  get type() {\n    return SharedIntervalCollectionFactory.Type;\n  }\n  get attributes() {\n    return SharedIntervalCollectionFactory.Attributes;\n  }\n  /**\n   * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}\n   */\n  load(runtime, id, services, attributes) {\n    return _asyncToGenerator(function* () {\n      const map = new SharedIntervalCollection(id, runtime, attributes);\n      yield map.load(services);\n      return map;\n    })();\n  }\n  create(runtime, id) {\n    const map = new SharedIntervalCollection(id, runtime, this.attributes);\n    map.initializeLocal();\n    return map;\n  }\n}\nSharedIntervalCollectionFactory.Type = \"https://graph.microsoft.com/types/sharedIntervalCollection\";\nSharedIntervalCollectionFactory.Attributes = {\n  type: SharedIntervalCollectionFactory.Type,\n  snapshotFormatVersion: \"0.1\",\n  packageVersion: pkgVersion\n};\nexport class SharedIntervalCollection extends SharedObject {\n  /**\n   * Constructs a new shared SharedIntervalCollection. If the object is non-local an id and service interfaces will\n   * be provided\n   */\n  constructor(id, runtime, attributes) {\n    super(id, runtime, attributes);\n    this[Symbol.toStringTag] = \"SharedIntervalCollection\";\n    this.intervalMapKernel = new MapKernel(this.serializer, this.handle, (op, localOpMetadata) => this.submitLocalMessage(op, localOpMetadata), () => this.isAttached(), [new IntervalCollectionValueType()]);\n  }\n  /**\n   * Create a SharedIntervalCollection\n   *\n   * @param runtime - data store runtime the new shared map belongs to\n   * @param id - optional name of the shared map\n   * @returns newly create shared map (but not attached yet)\n   */\n  static create(runtime, id) {\n    return runtime.createChannel(id, SharedIntervalCollectionFactory.Type);\n  }\n  /**\n   * Get a factory for SharedIntervalCollection to register with the data store.\n   *\n   * @returns a factory that creates and load SharedIntervalCollection\n   */\n  static getFactory() {\n    return new SharedIntervalCollectionFactory();\n  }\n  waitIntervalCollection(label) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.intervalMapKernel.wait(_this.getIntervalCollectionPath(label));\n    })();\n  }\n  // TODO: fix race condition on creation by putting type on every operation\n  getIntervalCollection(label) {\n    const realLabel = this.getIntervalCollectionPath(label);\n    if (!this.intervalMapKernel.has(realLabel)) {\n      this.intervalMapKernel.createValueType(label, IntervalCollectionValueType.Name, undefined);\n    }\n    const sharedCollection = this.intervalMapKernel.get(realLabel);\n    return sharedCollection;\n  }\n  snapshotCore(serializer) {\n    const tree = {\n      entries: [{\n        mode: FileMode.File,\n        path: snapshotFileName,\n        type: TreeEntry.Blob,\n        value: {\n          contents: this.intervalMapKernel.serialize(serializer),\n          encoding: \"utf-8\"\n        }\n      }],\n      // eslint-disable-next-line no-null/no-null\n      id: null\n    };\n    return tree;\n  }\n  reSubmitCore(content, localOpMetadata) {\n    this.intervalMapKernel.trySubmitMessage(content, localOpMetadata);\n  }\n  onDisconnect() {\n    debug(`${this.id} is now disconnected`);\n  }\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}\n   */\n  loadCore(storage) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const header = yield storage.read(snapshotFileName);\n      const data = header ? fromBase64ToUtf8(header) : undefined;\n      _this2.intervalMapKernel.populate(data);\n    })();\n  }\n  processCore(message, local, localOpMetadata) {\n    if (message.type === MessageType.Operation) {\n      this.intervalMapKernel.tryProcessMessage(message, local, localOpMetadata);\n    }\n  }\n  registerCore() {\n    for (const value of this.intervalMapKernel.values()) {\n      if (SharedObject.is(value)) {\n        value.bindToContext();\n      }\n    }\n  }\n  /**\n   * Creates the full path of the intervalCollection label\n   * @param label - the incoming lable\n   */\n  getIntervalCollectionPath(label) {\n    return label;\n  }\n}\n//# sourceMappingURL=sharedIntervalCollection.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}