{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, LazyPromise } from \"@fluidframework/common-utils\";\nimport { CreateContainerError, DataCorruptionError } from \"@fluidframework/container-utils\";\nimport { readAndParse } from \"@fluidframework/driver-utils\";\nimport { gcBlobKey } from \"@fluidframework/runtime-definitions\";\nimport { attributesBlobKey, createServiceEndpoints, summarizeChannel } from \"./channelContext\";\nimport { debug } from \"./debug\";\nexport class RemoteChannelContext {\n  constructor(runtime, dataStoreContext, storageService, submitFn, dirtyFn, id, baseSnapshot, registry, extraBlobs, createSummarizerNode, attachMessageType) {\n    var _this = this;\n    this.runtime = runtime;\n    this.dataStoreContext = dataStoreContext;\n    this.id = id;\n    this.registry = registry;\n    this.attachMessageType = attachMessageType;\n    this.isLoaded = false;\n    this.pending = [];\n    /**\n     * This loads the GC details from the base snapshot of this context.\n     */\n    this.gcDetailsInInitialSummaryP = new LazyPromise( /*#__PURE__*/_asyncToGenerator(function* () {\n      if (yield _this.services.objectStorage.contains(gcBlobKey)) {\n        return readAndParse(_this.services.objectStorage, gcBlobKey);\n      } else {\n        return {};\n      }\n    }));\n    this.services = createServiceEndpoints(this.id, this.dataStoreContext.connected, submitFn, () => dirtyFn(this.id), storageService, baseSnapshot, extraBlobs);\n    const thisSummarizeInternal = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (fullTree, trackState) {\n        return _this.summarizeInternal(fullTree, trackState);\n      });\n      return function thisSummarizeInternal(_x, _x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    this.summarizerNode = createSummarizerNode(thisSummarizeInternal, /*#__PURE__*/_asyncToGenerator(function* () {\n      return _this.getGCDataInternal();\n    }), /*#__PURE__*/_asyncToGenerator(function* () {\n      return _this.gcDetailsInInitialSummaryP;\n    }));\n  }\n  // eslint-disable-next-line @typescript-eslint/promise-function-async\n  getChannel() {\n    if (this.channelP === undefined) {\n      this.channelP = this.loadChannel();\n    }\n    return this.channelP;\n  }\n  setConnectionState(connected, clientId) {\n    // Connection events are ignored if the data store is not yet loaded\n    if (!this.isLoaded) {\n      return;\n    }\n    this.services.deltaConnection.setConnectionState(connected);\n  }\n  processOp(message, local, localOpMetadata) {\n    this.summarizerNode.invalidate(message.sequenceNumber);\n    if (this.isLoaded) {\n      this.services.deltaConnection.process(message, local, localOpMetadata);\n    } else {\n      assert(!local, \"Remote channel must not be local when processing op\");\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.pending.push(message);\n    }\n  }\n  reSubmit(content, localOpMetadata) {\n    assert(this.isLoaded, \"Remote channel must be loaded when resubmitting op\");\n    this.services.deltaConnection.reSubmit(content, localOpMetadata);\n  }\n  /**\n   * Returns a summary at the current sequence number.\n   * @param fullTree - true to bypass optimizations and force a full summary tree\n   * @param trackState - This tells whether we should track state from this summary.\n   */\n  summarize(fullTree = false, trackState = true) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return _this2.summarizerNode.summarize(fullTree, trackState);\n    })();\n  }\n  summarizeInternal(fullTree, trackState) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const channel = yield _this3.getChannel();\n      const summarizeResult = summarizeChannel(channel, fullTree, trackState);\n      return Object.assign(Object.assign({}, summarizeResult), {\n        id: _this3.id\n      });\n    })();\n  }\n  loadChannel() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      assert(!_this4.isLoaded, \"Remote channel must not already be loaded when loading\");\n      let attributes;\n      if (yield _this4.services.objectStorage.contains(attributesBlobKey)) {\n        attributes = yield readAndParse(_this4.services.objectStorage, attributesBlobKey);\n      }\n      let factory;\n      // this is a back-compat case where\n      // the attach message doesn't include\n      // the attributes. Since old attach messages\n      // will not have attributes we need to keep\n      // this as long as we support old attach messages\n      if (attributes === undefined) {\n        if (_this4.attachMessageType === undefined) {\n          // TODO: Strip out potential PII content #1920\n          throw new DataCorruptionError(\"Channel type not available\", {\n            channelId: _this4.id,\n            dataStoreId: _this4.dataStoreContext.id,\n            dataStorePackagePath: _this4.dataStoreContext.packagePath.join(\"/\")\n          });\n        }\n        factory = _this4.registry.get(_this4.attachMessageType);\n        if (factory === undefined) {\n          // TODO: Strip out potential PII content #1920\n          throw new DataCorruptionError(`Channel Factory ${_this4.attachMessageType} for attach not registered`, {\n            channelId: _this4.id,\n            dataStoreId: _this4.dataStoreContext.id,\n            dataStorePackagePath: _this4.dataStoreContext.packagePath.join(\"/\"),\n            channelFactoryType: _this4.attachMessageType\n          });\n        }\n        attributes = factory.attributes;\n      } else {\n        factory = _this4.registry.get(attributes.type);\n        if (factory === undefined) {\n          // TODO: Strip out potential PII content #1920\n          throw new DataCorruptionError(`Channel Factory ${attributes.type} not registered`, {\n            channelId: _this4.id,\n            dataStoreId: _this4.dataStoreContext.id,\n            dataStorePackagePath: _this4.dataStoreContext.packagePath.join(\"/\"),\n            channelFactoryType: attributes.type\n          });\n        }\n      }\n      // Compare snapshot version to collaborative object version\n      if (attributes.snapshotFormatVersion !== undefined && attributes.snapshotFormatVersion !== factory.attributes.snapshotFormatVersion) {\n        debug(`Snapshot version mismatch. Type: ${attributes.type}, ` + `Snapshot format@pkg version: ${attributes.snapshotFormatVersion}@${attributes.packageVersion}, ` +\n        // eslint-disable-next-line max-len\n        `client format@pkg version: ${factory.attributes.snapshotFormatVersion}@${factory.attributes.packageVersion}`);\n      }\n      // eslint-disable-next-line max-len\n      debug(`Loading channel ${attributes.type}@${factory.attributes.packageVersion}, snapshot format version: ${attributes.snapshotFormatVersion}`);\n      const channel = yield factory.load(_this4.runtime, _this4.id, _this4.services, attributes);\n      // Send all pending messages to the channel\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      for (const message of _this4.pending) {\n        try {\n          _this4.services.deltaConnection.process(message, false, undefined /* localOpMetadata */);\n        } catch (err) {\n          // record sequence number for easier debugging\n          const error = CreateContainerError(err);\n          error.sequenceNumber = message.sequenceNumber;\n          throw error;\n        }\n      }\n      // Commit changes.\n      _this4.channel = channel;\n      _this4.pending = undefined;\n      _this4.isLoaded = true;\n      // Because have some await between we created the service and here, the connection state might have changed\n      // and we don't propagate the connection state when we are not loaded.  So we have to set it again here.\n      _this4.services.deltaConnection.setConnectionState(_this4.dataStoreContext.connected);\n      return _this4.channel;\n    })();\n  }\n  /**\n   * Returns the data used for garbage collection. This includes a list of GC nodes that represent this context.\n   * Each node has a set of outbound routes to other GC nodes in the document.\n   * If there is no new data in this context since the last summary, previous GC data is used.\n   * If there is new data, the GC data is generated again (by calling getGCDataInternal).\n   */\n  getGCData() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      return _this5.summarizerNode.getGCData();\n    })();\n  }\n  /**\n   * Generates the data used for garbage collection. This is called when there is new data since last summary. It\n   * loads the context and calls into the channel to get its GC data.\n   */\n  getGCDataInternal() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const channel = yield _this6.getChannel();\n      return channel.getGCData();\n    })();\n  }\n  /**\n   * After GC has run, called to notify the context of routes used in it. These are used for the following:\n   * 1. To identify if this context is being referenced in the document or not.\n   * 2. To determine if it needs to re-summarize in case used routes changed since last summary.\n   * 3. These are added to the summary generated by the context.\n   * @param usedRoutes - The routes that are used in this context.\n   */\n  updateUsedRoutes(usedRoutes) {\n    /**\n     * Currently, DDSs are always considered referenced and are not garbage collected. Update the summarizer node's\n     * used routes to contain a route to this channel context.\n     * Once we have GC at DDS level, this will be updated to use the passed usedRoutes. See -\n     * https://github.com/microsoft/FluidFramework/issues/4611\n     */\n    // back-compat: 0.33 - updateUsedRoutes is added in 0.33. Remove the check here when N >= 0.36.\n    if (this.summarizerNode.updateUsedRoutes !== undefined) {\n      this.summarizerNode.updateUsedRoutes([\"\"]);\n    }\n  }\n}\n//# sourceMappingURL=remoteChannelContext.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}