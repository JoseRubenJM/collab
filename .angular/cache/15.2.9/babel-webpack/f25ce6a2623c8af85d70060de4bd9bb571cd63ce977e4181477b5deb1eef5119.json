{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { buildRuntimeRequestHandler } from \"@fluidframework/request-handler\";\nimport { RequestParser } from \"@fluidframework/runtime-utils\";\n/**\n * A mountable view is only required if the view needs to be mounted across a bundle boundary.  Mounting across\n * bundle boundaries breaks some frameworks, so the mountable view is used to ensure the mounting is done within\n * the same bundle as the view.  For example, React hooks don't work if mounted across bundles since there will\n * be two React instances, breaking the Rules of Hooks.  When cross-bundle mounting isn't required, the mountable\n * view isn't necessary.\n *\n * When a request is received with a mountableView: true header, this request handler will reissue the request\n * without the header, and respond with a mountable view of the given class using the response.\n * @param MountableViewClass - The type of mountable view to use when responding\n */\nexport const mountableViewRequestHandler = (MountableViewClass, handlers) => {\n  const nestedHandler = buildRuntimeRequestHandler(...handlers);\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (request, runtime) {\n      var _a;\n      const mountableView = ((_a = request.headers) === null || _a === void 0 ? void 0 : _a.mountableView) === true;\n      let newRequest = request;\n      if (mountableView) {\n        // Reissue the request without the mountableView header.\n        // We'll repack whatever the response is if we can.\n        const headers = Object.assign({}, request.headers);\n        delete headers.mountableView;\n        newRequest = {\n          url: request.url,\n          headers\n        };\n      }\n      const response = yield nestedHandler(newRequest, runtime);\n      if (mountableView && response.status === 200 && MountableViewClass.canMount(response.value)) {\n        return {\n          status: 200,\n          mimeType: \"fluid/object\",\n          value: new MountableViewClass(response.value)\n        };\n      }\n      return response;\n    });\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};\n/**\n * Pipe through container request into internal request.\n * If request is empty and default url is provided, redirect request to such default url.\n * @param defaultRootId - optional default root data store ID to pass request in case request is empty.\n */\nexport const defaultRouteRequestHandler = defaultRootId => {\n  return /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator(function* (request, runtime) {\n      const parser = RequestParser.create(request);\n      if (parser.pathParts.length === 0) {\n        return runtime.IFluidHandleContext.resolveHandle({\n          url: `/${defaultRootId}${parser.query}`,\n          headers: request.headers\n        });\n      }\n      return undefined; // continue search\n    });\n    return function (_x3, _x4) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n};\n/**\n * Default request handler for a Fluid object that returns the object itself if:\n *  1. the request url is a \"/\"\n *  2. the request url is empty\n * Returns a 404 error for any other url.\n */\nexport function defaultFluidObjectRequestHandler(fluidObject, request) {\n  if (request.url === \"/\" || request.url === \"\") {\n    return {\n      mimeType: \"fluid/object\",\n      status: 200,\n      value: fluidObject\n    };\n  } else {\n    return {\n      mimeType: \"text/plain\",\n      status: 404,\n      value: `unknown request url: ${request.url}`\n    };\n  }\n}\n//# sourceMappingURL=requestHandlers.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}