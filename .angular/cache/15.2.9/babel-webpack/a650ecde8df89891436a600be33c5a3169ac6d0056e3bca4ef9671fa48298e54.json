{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { refGetRangeLabels, refGetTileLabels, refHasRangeLabel, refHasRangeLabels, refHasTileLabel, refHasTileLabels } from \"./mergeTree\";\nimport { ReferenceType } from \"./ops\";\nimport { addProperties } from \"./properties\";\nexport let LocalReference = /*#__PURE__*/(() => {\n  class LocalReference {\n    constructor(client, segment, offset = 0, refType = ReferenceType.Simple) {\n      this.client = client;\n      this.segment = segment;\n      this.offset = offset;\n      this.refType = refType;\n    }\n    min(b) {\n      if (this.compare(b) < 0) {\n        return this;\n      } else {\n        return b;\n      }\n    }\n    max(b) {\n      if (this.compare(b) > 0) {\n        return this;\n      } else {\n        return b;\n      }\n    }\n    compare(b) {\n      if (this.segment === b.segment) {\n        return this.offset - b.offset;\n      } else {\n        if (this.segment === undefined || b.segment !== undefined && this.segment.ordinal < b.segment.ordinal) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n    }\n    toPosition() {\n      if (this.segment && this.segment.parent) {\n        return this.getOffset() + this.client.getPosition(this.segment);\n      } else {\n        return LocalReference.DetachedPosition;\n      }\n    }\n    hasTileLabels() {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return refHasTileLabels(this);\n    }\n    hasRangeLabels() {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return refHasRangeLabels(this);\n    }\n    hasTileLabel(label) {\n      return refHasTileLabel(this, label);\n    }\n    hasRangeLabel(label) {\n      return refHasRangeLabel(this, label);\n    }\n    getTileLabels() {\n      return refGetTileLabels(this);\n    }\n    getRangeLabels() {\n      return refGetRangeLabels(this);\n    }\n    isLeaf() {\n      return false;\n    }\n    addProperties(newProps, op) {\n      this.properties = addProperties(this.properties, newProps, op);\n    }\n    getSegment() {\n      return this.segment;\n    }\n    getOffset() {\n      if (this.segment.removedSeq) {\n        return 0;\n      }\n      return this.offset;\n    }\n    getProperties() {\n      return this.properties;\n    }\n  }\n  LocalReference.DetachedPosition = -1;\n  return LocalReference;\n})();\nexport class LocalReferenceCollection {\n  constructor(segment, initialRefsByfOffset = new Array(segment.cachedLength)) {\n    this.segment = segment;\n    this.hierRefCount = 0;\n    this.refCount = 0;\n    // Since javascript arrays are sparse the above won't populate any of the\n    // indicies, but it will ensure the length property of the array matches\n    // the length of the segment.\n    this.refsByOffset = initialRefsByfOffset;\n  }\n  static append(seg1, seg2) {\n    if (seg2.localRefs && !seg2.localRefs.empty) {\n      if (!seg1.localRefs) {\n        seg1.localRefs = new LocalReferenceCollection(seg1);\n      }\n      seg1.localRefs.append(seg2.localRefs);\n    }\n  }\n  [Symbol.iterator]() {\n    const subiterators = [];\n    for (const refs of this.refsByOffset) {\n      if (refs) {\n        if (refs.before) {\n          subiterators.push(refs.before[Symbol.iterator]());\n        }\n        if (refs.at) {\n          subiterators.push(refs.at[Symbol.iterator]());\n        }\n        if (refs.after) {\n          subiterators.push(refs.after[Symbol.iterator]());\n        }\n      }\n    }\n    const iterator = {\n      next() {\n        while (subiterators.length > 0) {\n          const next = subiterators[0].next();\n          if (next.done === true) {\n            subiterators.shift();\n          } else {\n            return next;\n          }\n        }\n        return {\n          value: undefined,\n          done: true\n        };\n      },\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n    return iterator;\n  }\n  clear() {\n    this.refCount = 0;\n    this.hierRefCount = 0;\n    const detachSegments = refs => {\n      if (refs) {\n        refs.forEach(r => {\n          if (r.segment === this.segment) {\n            r.segment = undefined;\n          }\n        });\n      }\n    };\n    for (let i = 0; i < this.refsByOffset.length; i++) {\n      if (this.refsByOffset[i]) {\n        detachSegments(this.refsByOffset[i].before);\n        detachSegments(this.refsByOffset[i].at);\n        detachSegments(this.refsByOffset[i].before);\n        this.refsByOffset[i] = undefined;\n      }\n    }\n  }\n  get empty() {\n    return this.refCount === 0;\n  }\n  addLocalRef(lref) {\n    if (this.refsByOffset[lref.offset] === undefined) {\n      this.refsByOffset[lref.offset] = {\n        at: [lref]\n      };\n    } else {\n      this.refsByOffset[lref.offset].at.push(lref);\n    }\n    if (lref.hasRangeLabels() || lref.hasTileLabels()) {\n      this.hierRefCount++;\n    }\n    this.refCount++;\n  }\n  removeLocalRef(lref) {\n    const tryRemoveRef = refs => {\n      if (refs) {\n        const index = refs.indexOf(lref);\n        if (index >= 0) {\n          refs.splice(index, 1);\n          if (lref.hasRangeLabels() || lref.hasTileLabels()) {\n            this.hierRefCount--;\n          }\n          this.refCount--;\n          return lref;\n        }\n      }\n    };\n    const refAtOffset = this.refsByOffset[lref.offset];\n    if (refAtOffset !== undefined) {\n      let ref = tryRemoveRef(refAtOffset.before);\n      if (ref) {\n        return ref;\n      }\n      ref = tryRemoveRef(refAtOffset.at);\n      if (ref) {\n        return ref;\n      }\n      ref = tryRemoveRef(refAtOffset.after);\n      if (ref) {\n        return ref;\n      }\n    }\n  }\n  /**\n   * Called by 'append()' implementations to append local refs from the given 'other' segment to the\n   * end of 'this' segment.\n   *\n   * Note: This method should be invoked after the caller has ensured that segments can be merged,\n   *       but before 'this' segment's cachedLength has changed, or the adjustment to the local refs\n   *       will be incorrect.\n   */\n  append(other) {\n    if (!other || other.empty) {\n      return;\n    }\n    this.hierRefCount += other.hierRefCount;\n    this.refCount += other.refCount;\n    other.hierRefCount = 0;\n    for (const lref of other) {\n      lref.segment = this.segment;\n      lref.offset += this.refsByOffset.length;\n    }\n    this.refsByOffset.push(...other.refsByOffset);\n  }\n  split(offset, splitSeg) {\n    if (!this.empty) {\n      splitSeg.localRefs = new LocalReferenceCollection(splitSeg, this.refsByOffset.splice(offset, this.refsByOffset.length - offset));\n      for (const lref of splitSeg.localRefs) {\n        lref.segment = splitSeg;\n        lref.offset -= offset;\n        if (lref.hasRangeLabels() || lref.hasTileLabels()) {\n          this.hierRefCount--;\n          splitSeg.localRefs.hierRefCount++;\n        }\n        this.refCount--;\n        splitSeg.localRefs.refCount++;\n      }\n    }\n  }\n  addBeforeTombstones(...refs) {\n    const beforeRefs = [];\n    for (const iterable of refs) {\n      for (const lref of iterable) {\n        // eslint-disable-next-line no-bitwise\n        if (lref.refType & ReferenceType.SlideOnRemove) {\n          beforeRefs.push(lref);\n          lref.segment = this.segment;\n          lref.offset = 0;\n          if (lref.hasRangeLabels() || lref.hasTileLabels()) {\n            this.hierRefCount++;\n          }\n          this.refCount++;\n        } else {\n          lref.segment = undefined;\n        }\n      }\n    }\n    if (beforeRefs.length > 0) {\n      if (this.refsByOffset[0] === undefined) {\n        this.refsByOffset[0] = {\n          before: beforeRefs\n        };\n      } else if (this.refsByOffset[0].before === undefined) {\n        this.refsByOffset[0].before = beforeRefs;\n      } else {\n        this.refsByOffset[0].before.unshift(...beforeRefs);\n      }\n    }\n  }\n  addAfterTombstones(...refs) {\n    const afterRefs = [];\n    for (const iterable of refs) {\n      for (const lref of iterable) {\n        // eslint-disable-next-line no-bitwise\n        if (lref.refType & ReferenceType.SlideOnRemove) {\n          afterRefs.push(lref);\n          lref.segment = this.segment;\n          lref.offset = this.segment.cachedLength - 1;\n          if (lref.hasRangeLabels() || lref.hasTileLabels()) {\n            this.hierRefCount++;\n          }\n          this.refCount++;\n        } else {\n          lref.segment = undefined;\n        }\n      }\n    }\n    if (afterRefs.length > 0) {\n      if (this.refsByOffset[this.segment.cachedLength - 1] === undefined) {\n        this.refsByOffset[this.segment.cachedLength - 1] = {\n          after: afterRefs\n        };\n      } else if (this.refsByOffset[this.segment.cachedLength - 1].after === undefined) {\n        this.refsByOffset[this.segment.cachedLength - 1].after = afterRefs;\n      } else {\n        this.refsByOffset[this.segment.cachedLength - 1].after.push(...afterRefs);\n      }\n    }\n  }\n}\n//# sourceMappingURL=localReference.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}