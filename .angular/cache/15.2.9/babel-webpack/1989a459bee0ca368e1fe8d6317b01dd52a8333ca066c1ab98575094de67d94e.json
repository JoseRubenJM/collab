{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport * as base64js from \"base64-js\";\n/**\n * Converts a Uint8Array to a string of the provided encoding\n * Useful when the array might be an {@link IsoBuffer}.\n *\n * @param arr - The array to convert.\n * @param encoding - Optional target encoding; only \"utf8\" and \"base64\" are\n * supported, with \"utf8\" being default.\n * @returns The converted string.\n */\nexport function Uint8ArrayToString(arr, encoding) {\n  switch (encoding) {\n    case \"base64\":\n      {\n        return base64js.fromByteArray(arr);\n      }\n    case \"utf8\":\n    case \"utf-8\":\n    case undefined:\n      {\n        return new TextDecoder().decode(arr);\n      }\n    default:\n      {\n        throw new Error(\"invalid/unsupported encoding\");\n      }\n  }\n}\n/**\n * Converts a {@link https://en.wikipedia.org/wiki/Base64 | base64} or\n * {@link https://en.wikipedia.org/wiki/UTF-8 | utf-8} string to array buffer.\n *\n * @param encoding - The input string's encoding.\n */\nexport const stringToBuffer = (input, encoding) => IsoBuffer.from(input, encoding).buffer;\n/**\n * Convert binary blob to string format\n *\n * @param blob - the binary blob\n * @param encoding - output string's encoding\n * @returns the blob in string format\n */\nexport const bufferToString = (blob, encoding) => IsoBuffer.from(blob).toString(encoding);\n/**\n * Determines if an object is an array buffer.\n *\n * @remarks Will detect and reject TypedArrays, like Uint8Array.\n * Reason - they can be viewport into Array, they can be accepted, but caller has to deal with\n * math properly (i.e. Take into account byteOffset at minimum).\n * For example, construction of new TypedArray can be in the form of new TypedArray(typedArray) or\n * new TypedArray(buffer, byteOffset, length), but passing TypedArray will result in fist path (and\n * ignoring byteOffice, length).\n *\n * @param obj - The object to determine if it is an ArrayBuffer.\n */\nexport function isArrayBuffer(obj) {\n  const maybe = obj;\n  return obj instanceof ArrayBuffer || typeof maybe === \"object\" && maybe !== null && typeof maybe.byteLength === \"number\" && typeof maybe.slice === \"function\" && maybe.byteOffset === undefined && maybe.buffer === undefined;\n}\n/**\n * Minimal implementation of Buffer for our usages in the browser environment.\n */\nexport class IsoBuffer extends Uint8Array {\n  /**\n   * Convert the buffer to a string.\n   * Only supports encoding the whole string (unlike the Node Buffer equivalent)\n   * and only utf8 and base64 encodings.\n   *\n   * @param encoding - The encoding to use.\n   */\n  toString(encoding) {\n    return Uint8ArrayToString(this, encoding);\n  }\n  /**\n   * @param value - (string | ArrayBuffer)\n   * @param encodingOrOffset - (string | number)\n   * @param length - (number)\n   */\n  static from(value, encodingOrOffset, length) {\n    if (typeof value === \"string\") {\n      return IsoBuffer.fromString(value, encodingOrOffset);\n      // Capture any typed arrays, including Uint8Array (and thus - IsoBuffer!)\n    } else if (value !== null && typeof value === \"object\" && isArrayBuffer(value.buffer)) {\n      // The version of the from function for the node buffer, which takes a buffer or typed array\n      // as first parameter, does not have any offset or length parameters. Those are just silently\n      // ignored and not taken into account\n      return IsoBuffer.fromArrayBuffer(value.buffer, value.byteOffset, value.byteLength);\n    } else if (isArrayBuffer(value)) {\n      return IsoBuffer.fromArrayBuffer(value, encodingOrOffset, length);\n    } else {\n      throw new TypeError();\n    }\n  }\n  static fromArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n    const offset = byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0;\n    const validLength = byteLength !== null && byteLength !== void 0 ? byteLength : arrayBuffer.byteLength - offset;\n    if (offset < 0 || offset > arrayBuffer.byteLength || validLength < 0 || validLength + offset > arrayBuffer.byteLength) {\n      throw new RangeError();\n    }\n    return new IsoBuffer(arrayBuffer, offset, validLength);\n  }\n  static fromString(str, encoding) {\n    switch (encoding) {\n      case \"base64\":\n        {\n          const sanitizedString = this.sanitizeBase64(str);\n          const encoded = base64js.toByteArray(sanitizedString);\n          return new IsoBuffer(encoded.buffer);\n        }\n      case \"utf8\":\n      case \"utf-8\":\n      case undefined:\n        {\n          const encoded = new TextEncoder().encode(str);\n          return new IsoBuffer(encoded.buffer);\n        }\n      default:\n        {\n          throw new Error(\"invalid/unsupported encoding\");\n        }\n    }\n  }\n  static isBuffer(obj) {\n    throw new Error(\"unimplemented\");\n  }\n  /**\n   * Sanitize a base64 string to provide to base64-js library.\n   * {@link https://www.npmjs.com/package/base64-js} is not as tolerant of the same malformed base64 as Node'\n   * Buffer is.\n   */\n  static sanitizeBase64(str) {\n    let sanitizedStr = str;\n    // Remove everything after padding - Node buffer ignores everything\n    // after any padding whereas base64-js does not\n    sanitizedStr = sanitizedStr.split(\"=\")[0];\n    // Remove invalid characters - Node buffer strips invalid characters\n    // whereas base64-js replaces them with \"A\"\n    sanitizedStr = sanitizedStr.replace(/[^\\w+-/]/g, \"\");\n    // Check for missing padding - Node buffer tolerates missing padding\n    // whereas base64-js does not\n    if (sanitizedStr.length % 4 !== 0) {\n      const paddingArray = [\"\", \"===\", \"==\", \"=\"];\n      sanitizedStr += paddingArray[sanitizedStr.length % 4];\n    }\n    return sanitizedStr;\n  }\n}\n//# sourceMappingURL=bufferBrowser.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}