{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/* eslint-disable no-bitwise */\nimport { EventEmitter } from \"events\";\nimport * as MergeTree from \"@fluidframework/merge-tree\";\nexport class Interval {\n  constructor(start, end, props) {\n    this.start = start;\n    this.end = end;\n    if (props) {\n      this.addProperties(props);\n    }\n  }\n  getAdditionalPropertySets() {\n    return this.auxProps;\n  }\n  addPropertySet(props) {\n    if (this.auxProps === undefined) {\n      this.auxProps = [];\n    }\n    this.auxProps.push(props);\n  }\n  serialize(client) {\n    let seq = 0;\n    if (client) {\n      seq = client.getCurrentSeq();\n    }\n    const serializedInterval = {\n      end: this.end,\n      intervalType: 0,\n      sequenceNumber: seq,\n      start: this.start\n    };\n    if (this.properties) {\n      serializedInterval.properties = this.properties;\n    }\n    return serializedInterval;\n  }\n  clone() {\n    return new Interval(this.start, this.end, this.properties);\n  }\n  compare(b) {\n    const startResult = this.start - b.start;\n    if (startResult === 0) {\n      return this.end - b.end;\n    } else {\n      return startResult;\n    }\n  }\n  overlaps(b) {\n    const result = this.start < b.end && this.end >= b.start;\n    return result;\n  }\n  union(b) {\n    return new Interval(Math.min(this.start, b.start), Math.max(this.end, b.end), this.properties);\n  }\n  getProperties() {\n    return this.properties;\n  }\n  addProperties(newProps, op) {\n    this.properties = MergeTree.addProperties(this.properties, newProps, op);\n  }\n}\nexport class SequenceInterval {\n  constructor(start, end, intervalType, props) {\n    this.start = start;\n    this.end = end;\n    this.intervalType = intervalType;\n    if (props) {\n      this.addProperties(props);\n    }\n  }\n  serialize(client) {\n    const startPosition = this.start.toPosition();\n    const endPosition = this.end.toPosition();\n    const serializedInterval = {\n      end: endPosition,\n      intervalType: this.intervalType,\n      sequenceNumber: client.getCurrentSeq(),\n      start: startPosition\n    };\n    if (this.properties) {\n      serializedInterval.properties = this.properties;\n    }\n    return serializedInterval;\n  }\n  clone() {\n    return new SequenceInterval(this.start, this.end, this.intervalType);\n  }\n  compare(b) {\n    const startResult = this.start.compare(b.start);\n    if (startResult === 0) {\n      return this.end.compare(b.end);\n    } else {\n      return startResult;\n    }\n  }\n  overlaps(b) {\n    const result = this.start.compare(b.end) < 0 && this.end.compare(b.start) >= 0;\n    if (this.checkMergeTree) {\n      this.checkOverlaps(b, result);\n    }\n    return result;\n  }\n  union(b) {\n    return new SequenceInterval(this.start.min(b.start), this.end.max(b.end), this.intervalType);\n  }\n  addProperties(newProps, op) {\n    this.properties = MergeTree.addProperties(this.properties, newProps, op);\n  }\n  overlapsPos(bstart, bend) {\n    const startPos = this.start.toPosition();\n    const endPos = this.start.toPosition();\n    return endPos > bstart && startPos < bend;\n  }\n  checkOverlaps(b, result) {\n    const astart = this.start.toPosition();\n    const bstart = b.start.toPosition();\n    const aend = this.end.toPosition();\n    const bend = b.end.toPosition();\n    const checkResult = astart < bend && bstart < aend;\n    if (checkResult !== result) {\n      // eslint-disable-next-line max-len\n      console.log(`check mismatch: res ${result} ${this.start.segment === b.end.segment} ${b.start.segment === this.end.segment}`);\n      console.log(`as ${astart} ae ${aend} bs ${bstart} be ${bend}`);\n      console.log(`as ${MergeTree.ordinalToArray(this.start.segment.ordinal)}@${this.start.offset}`);\n      console.log(`ae ${MergeTree.ordinalToArray(this.end.segment.ordinal)}@${this.end.offset}`);\n      console.log(`bs ${MergeTree.ordinalToArray(b.start.segment.ordinal)}@${b.start.offset}`);\n      console.log(`be ${MergeTree.ordinalToArray(b.end.segment.ordinal)}@${b.end.offset}`);\n      console.log(this.checkMergeTree.nodeToString(b.start.segment.parent, \"\"));\n    }\n  }\n}\nfunction createPositionReference(client, pos, refType) {\n  const segoff = client.getContainingSegment(pos);\n  if (segoff && segoff.segment) {\n    const lref = new MergeTree.LocalReference(client, segoff.segment, segoff.offset, refType);\n    if (refType !== MergeTree.ReferenceType.Transient) {\n      client.addLocalReference(lref);\n    }\n    return lref;\n  }\n  return new MergeTree.LocalReference(client, undefined);\n}\nfunction createSequenceInterval(label, start, end, client, intervalType) {\n  let beginRefType = MergeTree.ReferenceType.RangeBegin;\n  let endRefType = MergeTree.ReferenceType.RangeEnd;\n  if (intervalType === MergeTree.IntervalType.Nest) {\n    beginRefType = MergeTree.ReferenceType.NestBegin;\n    endRefType = MergeTree.ReferenceType.NestEnd;\n  } else if (intervalType === MergeTree.IntervalType.Transient) {\n    beginRefType = MergeTree.ReferenceType.Transient;\n    endRefType = MergeTree.ReferenceType.Transient;\n  }\n  // TODO: Should SlideOnRemove be the default behavior?\n  if (intervalType & MergeTree.IntervalType.SlideOnRemove) {\n    beginRefType |= MergeTree.ReferenceType.SlideOnRemove;\n    endRefType |= MergeTree.ReferenceType.SlideOnRemove;\n  }\n  const startLref = createPositionReference(client, start, beginRefType);\n  const endLref = createPositionReference(client, end, endRefType);\n  if (startLref && endLref) {\n    startLref.pairedRef = endLref;\n    endLref.pairedRef = startLref;\n    const rangeProp = {\n      [MergeTree.reservedRangeLabelsKey]: [label]\n    };\n    startLref.addProperties(rangeProp);\n    endLref.addProperties(rangeProp);\n    const ival = new SequenceInterval(startLref, endLref, intervalType, rangeProp);\n    return ival;\n  }\n}\nexport function defaultIntervalConflictResolver(a, b) {\n  a.addPropertySet(b.properties);\n  return a;\n}\nexport function createIntervalIndex(conflict) {\n  const helpers = {\n    compareEnds: compareIntervalEnds,\n    create: createInterval\n  };\n  const lc = new LocalIntervalCollection(undefined, \"\", helpers);\n  if (conflict) {\n    lc.addConflictResolver(conflict);\n  } else {\n    lc.addConflictResolver(defaultIntervalConflictResolver);\n  }\n  return lc;\n}\nexport class LocalIntervalCollection {\n  constructor(client, label, helpers) {\n    this.client = client;\n    this.label = label;\n    this.helpers = helpers;\n    this.intervalTree = new MergeTree.IntervalTree();\n    this.endIntervalTree =\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    new MergeTree.RedBlackTree(helpers.compareEnds);\n  }\n  addConflictResolver(conflictResolver) {\n    this.conflictResolver = conflictResolver;\n    this.endConflictResolver = (key, currentKey) => {\n      const ival = this.conflictResolver(key, currentKey);\n      return {\n        data: ival,\n        key: ival\n      };\n    };\n  }\n  map(fn) {\n    this.intervalTree.map(fn);\n  }\n  findOverlappingIntervals(startPosition, endPosition) {\n    if (!this.intervalTree.intervals.isEmpty()) {\n      const transientInterval = this.helpers.create(\"transient\", startPosition, endPosition, this.client, MergeTree.IntervalType.Transient);\n      const overlappingIntervalNodes = this.intervalTree.match(transientInterval);\n      return overlappingIntervalNodes.map(node => node.key);\n    } else {\n      return [];\n    }\n  }\n  previousInterval(pos) {\n    const transientInterval = this.helpers.create(\"transient\", pos, pos, this.client, MergeTree.IntervalType.Transient);\n    const rbNode = this.endIntervalTree.floor(transientInterval);\n    if (rbNode) {\n      return rbNode.data;\n    }\n  }\n  nextInterval(pos) {\n    const transientInterval = this.helpers.create(\"transient\", pos, pos, this.client, MergeTree.IntervalType.Transient);\n    const rbNode = this.endIntervalTree.ceil(transientInterval);\n    if (rbNode) {\n      return rbNode.data;\n    }\n  }\n  removeInterval(startPosition, endPosition) {\n    const transientInterval = this.helpers.create(\"transient\", startPosition, endPosition, this.client, MergeTree.IntervalType.Transient);\n    this.intervalTree.remove(transientInterval);\n    this.endIntervalTree.remove(transientInterval);\n    return transientInterval;\n  }\n  createInterval(start, end, intervalType) {\n    return this.helpers.create(this.label, start, end, this.client, intervalType);\n  }\n  // TODO: remove interval, handle duplicate intervals\n  addInterval(start, end, intervalType, props) {\n    const interval = this.createInterval(start, end, intervalType);\n    if (interval) {\n      interval.addProperties(props);\n      if (this.label && this.label.length > 0) {\n        interval.properties[MergeTree.reservedRangeLabelsKey] = [this.label];\n      }\n      this.intervalTree.put(interval, this.conflictResolver);\n      this.endIntervalTree.put(interval, interval, this.endConflictResolver);\n    }\n    return interval;\n  }\n  serialize() {\n    const client = this.client;\n    const intervals = this.intervalTree.intervals.keys();\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return intervals.map(interval => interval.serialize(client));\n  }\n}\nconst compareSequenceIntervalEnds = (a, b) => a.end.compare(b.end);\nclass SequenceIntervalCollectionFactory {\n  load(emitter, raw = []) {\n    const helpers = {\n      compareEnds: compareSequenceIntervalEnds,\n      create: createSequenceInterval\n    };\n    return new IntervalCollection(helpers, true, emitter, raw);\n  }\n  store(value) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return value.serializeInternal();\n  }\n}\nexport class SequenceIntervalCollectionValueType {\n  get name() {\n    return SequenceIntervalCollectionValueType.Name;\n  }\n  get factory() {\n    return SequenceIntervalCollectionValueType._factory;\n  }\n  get ops() {\n    return SequenceIntervalCollectionValueType._ops;\n  }\n}\nSequenceIntervalCollectionValueType.Name = \"sharedStringIntervalCollection\";\nSequenceIntervalCollectionValueType._factory = new SequenceIntervalCollectionFactory();\nSequenceIntervalCollectionValueType._ops = new Map([[\"add\", {\n  process: (value, params, local, op) => {\n    // Local ops were applied when the message was created\n    if (local) {\n      return;\n    }\n    value.addInternal(params, local, op);\n  }\n}], [\"delete\", {\n  process: (value, params, local, op) => {\n    if (local) {\n      return;\n    }\n    value.deleteInterval(params, local, op);\n  }\n}]]);\nconst compareIntervalEnds = (a, b) => a.end - b.end;\nfunction createInterval(label, start, end, client) {\n  let rangeProp;\n  if (label && label.length > 0) {\n    rangeProp = {\n      [MergeTree.reservedRangeLabelsKey]: [label]\n    };\n  }\n  return new Interval(start, end, rangeProp);\n}\nclass IntervalCollectionFactory {\n  load(emitter, raw = []) {\n    const helpers = {\n      compareEnds: compareIntervalEnds,\n      create: createInterval\n    };\n    const collection = new IntervalCollection(helpers, false, emitter, raw);\n    collection.attachGraph(undefined, \"\");\n    return collection;\n  }\n  store(value) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return value.serializeInternal();\n  }\n}\nexport class IntervalCollectionValueType {\n  get name() {\n    return IntervalCollectionValueType.Name;\n  }\n  get factory() {\n    return IntervalCollectionValueType._factory;\n  }\n  get ops() {\n    return IntervalCollectionValueType._ops;\n  }\n}\nIntervalCollectionValueType.Name = \"sharedIntervalCollection\";\nIntervalCollectionValueType._factory = new IntervalCollectionFactory();\nIntervalCollectionValueType._ops = new Map([[\"add\", {\n  process: (value, params, local, op) => {\n    // Local ops were applied when the message was created\n    if (local) {\n      return;\n    }\n    value.addInternal(params, local, op);\n  }\n}], [\"delete\", {\n  process: (value, params, local, op) => {\n    if (local) {\n      return;\n    }\n    value.deleteInterval(params, local, op);\n  }\n}]]);\nexport class IntervalCollectionView extends EventEmitter {\n  constructor(client, savedSerializedIntervals, label, helpers, emitter) {\n    super();\n    this.client = client;\n    this.emitter = emitter;\n    // Instantiate the local interval collection based on the saved intervals\n    this.localCollection = new LocalIntervalCollection(client, label, helpers);\n    if (savedSerializedIntervals) {\n      for (const serializedInterval of savedSerializedIntervals) {\n        this.localCollection.addInterval(serializedInterval.start, serializedInterval.end, serializedInterval.intervalType, serializedInterval.properties);\n      }\n    }\n  }\n  attachDeserializer(onDeserialize) {\n    this.attachDeserializerCore(onDeserialize);\n  }\n  addConflictResolver(conflictResolver) {\n    this.localCollection.addConflictResolver(conflictResolver);\n  }\n  findOverlappingIntervals(startPosition, endPosition) {\n    return this.localCollection.findOverlappingIntervals(startPosition, endPosition);\n  }\n  map(fn) {\n    this.localCollection.map(fn);\n  }\n  previousInterval(pos) {\n    return this.localCollection.previousInterval(pos);\n  }\n  nextInterval(pos) {\n    return this.localCollection.nextInterval(pos);\n  }\n  on(event, listener) {\n    return super.on(event, listener);\n  }\n  add(start, end, intervalType, props) {\n    let seq = 0;\n    if (this.client) {\n      seq = this.client.getCurrentSeq();\n    }\n    const serializedInterval = {\n      end,\n      intervalType,\n      properties: props,\n      sequenceNumber: seq,\n      start\n    };\n    this.addInternal(serializedInterval, true, undefined);\n  }\n  delete(start, end) {\n    let sequenceNumber = 0;\n    if (this.client) {\n      sequenceNumber = this.client.getCurrentSeq();\n    }\n    const serializedInterval = {\n      start,\n      end,\n      sequenceNumber,\n      intervalType: MergeTree.IntervalType.Transient\n    };\n    this.deleteInterval(serializedInterval, true, undefined);\n  }\n  // TODO: error cases\n  addInternal(serializedInterval, local, op) {\n    const interval = this.localCollection.addInterval(serializedInterval.start, serializedInterval.end, serializedInterval.intervalType, serializedInterval.properties);\n    if (interval) {\n      // Local ops get submitted to the server. Remote ops have the deserializer run.\n      if (local) {\n        this.emitter.emit(\"add\", undefined, serializedInterval);\n      } else {\n        if (this.onDeserialize) {\n          this.onDeserialize(interval);\n        }\n      }\n    }\n    this.emit(\"addInterval\", interval, local, op);\n    return this;\n  }\n  deleteInterval(serializedInterval, local, op) {\n    const interval = this.localCollection.removeInterval(serializedInterval.start, serializedInterval.end);\n    if (interval) {\n      // Local ops get submitted to the server. Remote ops have the deserializer run.\n      if (local) {\n        this.emitter.emit(\"delete\", undefined, serializedInterval);\n      } else {\n        if (this.onDeserialize) {\n          this.onDeserialize(interval);\n        }\n      }\n    }\n    this.emit(\"deleteInterval\", interval, local, op);\n    return this;\n  }\n  serializeInternal() {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return this.localCollection.serialize();\n  }\n  attachDeserializerCore(onDeserialize) {\n    // If no deserializer is specified can skip all processing work\n    if (!onDeserialize) {\n      return;\n    }\n    // Start by storing the callbacks so that any subsequent modifications make use of them\n    this.onDeserialize = onDeserialize;\n    // Trigger the async prepare work across all values in the collection\n    this.localCollection.map(interval => {\n      this.onDeserialize(interval);\n    });\n  }\n}\nexport class IntervalCollection {\n  constructor(helpers, requiresClient, emitter, serializedIntervals) {\n    this.helpers = helpers;\n    this.requiresClient = requiresClient;\n    this.emitter = emitter;\n    this.savedSerializedIntervals = serializedIntervals;\n  }\n  get attached() {\n    return !!this.view;\n  }\n  attachGraph(client, label) {\n    if (this.view) {\n      throw new Error(\"Only supports one Sequence attach\");\n    }\n    if (client === undefined && this.requiresClient) {\n      throw new Error(\"Client required for this collection\");\n    }\n    this.view = new IntervalCollectionView(client, this.savedSerializedIntervals, label, this.helpers, this.emitter);\n    this.savedSerializedIntervals = undefined;\n  }\n  add(startPosition, endPosition, intervalType, props) {\n    if (!this.view) {\n      throw new Error(\"attach must be called prior to adding intervals\");\n    }\n    this.view.add(startPosition, endPosition, intervalType, props);\n  }\n  delete(startPosition, endPosition) {\n    if (!this.view) {\n      throw new Error(\"attach must be called prior to deleting intervals\");\n    }\n    this.view.delete(startPosition, endPosition);\n  }\n  addConflictResolver(conflictResolver) {\n    this.view.addConflictResolver(conflictResolver);\n  }\n  getView(onDeserialize) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (!_this.view) {\n        return Promise.reject(new Error(\"attachSequence must be called prior to retrieving the view\"));\n      }\n      // Attach custom deserializers if specified\n      if (onDeserialize) {\n        _this.view.attachDeserializer(onDeserialize);\n      }\n      return _this.view;\n    })();\n  }\n  addInternal(serializedInterval, local, op) {\n    if (!this.view) {\n      throw new Error(\"attachSequence must be called\");\n    }\n    return this.view.addInternal(serializedInterval, local, op);\n  }\n  deleteInterval(serializedInterval, local, op) {\n    if (!this.view) {\n      throw new Error(\"attach must be called prior to deleting intervals\");\n    }\n    this.view.deleteInterval(serializedInterval, local, op);\n  }\n  serializeInternal() {\n    if (!this.view) {\n      throw new Error(\"attachSequence must be called\");\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return this.view.serializeInternal();\n  }\n}\n//# sourceMappingURL=intervalCollection.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}