{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { AttachState } from \"@fluidframework/container-definitions\";\nimport { PerformanceEvent } from \"@fluidframework/telemetry-utils\";\nimport { assert, LazyPromise } from \"@fluidframework/common-utils\";\nimport { NullChaincode, NullRuntime } from \"./nullRuntime\";\nconst PackageNotFactoryError = \"Code package does not implement IRuntimeFactory\";\nexport class ContainerContext {\n  constructor(container, scope, codeLoader, codeDetails, _baseSnapshot, attributes, deltaManager, quorum, loader, raiseContainerWarning, submitFn, submitSignalFn, snapshotFn, closeFn, version, previousRuntimeState) {\n    var _this = this;\n    this.container = container;\n    this.scope = scope;\n    this.codeLoader = codeLoader;\n    this.codeDetails = codeDetails;\n    this._baseSnapshot = _baseSnapshot;\n    this.attributes = attributes;\n    this.deltaManager = deltaManager;\n    this.quorum = quorum;\n    this.loader = loader;\n    this.raiseContainerWarning = raiseContainerWarning;\n    this.submitFn = submitFn;\n    this.submitSignalFn = submitSignalFn;\n    this.snapshotFn = snapshotFn;\n    this.closeFn = closeFn;\n    this.version = version;\n    this.previousRuntimeState = previousRuntimeState;\n    this._disposed = false;\n    this.fluidModuleP = new LazyPromise( /*#__PURE__*/_asyncToGenerator(function* () {\n      if (_this.codeDetails === undefined) {\n        const fluidExport = new NullChaincode();\n        return {\n          fluidExport\n        };\n      }\n      const fluidModule = yield PerformanceEvent.timedExecAsync(_this.logger, {\n        eventName: \"CodeLoad\"\n      }, /*#__PURE__*/_asyncToGenerator(function* () {\n        return _this.codeLoader.load(_this.codeDetails);\n      }));\n      return fluidModule;\n    }));\n    this.logger = container.subLogger;\n    this.attachListener();\n  }\n  static createOrLoad(container, scope, codeLoader, codeDetails, baseSnapshot, attributes, deltaManager, quorum, loader, raiseContainerWarning, submitFn, submitSignalFn, snapshotFn, closeFn, version, previousRuntimeState) {\n    return _asyncToGenerator(function* () {\n      const context = new ContainerContext(container, scope, codeLoader, codeDetails, baseSnapshot, attributes, deltaManager, quorum, loader, raiseContainerWarning, submitFn, submitSignalFn, snapshotFn, closeFn, version, previousRuntimeState);\n      yield context.load();\n      return context;\n    })();\n  }\n  get id() {\n    return this.container.id;\n  }\n  get clientId() {\n    return this.container.clientId;\n  }\n  get clientDetails() {\n    return this.container.clientDetails;\n  }\n  get existing() {\n    return this.container.existing;\n  }\n  get branch() {\n    return this.attributes.branch;\n  }\n  get runtimeVersion() {\n    var _a;\n    return (_a = this.runtime) === null || _a === void 0 ? void 0 : _a.runtimeVersion;\n  }\n  get connected() {\n    return this.container.connected;\n  }\n  get canSummarize() {\n    return \"summarize\" in this.runtime;\n  }\n  get serviceConfiguration() {\n    return this.container.serviceConfiguration;\n  }\n  get audience() {\n    return this.container.audience;\n  }\n  get options() {\n    return this.container.options;\n  }\n  get configuration() {\n    const config = {\n      scopes: this.container.scopes\n    };\n    return config;\n  }\n  get baseSnapshot() {\n    return this._baseSnapshot;\n  }\n  get storage() {\n    return this.container.storage;\n  }\n  get runtime() {\n    if (this._runtime === undefined) {\n      throw new Error(\"Attempted to access runtime before it was defined\");\n    }\n    return this._runtime;\n  }\n  get disposed() {\n    return this._disposed;\n  }\n  attachListener() {\n    this.container.once(\"attaching\", () => {\n      var _a, _b, _c;\n      (_c = (_a = this._runtime) === null || _a === void 0 ? void 0 : (_b = _a).setAttachState) === null || _c === void 0 ? void 0 : _c.call(_b, AttachState.Attaching);\n    });\n    this.container.once(\"attached\", () => {\n      var _a, _b, _c;\n      (_c = (_a = this._runtime) === null || _a === void 0 ? void 0 : (_b = _a).setAttachState) === null || _c === void 0 ? void 0 : _c.call(_b, AttachState.Attached);\n    });\n  }\n  dispose(error) {\n    if (this._disposed) {\n      return;\n    }\n    this._disposed = true;\n    this.runtime.dispose(error);\n    this.quorum.dispose();\n    this.deltaManager.dispose();\n  }\n  snapshot(tagMessage = \"\", fullTree = false) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return _this2.runtime.snapshot(tagMessage, fullTree);\n    })();\n  }\n  getLoadedFromVersion() {\n    return this.container.loadedFromVersion;\n  }\n  /**\n   * Snapshot and close the runtime, and return its state if available\n   */\n  snapshotRuntimeState() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      return _this3.runtime.stop();\n    })();\n  }\n  get attachState() {\n    return this.container.attachState;\n  }\n  createSummary() {\n    return this.runtime.createSummary();\n  }\n  setConnectionState(connected, clientId) {\n    const runtime = this.runtime;\n    assert(connected === this.connected, \"Mismatch in connection state while setting\");\n    runtime.setConnectionState(connected, clientId);\n  }\n  process(message, local, context) {\n    this.runtime.process(message, local, context);\n  }\n  processSignal(message, local) {\n    this.runtime.processSignal(message, local);\n  }\n  request(path) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      return _this4.runtime.request(path);\n    })();\n  }\n  requestSnapshot(tagMessage) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      return _this5.snapshotFn(tagMessage);\n    })();\n  }\n  registerTasks(tasks) {\n    return;\n  }\n  reloadContext() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      return _this6.container.reloadContext();\n    })();\n  }\n  hasNullRuntime() {\n    return this.runtime instanceof NullRuntime;\n  }\n  getAbsoluteUrl(relativeUrl) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      return _this7.container.getAbsoluteUrl(relativeUrl);\n    })();\n  }\n  /**\n   * Determines if the current code details of the context\n   * satisfy the incoming constraint code details\n   */\n  satisfies(constraintCodeDetails) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      const comparers = [];\n      const maybeCompareCodeLoader = _this8.codeLoader;\n      if (maybeCompareCodeLoader.IFluidCodeDetailsComparer !== undefined) {\n        comparers.push(maybeCompareCodeLoader.IFluidCodeDetailsComparer);\n      }\n      const maybeCompareExport = (yield _this8.fluidModuleP).fluidExport;\n      if (((_a = maybeCompareExport) === null || _a === void 0 ? void 0 : _a.IFluidCodeDetailsComparer) !== undefined) {\n        comparers.push(maybeCompareExport.IFluidCodeDetailsComparer);\n      }\n      // if there are not comparers it is not possible to know\n      // if the current satisfy the incoming, so return false,\n      // as assuming they do not satisfy is safer .e.g we will\n      // reload, rather than potentially running with\n      // incompatible code\n      if (comparers.length === 0) {\n        return false;\n      }\n      for (const comparer of comparers) {\n        const satisfies = yield comparer.satisfies(_this8.codeDetails, constraintCodeDetails);\n        if (satisfies === false) {\n          return false;\n        }\n      }\n      return true;\n    })();\n  }\n  load() {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const maybeFactory = (yield _this9.fluidModuleP).fluidExport.IRuntimeFactory;\n      if (maybeFactory === undefined) {\n        throw new Error(PackageNotFactoryError);\n      }\n      _this9._runtime = yield maybeFactory.instantiateRuntime(_this9);\n    })();\n  }\n}\n//# sourceMappingURL=containerContext.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}