{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/* eslint-disable @typescript-eslint/consistent-type-assertions, eqeqeq, object-shorthand */\n/* eslint-disable no-bitwise, no-param-reassign */\nimport { Trace } from \"@fluidframework/common-utils\";\nimport * as MergeTree from \"./mergeTree\";\nexport class Stack {\n  constructor() {\n    this.items = [];\n  }\n  push(val) {\n    this.items.push(val);\n  }\n  empty() {\n    return this.items.length === 0;\n  }\n  top() {\n    return this.items[this.items.length - 1];\n  }\n  pop() {\n    return this.items.pop();\n  }\n}\nexport function ListRemoveEntry(entry) {\n  if (entry === undefined) {\n    return undefined;\n  } else if (entry.isHead) {\n    return undefined;\n  } else {\n    entry.next.prev = entry.prev;\n    entry.prev.next = entry.next;\n  }\n  return entry;\n}\nexport function ListMakeEntry(data) {\n  const entry = new List(false, data);\n  entry.prev = entry;\n  entry.next = entry;\n  return entry;\n}\nexport function ListMakeHead() {\n  const entry = new List(true, undefined);\n  entry.prev = entry;\n  entry.next = entry;\n  return entry;\n}\nexport class List {\n  constructor(isHead, data) {\n    this.isHead = isHead;\n    this.data = data;\n  }\n  clear() {\n    if (this.isHead) {\n      this.prev = this;\n      this.next = this;\n    }\n  }\n  add(data) {\n    const entry = ListMakeEntry(data);\n    this.prev.next = entry;\n    entry.next = this;\n    entry.prev = this.prev;\n    this.prev = entry;\n    return entry;\n  }\n  dequeue() {\n    if (!this.empty()) {\n      const removedEntry = ListRemoveEntry(this.next);\n      return removedEntry.data;\n    }\n  }\n  enqueue(data) {\n    return this.add(data);\n  }\n  walk(fn) {\n    for (let entry = this.next; !entry.isHead; entry = entry.next) {\n      fn(entry.data, entry);\n    }\n  }\n  some(fn, rev) {\n    const rtn = [];\n    const start = rev ? this.prev : this.next;\n    for (let entry = start; !entry.isHead; entry = rev ? entry.prev : entry.next) {\n      if (fn(entry.data, entry)) {\n        if (rev) {\n          // preserve list order when in reverse\n          rtn.unshift(entry.data);\n        } else {\n          rtn.push(entry.data);\n        }\n      }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return rtn;\n  }\n  count() {\n    let entry;\n    let i;\n    entry = this.next;\n    for (i = 0; !entry.isHead; i++) {\n      entry = entry.next;\n    }\n    return i;\n  }\n  first() {\n    if (!this.empty()) {\n      return this.next.data;\n    }\n  }\n  last() {\n    if (!this.empty()) {\n      return this.prev.data;\n    }\n  }\n  empty() {\n    return this.next === this;\n  }\n  pushEntry(entry) {\n    entry.isHead = false;\n    entry.next = this.next;\n    entry.prev = this;\n    this.next = entry;\n    entry.next.prev = entry;\n  }\n  push(data) {\n    const entry = ListMakeEntry(data);\n    entry.data = data;\n    entry.isHead = false;\n    entry.next = this.next;\n    entry.prev = this;\n    this.next = entry;\n    entry.next.prev = entry;\n  }\n  popEntry(head) {\n    if (this.next.isHead) {\n      return undefined;\n    } else {\n      return ListRemoveEntry(this.next);\n    }\n  }\n  insertEntry(entry) {\n    entry.isHead = false;\n    this.prev.next = entry;\n    entry.next = this;\n    entry.prev = this.prev;\n    this.prev = entry;\n    return entry;\n  }\n  insertAfter(data) {\n    const entry = ListMakeEntry(data);\n    entry.next = this.next;\n    entry.prev = this;\n    this.next = entry;\n    entry.next.prev = entry;\n    return entry;\n  }\n  insertBefore(data) {\n    const entry = ListMakeEntry(data);\n    return this.insertEntryBefore(entry);\n  }\n  insertEntryBefore(entry) {\n    this.prev.next = entry;\n    entry.next = this;\n    entry.prev = this.prev;\n    this.prev = entry;\n    return entry;\n  }\n}\nexport const numberComparer = {\n  min: Number.MIN_VALUE,\n  compare: (a, b) => a - b\n};\nexport class Heap {\n  constructor(a, comp) {\n    this.comp = comp;\n    this.L = [comp.min];\n    for (let i = 0, len = a.length; i < len; i++) {\n      this.add(a[i]);\n    }\n  }\n  count() {\n    return this.L.length - 1;\n  }\n  peek() {\n    return this.L[1];\n  }\n  get() {\n    const x = this.L[1];\n    this.L[1] = this.L[this.count()];\n    this.L.pop();\n    this.fixdown(1);\n    return x;\n  }\n  add(x) {\n    this.L.push(x);\n    this.fixup(this.count());\n  }\n  fixup(k) {\n    while (k > 1 && this.comp.compare(this.L[k >> 1], this.L[k]) > 0) {\n      const tmp = this.L[k >> 1];\n      this.L[k >> 1] = this.L[k];\n      this.L[k] = tmp;\n      k = k >> 1;\n    }\n  }\n  fixdown(k) {\n    while (k << 1 <= this.count()) {\n      let j = k << 1;\n      if (j < this.count() && this.comp.compare(this.L[j], this.L[j + 1]) > 0) {\n        j++;\n      }\n      if (this.comp.compare(this.L[k], this.L[j]) <= 0) {\n        break;\n      }\n      const tmp = this.L[k];\n      this.L[k] = this.L[j];\n      this.L[j] = tmp;\n      k = j;\n    }\n  }\n}\n// For testing\nexport function LinearDictionary(compareKeys) {\n  const props = [];\n  const compareProps = (a, b) => compareKeys(a.key, b.key);\n  function diag() {\n    console.log(`size is ${props.length}`);\n  }\n  function mapRange(action, accum, start, end) {\n    if (start === undefined) {\n      start = min().key;\n    }\n    if (end === undefined) {\n      end = max().key;\n    }\n    for (let i = 0, len = props.length; i < len; i++) {\n      if (compareKeys(start, props[i].key) <= 0) {\n        const ecmp = compareKeys(end, props[i].key);\n        if (ecmp < 0) {\n          break;\n        }\n        if (!action(props[i], accum)) {\n          break;\n        }\n      }\n    }\n  }\n  function map(action, accum) {\n    mapRange(action, accum);\n  }\n  function min() {\n    if (props.length > 0) {\n      return props[0];\n    }\n  }\n  function max() {\n    if (props.length > 0) {\n      return props[props.length - 1];\n    }\n  }\n  function get(key) {\n    for (let i = 0, len = props.length; i < len; i++) {\n      if (props[i].key == key) {\n        return props[i];\n      }\n    }\n  }\n  function put(key, data) {\n    if (key !== undefined) {\n      if (data === undefined) {\n        remove(key);\n      } else {\n        props.push({\n          key,\n          data\n        });\n        props.sort(compareProps); // Go to insertion sort if too slow\n      }\n    }\n  }\n\n  function remove(key) {\n    if (key !== undefined) {\n      for (let i = 0, len = props.length; i < len; i++) {\n        if (props[i].key == key) {\n          props[i] = props[len - 1];\n          props.length--;\n          props.sort(compareProps);\n          break;\n        }\n      }\n    }\n  }\n  return {\n    min: min,\n    max: max,\n    map: map,\n    mapRange: mapRange,\n    remove: remove,\n    get: get,\n    put: put,\n    diag: diag\n  };\n}\nexport class RedBlackTree {\n  constructor(compareKeys, aug) {\n    this.compareKeys = compareKeys;\n    this.aug = aug;\n  }\n  makeNode(key, data, color, size) {\n    const node = {\n      key,\n      data,\n      color,\n      size\n    };\n    if (this.aug && this.aug.init) {\n      this.aug.init(node);\n    }\n    return node;\n  }\n  isRed(node) {\n    return node && node.color == 0 /* RED */;\n  }\n\n  nodeSize(node) {\n    return node ? node.size : 0;\n  }\n  size() {\n    return this.nodeSize(this.root);\n  }\n  isEmpty() {\n    return !this.root;\n  }\n  get(key) {\n    if (key !== undefined) {\n      return this.nodeGet(this.root, key);\n    }\n  }\n  nodeGet(node, key) {\n    while (node) {\n      const cmp = this.compareKeys(key, node.key);\n      if (cmp < 0) {\n        node = node.left;\n      } else if (cmp > 0) {\n        node = node.right;\n      } else {\n        return node;\n      }\n    }\n  }\n  contains(key) {\n    return this.get(key);\n  }\n  gather(key, matcher) {\n    const results = [];\n    if (key !== undefined) {\n      this.nodeGather(this.root, results, key, matcher);\n    }\n    return results;\n  }\n  nodeGather(node, results, key, matcher) {\n    if (node) {\n      if (matcher.continueSubtree(node.left, key)) {\n        this.nodeGather(node.left, results, key, matcher);\n      }\n      if (matcher.matchNode(node, key)) {\n        results.push(node);\n      }\n      if (matcher.continueSubtree(node.right, key)) {\n        this.nodeGather(node.right, results, key, matcher);\n      }\n    }\n  }\n  put(key, data, conflict) {\n    if (key !== undefined) {\n      if (data === undefined) {\n        this.remove(key);\n      } else {\n        this.root = this.nodePut(this.root, key, data, conflict);\n        this.root.color = 1 /* BLACK */;\n      }\n    }\n  }\n\n  nodePut(node, key, data, conflict) {\n    if (!node) {\n      return this.makeNode(key, data, 0 /* RED */, 1);\n    } else {\n      const cmp = this.compareKeys(key, node.key);\n      if (cmp < 0) {\n        node.left = this.nodePut(node.left, key, data, conflict);\n      } else if (cmp > 0) {\n        node.right = this.nodePut(node.right, key, data, conflict);\n      } else {\n        if (conflict) {\n          const kd = conflict(key, node.key, data, node.data);\n          if (kd.key) {\n            node.key = kd.key;\n          }\n          if (kd.data) {\n            node.data = kd.data;\n          } else {\n            node.data = data;\n          }\n        } else {\n          node.data = data;\n        }\n      }\n      if (this.isRed(node.right) && !this.isRed(node.left)) {\n        node = this.rotateLeft(node);\n      }\n      if (this.isRed(node.left) && this.isRed(node.left.left)) {\n        node = this.rotateRight(node);\n      }\n      if (this.isRed(node.left) && this.isRed(node.right)) {\n        this.flipColors(node);\n      }\n      node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;\n      if (this.aug) {\n        this.updateLocal(node);\n      }\n      return node;\n    }\n  }\n  updateLocal(node) {\n    if (this.aug) {\n      if (this.isRed(node.left)) {\n        this.aug.update(node.left);\n      }\n      if (this.isRed(node.right)) {\n        this.aug.update(node.right);\n      }\n      this.aug.update(node);\n    }\n  }\n  removeMin() {\n    if (!this.isEmpty()) {\n      if (!this.isRed(this.root.left) && !this.isRed(this.root.right)) {\n        this.root.color = 0 /* RED */;\n      }\n\n      this.root = this.nodeRemoveMin(this.root);\n      if (!this.isEmpty()) {\n        this.root.color = 1 /* BLACK */;\n      }\n    }\n    // TODO: error on empty\n  }\n\n  nodeRemoveMin(node) {\n    if (node.left) {\n      if (!this.isRed(node.left) && !this.isRed(node.left.left)) {\n        node = this.moveRedLeft(node);\n      }\n      node.left = this.nodeRemoveMin(node.left);\n      return this.balance(node);\n    }\n  }\n  removeMax() {\n    if (this.isEmpty()) {\n      if (!this.isRed(this.root.left) && !this.isRed(this.root.right)) {\n        this.root.color = 0 /* RED */;\n      }\n\n      this.root = this.nodeRemoveMax(this.root);\n      if (!this.isEmpty()) {\n        this.root.color = 1 /* BLACK */;\n      }\n    }\n    // TODO: error on empty\n  }\n\n  nodeRemoveMax(node) {\n    if (this.isRed(node.left)) {\n      node = this.rotateRight(node);\n    }\n    if (!node.right) {\n      return undefined;\n    }\n    if (!this.isRed(node.right) && !this.isRed(node.right.left)) {\n      node = this.moveRedRight(node);\n    }\n    node.right = this.nodeRemoveMax(node.right);\n    return this.balance(node);\n  }\n  remove(key) {\n    if (key !== undefined) {\n      if (!this.contains(key)) {\n        return;\n      }\n      if (!this.isRed(this.root.left) && !this.isRed(this.root.right)) {\n        this.root.color = 0 /* RED */;\n      }\n\n      this.root = this.nodeRemove(this.root, key);\n    }\n    // TODO: error on undefined key\n  }\n\n  nodeRemove(node, key) {\n    if (this.compareKeys(key, node.key) < 0) {\n      if (!this.isRed(node.left) && !this.isRed(node.left.left)) {\n        node = this.moveRedLeft(node);\n      }\n      node.left = this.nodeRemove(node.left, key);\n    } else {\n      if (this.isRed(node.left)) {\n        node = this.rotateRight(node);\n      }\n      if (this.compareKeys(key, node.key) == 0 && !node.right) {\n        return undefined;\n      }\n      if (!this.isRed(node.right) && !this.isRed(node.right.left)) {\n        node = this.moveRedRight(node);\n      }\n      if (this.compareKeys(key, node.key) == 0) {\n        const subtreeMin = this.nodeMin(node.right);\n        node.key = subtreeMin.key;\n        node.data = subtreeMin.data;\n        node.right = this.nodeRemoveMin(node.right);\n      } else {\n        node.right = this.nodeRemove(node.right, key);\n      }\n    }\n    return this.balance(node);\n  }\n  height() {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return this.nodeHeight(this.root);\n  }\n  nodeHeight(node) {\n    if (node === undefined) {\n      return -1;\n    } else {\n      return 1 + Math.max(this.nodeHeight(node.left), this.nodeHeight(node.right));\n    }\n  }\n  floor(key) {\n    if (!this.isEmpty()) {\n      return this.nodeFloor(this.root, key);\n    }\n  }\n  nodeFloor(node, key) {\n    if (node) {\n      const cmp = this.compareKeys(key, node.key);\n      if (cmp == 0) {\n        return node;\n      } else if (cmp < 0) {\n        return this.nodeFloor(node.left, key);\n      } else {\n        const rightFloor = this.nodeFloor(node.right, key);\n        if (rightFloor) {\n          return rightFloor;\n        } else {\n          return node;\n        }\n      }\n    }\n  }\n  ceil(key) {\n    if (!this.isEmpty()) {\n      return this.nodeCeil(this.root, key);\n    }\n  }\n  nodeCeil(node, key) {\n    if (node) {\n      const cmp = this.compareKeys(key, node.key);\n      if (cmp == 0) {\n        return node;\n      } else if (cmp > 0) {\n        return this.nodeCeil(node.right, key);\n      } else {\n        const leftCeil = this.nodeCeil(node.left, key);\n        if (leftCeil) {\n          return leftCeil;\n        } else {\n          return node;\n        }\n      }\n    }\n  }\n  min() {\n    if (!this.isEmpty()) {\n      return this.nodeMin(this.root);\n    }\n    // TODO: error on empty\n  }\n\n  nodeMin(node) {\n    if (!node.left) {\n      return node;\n    } else {\n      return this.nodeMin(node.left);\n    }\n  }\n  max() {\n    if (!this.isEmpty()) {\n      return this.nodeMax(this.root);\n    }\n    // TODO: error on empty\n  }\n\n  nodeMax(node) {\n    if (!node.right) {\n      return node;\n    } else {\n      return this.nodeMax(node.right);\n    }\n  }\n  rotateRight(node) {\n    const leftChild = node.left;\n    node.left = leftChild.right;\n    leftChild.right = node;\n    leftChild.color = leftChild.right.color;\n    leftChild.right.color = 0 /* RED */;\n    leftChild.size = node.size;\n    node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;\n    if (this.aug) {\n      this.updateLocal(node);\n      this.updateLocal(leftChild);\n    }\n    return leftChild;\n  }\n  rotateLeft(node) {\n    const rightChild = node.right;\n    node.right = rightChild.left;\n    rightChild.left = node;\n    rightChild.color = rightChild.left.color;\n    rightChild.left.color = 0 /* RED */;\n    rightChild.size = node.size;\n    node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;\n    if (this.aug) {\n      this.updateLocal(node);\n      this.updateLocal(rightChild);\n    }\n    return rightChild;\n  }\n  oppositeColor(c) {\n    return c == 1 /* BLACK */ ? 0 /* RED */ : 1 /* BLACK */;\n  }\n\n  flipColors(node) {\n    node.color = this.oppositeColor(node.color);\n    node.left.color = this.oppositeColor(node.left.color);\n    node.right.color = this.oppositeColor(node.right.color);\n  }\n  moveRedLeft(node) {\n    this.flipColors(node);\n    if (this.isRed(node.right.left)) {\n      node.right = this.rotateRight(node.right);\n      node = this.rotateLeft(node);\n      this.flipColors(node);\n    }\n    return node;\n  }\n  moveRedRight(node) {\n    this.flipColors(node);\n    if (this.isRed(node.left.left)) {\n      node = this.rotateRight(node);\n      this.flipColors(node);\n    }\n    return node;\n  }\n  balance(node) {\n    if (this.isRed(node.right)) {\n      node = this.rotateLeft(node);\n    }\n    if (this.isRed(node.left) && this.isRed(node.left.left)) {\n      node = this.rotateRight(node);\n    }\n    if (this.isRed(node.left) && this.isRed(node.right)) {\n      this.flipColors(node);\n    }\n    node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;\n    if (this.aug) {\n      this.aug.update(node);\n    }\n    return node;\n  }\n  mapRange(action, accum, start, end) {\n    this.nodeMap(this.root, action, start, end);\n  }\n  map(action, accum) {\n    // TODO: optimize to avoid comparisons\n    this.nodeMap(this.root, action, accum);\n  }\n  keys() {\n    const keyList = [];\n    const actions = {\n      showStructure: true,\n      infix: node => {\n        keyList.push(node.key);\n        return true;\n      }\n    };\n    this.walk(actions);\n    return keyList;\n  }\n  /**\n   * Depth-first traversal with custom action; if action returns\n   * false, traversal is halted.\n   * @param action - action to apply to each node\n   */\n  walk(actions) {\n    this.nodeWalk(this.root, actions);\n  }\n  nodeWalk(node, actions) {\n    let go = true;\n    if (node) {\n      if (actions.pre) {\n        if (actions.showStructure || node.color === 1 /* BLACK */) {\n          go = actions.pre(node);\n        }\n      }\n      if (node.left) {\n        go = this.nodeWalk(node.left, actions);\n      }\n      if (go && actions.infix) {\n        if (actions.showStructure || node.color === 1 /* BLACK */) {\n          go = actions.infix(node);\n        }\n      }\n      if (go) {\n        go = this.nodeWalk(node.right, actions);\n      }\n      if (go && actions.post) {\n        if (actions.showStructure || node.color === 1 /* BLACK */) {\n          go = actions.post(node);\n        }\n      }\n    }\n    return go;\n  }\n  nodeMap(node, action, accum, start, end) {\n    if (!node) {\n      return true;\n    }\n    if (start === undefined) {\n      start = this.nodeMin(node).key;\n    }\n    if (end === undefined) {\n      end = this.nodeMax(node).key;\n    }\n    const cmpStart = this.compareKeys(start, node.key);\n    const cmpEnd = this.compareKeys(end, node.key);\n    let go = true;\n    if (cmpStart < 0) {\n      go = this.nodeMap(node.left, action, accum, start, end);\n    }\n    if (go && cmpStart <= 0 && cmpEnd >= 0) {\n      // REVIEW: test for black node here\n      go = action(node, accum);\n    }\n    if (go && cmpEnd > 0) {\n      go = this.nodeMap(node.right, action, accum, start, end);\n    }\n    return go;\n  }\n  diag() {\n    console.log(`Height is ${this.height()}`);\n  }\n}\n/**\n * Union of two ranges; assumes for both ranges start \\<= end.\n * @param a - A range\n * @param b - A range\n */\nexport function integerRangeUnion(a, b) {\n  return {\n    start: Math.min(a.start, b.start),\n    end: Math.max(a.end, b.end)\n  };\n}\nexport function integerRangeOverlaps(a, b) {\n  return a.start < b.end && a.end > b.start;\n}\nexport function integerRangeComparer(a, b) {\n  if (a.start === b.start) {\n    return a.end - b.end;\n  } else {\n    return a.start - b.start;\n  }\n}\nexport const integerRangeCopy = r => ({\n  start: r.start,\n  end: r.end\n});\nexport const integerRangeToString = range => `[${range.start},${range.end})`;\n// TODO: handle duplicate keys\nexport class IntegerRangeTree {\n  constructor() {\n    this.ranges = new RedBlackTree(integerRangeComparer, this);\n    this.diag = false;\n  }\n  remove(r) {\n    this.ranges.remove(r);\n  }\n  put(r) {\n    this.ranges.put(r, {\n      minmax: integerRangeCopy(r)\n    });\n  }\n  toString() {\n    return this.nodeToString(this.ranges.root);\n  }\n  nodeToString(node) {\n    let buf = \"\";\n    let indentAmt = 0;\n    const actions = {\n      pre: n => {\n        let red = \"\";\n        if (n.color === 0 /* RED */) {\n          red = \"R \";\n        }\n        buf += MergeTree.internedSpaces(indentAmt);\n        buf += `${red}key: ${integerRangeToString(n.key)} minmax: ${integerRangeToString(n.data.minmax)}\\n`;\n        indentAmt += 2;\n        return true;\n      },\n      post: n => {\n        indentAmt -= 2;\n        return true;\n      },\n      showStructure: true\n    };\n    this.ranges.nodeWalk(node, actions);\n    return buf;\n  }\n  matchPos(pos) {\n    return this.match({\n      start: pos,\n      end: pos + 1\n    });\n  }\n  match(r) {\n    return this.ranges.gather(r, this);\n  }\n  matchNode(node, key) {\n    return node && integerRangeOverlaps(node.key, key);\n  }\n  continueSubtree(node, key) {\n    const cont = node && integerRangeOverlaps(node.data.minmax, key);\n    if (this.diag && !cont) {\n      if (node) {\n        console.log(`skipping subtree of size ${node.size} key ${integerRangeToString(key)}`);\n        console.log(this.nodeToString(node));\n      }\n    }\n    return cont;\n  }\n  update(node) {\n    if (node.left && node.right) {\n      node.data.minmax = integerRangeUnion(node.key, integerRangeUnion(node.left.data.minmax, node.right.data.minmax));\n    } else {\n      if (node.left) {\n        node.data.minmax = integerRangeUnion(node.key, node.left.data.minmax);\n      } else if (node.right) {\n        node.data.minmax = integerRangeUnion(node.key, node.right.data.minmax);\n      } else {\n        node.data.minmax = integerRangeCopy(node.key);\n      }\n    }\n  }\n}\nexport const intervalComparer = (a, b) => a.compare(b);\nexport class IntervalTree {\n  constructor() {\n    this.intervals = new RedBlackTree(intervalComparer, this);\n    this.diag = false;\n    this.timePut = false;\n    this.putTime = 0;\n    this.putCount = 0;\n  }\n  printTiming() {\n    console.log(`put total = ${this.putTime} avg=${(this.putTime / this.putCount).toFixed(2)}`);\n  }\n  remove(x) {\n    this.intervals.remove(x);\n  }\n  put(x, conflict) {\n    let rbConflict;\n    if (conflict) {\n      rbConflict = (key, currentKey) => {\n        const ival = conflict(key, currentKey);\n        return {\n          key: ival\n        };\n      };\n    }\n    if (this.timePut) {\n      const trace = Trace.start();\n      this.intervals.put(x, {\n        minmax: x.clone()\n      }, rbConflict);\n      this.putTime += trace.trace().duration * 1000;\n      this.putCount++;\n    } else {\n      this.intervals.put(x, {\n        minmax: x.clone()\n      }, rbConflict);\n    }\n  }\n  map(fn) {\n    const actions = {\n      infix: node => {\n        fn(node.key);\n        return true;\n      },\n      showStructure: true\n    };\n    this.intervals.walk(actions);\n  }\n  // TODO: toString()\n  match(x) {\n    return this.intervals.gather(x, this);\n  }\n  matchNode(node, key) {\n    return node && node.key.overlaps(key);\n  }\n  continueSubtree(node, key) {\n    const cont = node && node.data.minmax.overlaps(key);\n    if (this.diag && !cont) {\n      if (node) {\n        console.log(`skipping subtree of size ${node.size} key ${key.toString()}`);\n        // console.log(this.nodeToString(node));\n      }\n    }\n\n    return cont;\n  }\n  update(node) {\n    if (node.left && node.right) {\n      node.data.minmax = node.key.union(node.left.data.minmax.union(node.right.data.minmax));\n    } else {\n      if (node.left) {\n        node.data.minmax = node.key.union(node.left.data.minmax);\n      } else if (node.right) {\n        node.data.minmax = node.key.union(node.right.data.minmax);\n      } else {\n        node.data.minmax = node.key.clone();\n      }\n    }\n  }\n}\nexport class TST {\n  constructor() {\n    this.n = 0;\n  }\n  size() {\n    return this.n;\n  }\n  contains(key) {\n    return this.get(key);\n  }\n  get(key) {\n    const x = this.nodeGet(this.root, key, 0);\n    if (x === undefined) {\n      return undefined;\n    }\n    return x.val;\n  }\n  nodeGet(x, key, d) {\n    if (x === undefined) {\n      return undefined;\n    }\n    const c = key.charAt(d);\n    if (c < x.c) {\n      return this.nodeGet(x.left, key, d);\n    } else if (c > x.c) {\n      return this.nodeGet(x.right, key, d);\n    } else if (d < key.length - 1) {\n      return this.nodeGet(x.mid, key, d + 1);\n    } else {\n      return x;\n    }\n  }\n  put(key, val) {\n    if (!this.contains(key)) {\n      this.n++;\n    }\n    this.root = this.nodePut(this.root, key, val, 0);\n    // console.log(`put ${key}`);\n  }\n\n  nodePut(x, key, val, d) {\n    const c = key.charAt(d);\n    if (x === undefined) {\n      x = {\n        c\n      };\n    }\n    if (c < x.c) {\n      x.left = this.nodePut(x.left, key, val, d);\n    } else if (c > x.c) {\n      x.right = this.nodePut(x.right, key, val, d);\n    } else if (d < key.length - 1) {\n      x.mid = this.nodePut(x.mid, key, val, d + 1);\n    } else {\n      x.val = val;\n    }\n    return x;\n  }\n  neighbors(text, distance = 2) {\n    let q = [];\n    this.nodeProximity(this.root, {\n      text: \"\"\n    }, 0, text, distance, q);\n    q = q.filter(value => value.text.length > 0);\n    return q;\n  }\n  keysWithPrefix(text) {\n    const q = [];\n    const x = this.nodeGet(this.root, text, 0);\n    if (x === undefined) {\n      return q;\n    }\n    if (x.val !== undefined) {\n      q.push(text);\n    }\n    this.collect(x.mid, {\n      text\n    }, q);\n    return q;\n  }\n  collect(x, prefix, q) {\n    if (x === undefined) {\n      return;\n    }\n    this.collect(x.left, prefix, q);\n    if (x.val !== undefined) {\n      q.push(prefix.text + x.c);\n    }\n    this.collect(x.mid, {\n      text: prefix.text + x.c\n    }, q);\n    this.collect(x.right, prefix, q);\n  }\n  mapNode(x, prefix, fn) {\n    if (x === undefined) {\n      return;\n    }\n    const key = prefix.text + x.c;\n    this.mapNode(x.left, prefix, fn);\n    if (x.val) {\n      fn(key, x.val);\n    }\n    this.mapNode(x.mid, {\n      text: key\n    }, fn);\n    this.mapNode(x.right, prefix, fn);\n  }\n  map(fn) {\n    this.mapNode(this.root, {\n      text: \"\"\n    }, fn);\n  }\n  pairsWithPrefix(text) {\n    const q = [];\n    const x = this.nodeGet(this.root, text, 0);\n    if (x === undefined) {\n      return q;\n    }\n    if (x.val !== undefined) {\n      q.push({\n        key: text,\n        val: x.val\n      });\n    }\n    this.collectPairs(x.mid, {\n      text\n    }, q);\n    return q;\n  }\n  collectPairs(x, prefix, q) {\n    if (x === undefined) {\n      return;\n    }\n    this.collectPairs(x.left, prefix, q);\n    if (x.val !== undefined) {\n      q.push({\n        key: prefix.text + x.c,\n        val: x.val\n      });\n    }\n    this.collectPairs(x.mid, {\n      text: prefix.text + x.c\n    }, q);\n    this.collectPairs(x.right, prefix, q);\n  }\n  patternCollect(x, prefix, d, pattern, q) {\n    if (x === undefined) {\n      return;\n    }\n    const c = pattern.charAt(d);\n    if (c === \".\" || c < x.c) {\n      this.patternCollect(x.left, prefix, d, pattern, q);\n    } else if (c === \".\" || c === x.c) {\n      if (d === pattern.length - 1 && x.val !== undefined) {\n        q.push(prefix.text + x.c);\n      } else if (d < pattern.length - 1) {\n        this.patternCollect(x.mid, {\n          text: prefix.text + x.c\n        }, d + 1, pattern, q);\n      }\n    }\n    if (c === \".\" || c > x.c) {\n      this.patternCollect(x.right, prefix, d, pattern, q);\n    }\n  }\n  nodeProximity(x, prefix, d, pattern, distance, q) {\n    if (x === undefined || distance < 0) {\n      return;\n    }\n    const c = pattern.charAt(d);\n    if (distance > 0 || c < x.c) {\n      this.nodeProximity(x.left, prefix, d, pattern, distance, q);\n    }\n    if (x.val !== undefined) {\n      const remD = distance - (pattern.length - d);\n      if (remD >= 0) {\n        let invD = distance;\n        if (c !== x.c) {\n          invD--;\n        }\n        q.push({\n          text: prefix.text + x.c,\n          val: x.val,\n          invDistance: invD\n        });\n      }\n    }\n    const recurD = d < pattern.length - 1 ? d + 1 : d;\n    if (c === x.c) {\n      this.nodeProximity(x.mid, {\n        text: prefix.text + x.c\n      }, recurD, pattern, distance, q);\n    } else {\n      this.nodeProximity(x.mid, {\n        text: prefix.text + x.c\n      }, recurD, pattern, distance - 1, q);\n    }\n    if (distance > 0 || c > x.c) {\n      this.nodeProximity(x.right, prefix, d, pattern, distance, q);\n    }\n  }\n  match(pattern) {\n    const q = [];\n    this.patternCollect(this.root, {\n      text: \"\"\n    }, 0, pattern, q);\n    return q;\n  }\n}\n//# sourceMappingURL=collections.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}