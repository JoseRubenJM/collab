{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { EventEmitter } from \"events\";\nimport { Deferred, PromiseTimer, Timer } from \"@fluidframework/common-utils\";\nimport { ChildLogger, LoggingError, PerformanceEvent } from \"@fluidframework/telemetry-utils\";\nimport { CreateContainerError } from \"@fluidframework/container-utils\";\nimport { MessageType } from \"@fluidframework/protocol-definitions\";\nimport { RunWhileConnectedCoordinator } from \"./runWhileConnectedCoordinator\";\nimport { SummaryCollection } from \"./summaryCollection\";\nimport { SummarizerHandle } from \"./summarizerHandle\";\n// Send some telemetry if generate summary takes too long\nconst maxSummarizeTimeoutTime = 20000; // 20 sec\nconst maxSummarizeTimeoutCount = 5; // Double and resend 5 times\nconst maxSummarizeAckWaitTime = 120000; // 2 minutes\nconst minOpsForLastSummary = 50;\nexport const ISummarizer = \"ISummarizer\";\nconst summarizingError = \"summarizingError\";\nexport class SummarizingWarning extends LoggingError {\n  constructor(errorMessage, logged = false) {\n    super(errorMessage);\n    this.logged = logged;\n    this.errorType = summarizingError;\n    this.canRetry = true;\n  }\n}\nexport const createSummarizingWarning = (details, logged) => new SummarizingWarning(details, logged);\nconst checkNotTimeout = something => {\n  if (something === undefined) {\n    return false;\n  }\n  return something.timerResult === undefined;\n};\n/**\n * This class contains the heuristics for when to summarize.\n */\nclass SummarizerHeuristics {\n  constructor(configuration, trySummarize,\n  /**\n   * Last received op sequence number\n   */\n  lastOpSeqNumber, firstAck) {\n    this.configuration = configuration;\n    this.trySummarize = trySummarize;\n    this.lastOpSeqNumber = lastOpSeqNumber;\n    this._lastAttempted = firstAck;\n    this._lastAcked = firstAck;\n    this.idleTimer = new Timer(this.configuration.idleTime, () => this.trySummarize(\"idle\"));\n  }\n  /**\n   * Last sent summary attempt\n   */\n  get lastAttempted() {\n    return this._lastAttempted;\n  }\n  /**\n   * Last acked summary attempt\n   */\n  get lastAcked() {\n    return this._lastAcked;\n  }\n  /**\n   * Sets the last attempted summary and last acked summary.\n   * @param lastSummary - last acked summary\n   */\n  initialize(lastSummary) {\n    this._lastAttempted = lastSummary;\n    this._lastAcked = lastSummary;\n  }\n  /**\n   * Records a summary attempt. If the attempt was successfully sent,\n   * provide the reference sequence number, otherwise it will be set\n   * to the last seen op sequence number.\n   * @param refSequenceNumber - reference sequence number of sent summary\n   */\n  recordAttempt(refSequenceNumber) {\n    this._lastAttempted = {\n      refSequenceNumber: refSequenceNumber !== null && refSequenceNumber !== void 0 ? refSequenceNumber : this.lastOpSeqNumber,\n      summaryTime: Date.now()\n    };\n  }\n  /**\n   * Mark the last sent summary attempt as acked.\n   */\n  ackLastSent() {\n    this._lastAcked = this.lastAttempted;\n  }\n  /**\n   * Runs the heuristic to determine if it should try to summarize.\n   */\n  run() {\n    this.idleTimer.clear();\n    const timeSinceLastSummary = Date.now() - this.lastAcked.summaryTime;\n    const opCountSinceLastSummary = this.lastOpSeqNumber - this.lastAcked.refSequenceNumber;\n    if (timeSinceLastSummary > this.configuration.maxTime) {\n      this.trySummarize(\"maxTime\");\n    } else if (opCountSinceLastSummary > this.configuration.maxOps) {\n      this.trySummarize(\"maxOps\");\n    } else {\n      this.idleTimer.restart();\n    }\n  }\n  /**\n   * Disposes of resources.\n   */\n  dispose() {\n    this.idleTimer.clear();\n  }\n}\n/**\n * An instance of RunningSummarizer manages the heuristics for summarizing.\n * Until disposed, the instance of RunningSummarizer can assume that it is\n * in a state of running, meaning it is connected and initialized.  It keeps\n * track of summaries that it is generating as they are broadcast and acked/nacked.\n */\nexport class RunningSummarizer {\n  constructor(clientId, onBehalfOfClientId, baseLogger, summaryWatcher, configuration, internalsProvider, lastOpSeqNumber, firstAck, immediateSummary = false, raiseSummarizingError) {\n    this.clientId = clientId;\n    this.onBehalfOfClientId = onBehalfOfClientId;\n    this.summaryWatcher = summaryWatcher;\n    this.configuration = configuration;\n    this.internalsProvider = internalsProvider;\n    this.immediateSummary = immediateSummary;\n    this.raiseSummarizingError = raiseSummarizingError;\n    this.stopping = false;\n    this._disposed = false;\n    this.summarizeCount = 0;\n    this.tryWhileSummarizing = false;\n    /**\n     * RunningSummarizer's logger includes the sequenced index of the current summary on each event.\n     * If some other Summarizer code wants that event on their logs they can get it here,\n     * but only if they're logging about that same summary.\n     * @param summaryOpRefSeq - RefSeq number of the summary op, to ensure the log correlation will be correct\n     */\n    this.tryGetCorrelatedLogger = summaryOpRefSeq => this.heuristics.lastAttempted.refSequenceNumber === summaryOpRefSeq ? this.logger : undefined;\n    this.logger = new ChildLogger(baseLogger, \"Running\", undefined, {\n      summaryGenTag: () => this.summarizeCount\n    });\n    this.heuristics = new SummarizerHeuristics(configuration, reason => this.trySummarize(reason), lastOpSeqNumber, firstAck);\n    this.summarizeTimer = new Timer(maxSummarizeTimeoutTime, () => this.summarizeTimerHandler(maxSummarizeTimeoutTime, 1));\n    // Cap the maximum amount of time client will wait for a summarize op ack to maxSummarizeAckWaitTime\n    const maxAckWaitTime = Math.min(this.configuration.maxAckWaitTime, maxSummarizeAckWaitTime);\n    this.pendingAckTimer = new PromiseTimer(maxAckWaitTime, () => {\n      this.raiseSummarizingError(\"SummaryAckWaitTimeout\");\n      // Note: summaryGenTag (from ChildLogger definition) may be 0,\n      // since this code path is hit when RunningSummarizer first starts up,\n      // before this instance has kicked off a new summarize run.\n      this.logger.sendErrorEvent({\n        eventName: \"SummaryAckWaitTimeout\",\n        maxAckWaitTime,\n        refSequenceNumber: this.heuristics.lastAttempted.refSequenceNumber,\n        summarySequenceNumber: this.heuristics.lastAttempted.summarySequenceNumber,\n        timePending: Date.now() - this.heuristics.lastAttempted.summaryTime\n      });\n    });\n  }\n  static start(clientId, onBehalfOfClientId, logger, summaryWatcher, configuration, internalsProvider, lastOpSeqNumber, firstAck, immediateSummary, raiseSummarizingError) {\n    return _asyncToGenerator(function* () {\n      const summarizer = new RunningSummarizer(clientId, onBehalfOfClientId, logger, summaryWatcher, configuration, internalsProvider, lastOpSeqNumber, firstAck, immediateSummary, raiseSummarizingError);\n      yield summarizer.waitStart();\n      // Run the heuristics after starting\n      if (immediateSummary) {\n        summarizer.trySummarize(\"immediate\");\n      } else {\n        summarizer.heuristics.run();\n      }\n      return summarizer;\n    })();\n  }\n  get disposed() {\n    return this._disposed;\n  }\n  dispose() {\n    this.summaryWatcher.dispose();\n    this.heuristics.dispose();\n    this.summarizeTimer.clear();\n    this.pendingAckTimer.clear();\n    this._disposed = true;\n  }\n  handleSystemOp(op) {\n    switch (op.type) {\n      case MessageType.ClientLeave:\n        {\n          const leavingClientId = JSON.parse(op.data);\n          if (leavingClientId === this.clientId || leavingClientId === this.onBehalfOfClientId) {\n            // Ignore summarizer leave messages, to make sure not to start generating\n            // a summary as the summarizer is leaving\n            return;\n          }\n          // Leave ops for any other client fall through to handle normally\n        }\n      // Intentional fallthrough\n      case MessageType.ClientJoin:\n      case MessageType.Propose:\n      case MessageType.Reject:\n        {\n          // Synchronously handle quorum ops like regular ops\n          this.handleOp(undefined, op);\n          return;\n        }\n      default:\n        {\n          return;\n        }\n    }\n  }\n  handleOp(error, op) {\n    if (error !== undefined) {\n      return;\n    }\n    this.heuristics.lastOpSeqNumber = op.sequenceNumber;\n    // Check for ops requesting summary\n    if (op.type === MessageType.Save) {\n      this.trySummarize(`;${op.clientId}: ${op.contents}`);\n    } else {\n      this.heuristics.run();\n    }\n  }\n  waitStop() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      var _a, _b;\n      if (_this.disposed) {\n        return;\n      }\n      if (_this.stopping) {\n        yield (_a = _this.summarizing) === null || _a === void 0 ? void 0 : _a.promise;\n        return;\n      }\n      _this.stopping = true;\n      const outstandingOps = _this.heuristics.lastOpSeqNumber - _this.heuristics.lastAcked.refSequenceNumber;\n      if (outstandingOps > minOpsForLastSummary) {\n        _this.trySummarize(\"lastSummary\");\n        // This resolves when the current pending summary is acked or fails.\n        // We wait for the result in case a safe summary is needed, and to get\n        // better telemetry.\n        yield (_b = _this.summarizing) === null || _b === void 0 ? void 0 : _b.promise;\n      }\n    })();\n  }\n  waitStart() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      // Wait no longer than ack timeout for all pending\n      const maybeLastAck = yield Promise.race([_this2.summaryWatcher.waitFlushed(), _this2.pendingAckTimer.start()]);\n      _this2.pendingAckTimer.clear();\n      if (checkNotTimeout(maybeLastAck)) {\n        _this2.heuristics.initialize({\n          refSequenceNumber: maybeLastAck.summaryOp.referenceSequenceNumber,\n          summaryTime: maybeLastAck.summaryOp.timestamp,\n          summarySequenceNumber: maybeLastAck.summaryOp.sequenceNumber\n        });\n      }\n    })();\n  }\n  trySummarize(reason) {\n    var _this3 = this;\n    if (this.summarizing !== undefined) {\n      // We can't summarize if we are already\n      this.tryWhileSummarizing = true;\n      return;\n    }\n    // GenerateSummary could take some time\n    // mark that we are currently summarizing to prevent concurrent summarizing\n    this.summarizing = new Deferred();\n    _asyncToGenerator(function* () {\n      const result = yield _this3.summarize(reason, false);\n      if (result !== true) {\n        // On nack or error, try again in safe mode\n        yield _this3.summarize(reason, true);\n      }\n    })().finally(() => {\n      var _a;\n      (_a = this.summarizing) === null || _a === void 0 ? void 0 : _a.resolve();\n      this.summarizing = undefined;\n      if (this.tryWhileSummarizing && !this.stopping && !this.disposed) {\n        this.tryWhileSummarizing = false;\n        this.heuristics.run();\n      }\n    }).catch(error => {\n      this.logger.sendErrorEvent({\n        eventName: \"UnexpectedSummarizeError\"\n      }, error);\n    });\n  }\n  /**\n   * Generates summary and listens for broadcast and ack/nack.\n   * Returns true for ack, false for nack, and undefined for failure or timeout.\n   * @param reason - reason for summarizing\n   * @param safe - true to generate summary in safe mode\n   */\n  summarize(reason, safe) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      _this4.summarizeTimer.start();\n      try {\n        return yield _this4.summarizeCore(reason, safe);\n      } finally {\n        _this4.summarizeTimer.clear();\n        _this4.pendingAckTimer.clear();\n      }\n    })();\n  }\n  summarizeCore(reason, safe) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      ++_this5.summarizeCount;\n      // Wait to generate and send summary\n      const summaryData = yield _this5.generateSummaryWithLogging(reason, safe);\n      _this5.heuristics.recordAttempt((_a = summaryData) === null || _a === void 0 ? void 0 : _a.referenceSequenceNumber);\n      if (!summaryData || !summaryData.submitted) {\n        // Did not send the summary op\n        _this5.raiseSummarizingError(\"Error while generating or submitting summary\");\n        return undefined;\n      }\n      const pendingTimeoutP = _this5.pendingAckTimer.start().catch(() => undefined);\n      const summary = _this5.summaryWatcher.watchSummary(summaryData.clientSequenceNumber);\n      // Wait for broadcast\n      const summaryOp = yield Promise.race([summary.waitBroadcast(), pendingTimeoutP]);\n      if (!checkNotTimeout(summaryOp)) {\n        return undefined;\n      }\n      _this5.heuristics.lastAttempted.summarySequenceNumber = summaryOp.sequenceNumber;\n      _this5.logger.sendTelemetryEvent({\n        eventName: \"SummaryOp\",\n        timeWaiting: Date.now() - _this5.heuristics.lastAttempted.summaryTime,\n        refSequenceNumber: summaryOp.referenceSequenceNumber,\n        summarySequenceNumber: summaryOp.sequenceNumber,\n        handle: summaryOp.contents.handle\n      });\n      // Wait for ack/nack\n      const ackNack = yield Promise.race([summary.waitAckNack(), pendingTimeoutP]);\n      if (!checkNotTimeout(ackNack)) {\n        return undefined;\n      }\n      _this5.logger.sendTelemetryEvent({\n        eventName: ackNack.type === MessageType.SummaryAck ? \"SummaryAck\" : \"SummaryNack\",\n        category: ackNack.type === MessageType.SummaryAck ? \"generic\" : \"error\",\n        timeWaiting: Date.now() - _this5.heuristics.lastAttempted.summaryTime,\n        summarySequenceNumber: ackNack.contents.summaryProposal.summarySequenceNumber,\n        error: ackNack.type === MessageType.SummaryNack ? ackNack.contents.errorMessage : undefined,\n        handle: ackNack.type === MessageType.SummaryAck ? ackNack.contents.handle : undefined\n      });\n      _this5.pendingAckTimer.clear();\n      // Update for success\n      if (ackNack.type === MessageType.SummaryAck) {\n        _this5.heuristics.ackLastSent();\n        // since we need a full summary after context reload, we only clear this on ack\n        _this5.immediateSummary = false;\n        return true;\n      } else {\n        _this5.raiseSummarizingError(\"SummaryNack\");\n        return false;\n      }\n    })();\n  }\n  generateSummaryWithLogging(message, safe) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const summarizingEvent = PerformanceEvent.start(_this6.logger, {\n        eventName: \"GenerateSummary\",\n        message,\n        timeSinceLastAttempt: Date.now() - _this6.heuristics.lastAttempted.summaryTime,\n        timeSinceLastSummary: Date.now() - _this6.heuristics.lastAcked.summaryTime,\n        safe: safe || undefined\n      });\n      // Wait for generate/send summary\n      let summaryData;\n      try {\n        summaryData = yield _this6.internalsProvider.generateSummary(_this6.immediateSummary, safe, _this6.logger);\n      } catch (error) {\n        summarizingEvent.cancel({\n          category: \"error\"\n        }, error);\n        return;\n      }\n      _this6.summarizeTimer.clear();\n      if (!summaryData) {\n        summarizingEvent.cancel();\n        return;\n      }\n      const telemetryProps = Object.assign(Object.assign(Object.assign({}, summaryData), summaryData.summaryStats), {\n        refSequenceNumber: summaryData.referenceSequenceNumber,\n        opsSinceLastAttempt: summaryData.referenceSequenceNumber - _this6.heuristics.lastAttempted.refSequenceNumber,\n        opsSinceLastSummary: summaryData.referenceSequenceNumber - _this6.heuristics.lastAcked.refSequenceNumber\n      });\n      telemetryProps.summaryStats = undefined;\n      telemetryProps.referenceSequenceNumber = undefined;\n      if (summaryData.submitted) {\n        summarizingEvent.end(telemetryProps);\n      } else {\n        summarizingEvent.cancel(telemetryProps);\n      }\n      return summaryData;\n    })();\n  }\n  summarizeTimerHandler(time, count) {\n    this.logger.sendPerformanceEvent({\n      eventName: \"SummarizeTimeout\",\n      timeoutTime: time,\n      timeoutCount: count\n    });\n    if (count < maxSummarizeTimeoutCount) {\n      // Double and start a new timer\n      const nextTime = time * 2;\n      this.summarizeTimer.start(nextTime, () => this.summarizeTimerHandler(nextTime, count + 1));\n    }\n  }\n}\n/**\n * Summarizer is responsible for coordinating when to send generate and send summaries.\n * It is the main entry point for summary work.\n */\nexport class Summarizer extends EventEmitter {\n  constructor(url, runtime, configurationGetter, internalsProvider, handleContext, summaryCollection) {\n    var _a;\n    super();\n    this.runtime = runtime;\n    this.configurationGetter = configurationGetter;\n    this.internalsProvider = internalsProvider;\n    this.immediateSummary = false;\n    this.stopped = false;\n    this.stopDeferred = new Deferred();\n    this._disposed = false;\n    this.logger = ChildLogger.create(this.runtime.logger, \"Summarizer\");\n    this.runCoordinator = new RunWhileConnectedCoordinator(runtime);\n    if (summaryCollection) {\n      // summarize immediately because we just went through context reload\n      this.immediateSummary = true;\n      this.summaryCollection = summaryCollection;\n    } else {\n      this.summaryCollection = new SummaryCollection(this.runtime.deltaManager.initialSequenceNumber, this.logger);\n    }\n    this.runtime.deltaManager.inbound.on(\"op\", op => this.summaryCollection.handleOp(op));\n    (_a = this.runtime.previousState.nextSummarizerD) === null || _a === void 0 ? void 0 : _a.resolve(this);\n    this.innerHandle = new SummarizerHandle(this, url, handleContext);\n  }\n  get IFluidLoadable() {\n    return this;\n  }\n  get IFluidRouter() {\n    return this;\n  }\n  get IFluidRunnable() {\n    return this;\n  }\n  get ISummarizer() {\n    return this;\n  }\n  get handle() {\n    return this.innerHandle;\n  }\n  run(onBehalfOf) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this7.runCore(onBehalfOf);\n      } catch (error) {\n        const err2 = Object.assign(Object.assign({\n          logged: false\n        }, CreateContainerError(error)), {\n          errorType: summarizingError\n        });\n        _this7.emit(\"summarizingError\", err2);\n        throw error;\n      } finally {\n        // Cleanup after running\n        if (_this7.runtime.connected) {\n          if (_this7.runningSummarizer) {\n            yield _this7.runningSummarizer.waitStop();\n          }\n          _this7.runtime.closeFn();\n        }\n        _this7.dispose();\n      }\n    })();\n  }\n  /**\n   * Stops the summarizer from running.  This will complete\n   * the run promise, and also close the container.\n   * @param reason - reason code for stopping\n   */\n  stop(reason) {\n    if (this.stopped) {\n      // already stopping\n      return;\n    }\n    this.stopped = true;\n    this.logger.sendTelemetryEvent({\n      eventName: \"StoppingSummarizer\",\n      onBehalfOf: this.onBehalfOfClientId,\n      reason\n    });\n    this.stopDeferred.resolve();\n  }\n  updateOnBehalfOf(onBehalfOf) {\n    this.onBehalfOfClientId = onBehalfOf;\n  }\n  request(request) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      return {\n        mimeType: \"fluid/object\",\n        status: 200,\n        value: _this8\n      };\n    })();\n  }\n  runCore(onBehalfOf) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      _this9.onBehalfOfClientId = onBehalfOf;\n      const startResult = yield _this9.runCoordinator.waitStart();\n      if (startResult.started === false) {\n        _this9.logger.sendTelemetryEvent({\n          eventName: \"NotStarted\",\n          reason: startResult.message,\n          onBehalfOf\n        });\n        return;\n      }\n      if (_this9.runtime.deltaManager.active === false) {\n        _this9.logger.sendTelemetryEvent({\n          eventName: \"NotStarted\",\n          reason: \"CannotWrite\",\n          onBehalfOf\n        });\n        return;\n      }\n      if (_this9.runtime.summarizerClientId !== _this9.onBehalfOfClientId && _this9.runtime.summarizerClientId !== _this9.runtime.clientId) {\n        // Verify that this client's computed summarizer matches the client this was spawned\n        // on behalf of.  If not, fallback on the following logic before stopping:\n        // If we are not oldest client in quorum, another client will take over as summarizer.\n        // We want to make sure we at least try to summarize in case server is rejecting ops,\n        // so if we are the oldest client, we will still go through and try to summarize at least once.\n        // We also don't want to end up with two summarizer clients running at the same time,\n        // so we bypass running altogether if this client isn't the oldest.\n        _this9.logger.sendTelemetryEvent({\n          eventName: \"NotStarted\",\n          reason: \"DifferentComputedSummarizer\",\n          computedSummarizer: _this9.runtime.summarizerClientId,\n          onBehalfOf,\n          clientId: _this9.runtime.clientId\n        });\n        return;\n      }\n      // Initialize values and first ack (time is not exact)\n      _this9.logger.sendTelemetryEvent({\n        eventName: \"RunningSummarizer\",\n        onBehalfOf,\n        initSummarySeqNumber: _this9.summaryCollection.initialSequenceNumber\n      });\n      const initialAttempt = {\n        refSequenceNumber: _this9.summaryCollection.initialSequenceNumber,\n        summaryTime: Date.now()\n      };\n      const runningSummarizer = yield RunningSummarizer.start(startResult.clientId, onBehalfOf, _this9.logger, _this9.summaryCollection.createWatcher(startResult.clientId), _this9.configurationGetter(), _this9 /* Pick<ISummarizerInternalsProvider, \"generateSummary\"> */, _this9.runtime.deltaManager.lastSequenceNumber, initialAttempt, _this9.immediateSummary, description => {\n        if (!_this9._disposed) {\n          _this9.emit(\"summarizingError\", createSummarizingWarning(`Summarizer: ${description}`, true));\n        }\n      });\n      _this9.runningSummarizer = runningSummarizer;\n      _this9.immediateSummary = false;\n      // Handle summary acks\n      _this9.handleSummaryAcks().catch(error => {\n        _this9.logger.sendErrorEvent({\n          eventName: \"HandleSummaryAckFatalError\"\n        }, error);\n        // Raise error to parent container.\n        _this9.emit(\"summarizingError\", createSummarizingWarning(\"Summarizer: HandleSummaryAckFatalError\", true));\n        _this9.stop(\"HandleSummaryAckFatalError\");\n      });\n      // Listen for ops\n      _this9.systemOpListener = op => runningSummarizer.handleSystemOp(op);\n      _this9.runtime.deltaManager.inbound.on(\"op\", _this9.systemOpListener);\n      _this9.opListener = (error, op) => runningSummarizer.handleOp(error, op);\n      _this9.runtime.on(\"batchEnd\", _this9.opListener);\n      yield Promise.race([_this9.runCoordinator.waitStopped(), _this9.stopDeferred.promise]);\n    })();\n  }\n  /**\n   * Disposes of resources after running.  This cleanup will\n   * clear any outstanding timers and reset some of the state\n   * properties.\n   */\n  dispose() {\n    this._disposed = true;\n    if (this.runningSummarizer) {\n      this.runningSummarizer.dispose();\n      this.runningSummarizer = undefined;\n    }\n    if (this.systemOpListener) {\n      this.runtime.deltaManager.inbound.off(\"op\", this.systemOpListener);\n    }\n    if (this.opListener) {\n      this.runtime.removeListener(\"batchEnd\", this.opListener);\n    }\n  }\n  setSummarizer() {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      _this10.runtime.nextSummarizerD = new Deferred();\n      return _this10.runtime.nextSummarizerD.promise;\n    })();\n  }\n  /** Implementation of SummarizerInternalsProvider.generateSummary */\n  generateSummary(full, safe, summaryLogger) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      if (_this11.onBehalfOfClientId !== _this11.runtime.summarizerClientId && _this11.runtime.clientId !== _this11.runtime.summarizerClientId) {\n        // We are no longer the summarizer; a different client is, so we should stop ourself\n        _this11.stop(\"parentNoLongerSummarizer\");\n        return undefined;\n      }\n      return _this11.internalsProvider.generateSummary(full, safe, summaryLogger);\n    })();\n  }\n  handleSummaryAcks() {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      let refSequenceNumber = _this12.summaryCollection.initialSequenceNumber;\n      while (_this12.runningSummarizer) {\n        const summaryLogger = (_a = _this12.runningSummarizer.tryGetCorrelatedLogger(refSequenceNumber), _a !== null && _a !== void 0 ? _a : _this12.logger);\n        try {\n          const ack = yield _this12.summaryCollection.waitSummaryAck(refSequenceNumber);\n          refSequenceNumber = ack.summaryOp.referenceSequenceNumber;\n          yield _this12.internalsProvider.refreshLatestSummaryAck(ack.summaryOp.contents.handle, ack.summaryAckNack.contents.handle, summaryLogger);\n        } catch (error) {\n          summaryLogger.sendErrorEvent({\n            eventName: \"HandleSummaryAckError\",\n            refSequenceNumber\n          }, error);\n        }\n        refSequenceNumber++;\n      }\n    })();\n  }\n}\n//# sourceMappingURL=summarizer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}