{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n// TODO: should this just be \"s\"?\nexport const serviceRoutePathRoot = \"_services\";\n/**\n * This class is a simple starter class for building a Container Service. It simply provides routing\n */\nexport class BaseContainerService {\n  constructor(runtime) {\n    this.runtime = runtime;\n  }\n  get IFluidRouter() {\n    return this;\n  }\n  request(request) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return {\n        status: 200,\n        mimeType: \"fluid/object\",\n        value: _this\n      };\n    })();\n  }\n}\n/**\n * ContainerService Factory that will only create one instance of the service for the Container.\n */\nclass SingletonContainerServiceFactory {\n  constructor(serviceFn) {\n    this.serviceFn = serviceFn;\n  }\n  getService(runtime) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this2.service) {\n        _this2.service = _this2.serviceFn(runtime);\n      }\n      return _this2.service;\n    })();\n  }\n}\n/**\n * Given a collection of IContainerServices will produce a RequestHandler for them all\n * @param serviceRegistry - Collection of Container Services\n */\nexport const generateContainerServicesRequestHandler = serviceRegistry => {\n  const factories = new Map();\n  new Map(serviceRegistry).forEach((fn, id) => {\n    factories.set(id, new SingletonContainerServiceFactory(fn));\n  });\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (request, runtime) {\n      if (request.pathParts[0] !== serviceRoutePathRoot) {\n        // If the request is not for a service we return undefined so the next handler can use it\n        return undefined;\n      }\n      if (request.pathParts.length < 2) {\n        // If there is not service to route to then return a failure\n        return {\n          status: 400,\n          mimeType: \"text/plain\",\n          value: `request url: [${request.url}] did not specify a service to route to`\n        };\n      }\n      const factory = factories.get(request.pathParts[1]);\n      if (!factory) {\n        // If we can't find a registry entry then return\n        return Promise.resolve({\n          status: 404,\n          mimeType: \"text/plain\",\n          value: `Could not find a valid service for request url: [${request.url}]`\n        });\n      }\n      const service = yield factory.getService(runtime);\n      const router = service.IFluidRouter;\n      const subRequest = request.createSubRequest(2);\n      if (router) {\n        return router.request(subRequest);\n      }\n      if (!request.isLeaf(2)) {\n        // If there is not terminating route but a sub-route was requested then we will fail.\n        return {\n          status: 400,\n          mimeType: \"text/plain\",\n          value: `request sub-url: [${subRequest}] for service that doesn't support routing`\n        };\n      }\n      // Otherwise we will just return the service\n      return {\n        status: 200,\n        mimeType: \"fluid/object\",\n        value: service\n      };\n    });\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};\n//# sourceMappingURL=containerServices.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}