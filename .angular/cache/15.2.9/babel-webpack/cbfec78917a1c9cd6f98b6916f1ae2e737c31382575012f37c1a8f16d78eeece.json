{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { RedBlackTree } from \"./collections\";\nimport { UnassignedSequenceNumber } from \"./constants\";\nimport { compareNumbers, internedSpaces, MergeTree } from \"./mergeTree\";\n/**\n * Returns the partial length whose sequence number is\n * the greatest sequence number within a that is\n * less than or equal to key.\n * @param a - array of partial segment lengths\n * @param key - sequence number\n */\nfunction latestLEQ(a, key) {\n  let best = -1;\n  let lo = 0;\n  let hi = a.length - 1;\n  while (lo <= hi) {\n    const mid = lo + Math.floor((hi - lo) / 2);\n    if (a[mid].seq <= key) {\n      if (best < 0 || a[best].seq < a[mid].seq) {\n        best = mid;\n      }\n      lo = mid + 1;\n    } else {\n      hi = mid - 1;\n    }\n  }\n  return best;\n}\n/**\n * Keep track of partial sums of segment lengths for all sequence numbers\n * in the current collaboration window (if any).  Only used during active\n * collaboration.\n */\nexport let PartialSequenceLengths = /*#__PURE__*/(() => {\n  class PartialSequenceLengths {\n    constructor(minSeq) {\n      this.minSeq = minSeq;\n      this.minLength = 0;\n      this.segmentCount = 0;\n      this.partialLengths = [];\n      this.clientSeqNumbers = [];\n    }\n    static combine(mergeTree, block, collabWindow, recur = false) {\n      const partialLengthsTopBranch = PartialSequenceLengths.combineBranch(mergeTree, block, collabWindow, 0, recur);\n      if (mergeTree.localBranchId > 0) {\n        partialLengthsTopBranch.downstreamPartialLengths = [];\n        for (let i = 0; i < mergeTree.localBranchId; i++) {\n          partialLengthsTopBranch.downstreamPartialLengths[i] = PartialSequenceLengths.combineBranch(mergeTree, block, collabWindow, i + 1, recur);\n        }\n      }\n      return partialLengthsTopBranch;\n    }\n    /**\n     * Combine the partial lengths of block's children\n     * @param block - an interior node; it is assumed that each interior node child of this block\n     * has its partials up to date\n     * @param collabWindow - segment window of the segment tree containing textSegmentBlock\n     */\n    static combineBranch(mergeTree, block, collabWindow, branchId, recur = false) {\n      let combinedPartialLengths = new PartialSequenceLengths(collabWindow.minSeq);\n      PartialSequenceLengths.fromLeaves(mergeTree, branchId, combinedPartialLengths, block, collabWindow);\n      let prevPartial;\n      function cloneOverlapRemoveClients(oldTree) {\n        if (!oldTree) {\n          return undefined;\n        }\n        const newTree = new RedBlackTree(compareNumbers);\n        oldTree.map(bProp => {\n          newTree.put(bProp.data.clientId, Object.assign({}, bProp.data));\n          return true;\n        });\n        return newTree;\n      }\n      function combineOverlapClients(a, b) {\n        if (a.overlapRemoveClients) {\n          if (b.overlapRemoveClients) {\n            b.overlapRemoveClients.map(bProp => {\n              const aProp = a.overlapRemoveClients.get(bProp.key);\n              if (aProp) {\n                aProp.data.seglen += bProp.data.seglen;\n              } else {\n                a.overlapRemoveClients.put(bProp.data.clientId, Object.assign({}, bProp.data));\n              }\n              return true;\n            });\n          }\n        } else {\n          a.overlapRemoveClients = cloneOverlapRemoveClients(b.overlapRemoveClients);\n        }\n      }\n      function addNext(partialLength) {\n        const seq = partialLength.seq;\n        let pLen = 0;\n        if (prevPartial) {\n          if (prevPartial.seq === partialLength.seq) {\n            prevPartial.seglen += partialLength.seglen;\n            prevPartial.len += partialLength.seglen;\n            combineOverlapClients(prevPartial, partialLength);\n            return;\n          } else {\n            pLen = prevPartial.len;\n            // Previous sequence number is finished\n            combinedPartialLengths.addClientSeqNumberFromPartial(prevPartial);\n          }\n        }\n        prevPartial = {\n          clientId: partialLength.clientId,\n          len: pLen + partialLength.seglen,\n          overlapRemoveClients: cloneOverlapRemoveClients(partialLength.overlapRemoveClients),\n          seglen: partialLength.seglen,\n          seq\n        };\n        combinedPartialLengths.partialLengths.push(prevPartial);\n      }\n      const childPartials = [];\n      for (let i = 0; i < block.childCount; i++) {\n        const child = block.children[i];\n        if (!child.isLeaf()) {\n          const childBlock = child;\n          if (recur) {\n            childBlock.partialLengths = PartialSequenceLengths.combine(mergeTree, childBlock, collabWindow, true);\n          }\n          childPartials.push(childBlock.partialLengths.partialLengthsForBranch(branchId));\n        }\n      }\n      let childPartialsLen = childPartials.length;\n      if (childPartialsLen !== 0) {\n        // Some children are interior nodes\n        if (combinedPartialLengths.partialLengths.length > 0) {\n          // Some children were leaves; add combined partials from these segments\n          childPartials.push(combinedPartialLengths);\n          childPartialsLen++;\n          combinedPartialLengths = new PartialSequenceLengths(collabWindow.minSeq);\n        }\n        const indices = new Array(childPartialsLen);\n        const childPartialsCounts = new Array(childPartialsLen);\n        for (let i = 0; i < childPartialsLen; i++) {\n          indices[i] = 0;\n          childPartialsCounts[i] = childPartials[i].partialLengths.length;\n          combinedPartialLengths.minLength += childPartials[i].minLength;\n          combinedPartialLengths.segmentCount += childPartials[i].segmentCount;\n        }\n        let outerIndexOfEarliest = 0;\n        let earliestPartialLength;\n        while (outerIndexOfEarliest >= 0) {\n          outerIndexOfEarliest = -1;\n          for (let k = 0; k < childPartialsLen; k++) {\n            // Find next earliest sequence number\n            if (indices[k] < childPartialsCounts[k]) {\n              const cpLen = childPartials[k].partialLengths[indices[k]];\n              if (outerIndexOfEarliest < 0 || cpLen.seq < earliestPartialLength.seq) {\n                outerIndexOfEarliest = k;\n                earliestPartialLength = cpLen;\n              }\n            }\n          }\n          if (outerIndexOfEarliest >= 0) {\n            addNext(earliestPartialLength);\n            indices[outerIndexOfEarliest]++;\n          }\n        }\n        // Add client entry for last partial, if any\n        if (prevPartial) {\n          combinedPartialLengths.addClientSeqNumberFromPartial(prevPartial);\n        }\n      }\n      // TODO: incremental zamboni during build\n      // console.log(combinedPartialLengths.toString());\n      // console.log(`ZZZ...(min ${segmentWindow.minSeq})`);\n      if (PartialSequenceLengths.options.zamboni) {\n        combinedPartialLengths.zamboni(collabWindow);\n      }\n      if (PartialSequenceLengths.options.verify) {\n        combinedPartialLengths.verify();\n      }\n      // console.log(combinedPartialLengths.toString());\n      return combinedPartialLengths;\n    }\n    static fromLeaves(mergeTree, branchId, combinedPartialLengths, block, collabWindow) {\n      combinedPartialLengths.minLength = 0;\n      combinedPartialLengths.segmentCount = block.childCount;\n      function seqLTE(seq, minSeq) {\n        return seq !== UnassignedSequenceNumber && seq <= minSeq;\n      }\n      for (let i = 0; i < block.childCount; i++) {\n        const child = block.children[i];\n        if (child.isLeaf()) {\n          // Leaf segment\n          const segment = child;\n          const segBranchId = mergeTree.getBranchId(segment.clientId);\n          // eslint-disable-next-line max-len\n          // console.log(`seg br ${segBranchId} cli ${glc(mergeTree, segment.clientId)} me ${glc(mergeTree, mergeTree.collabWindow.clientId)}`);\n          if (segBranchId <= branchId) {\n            if (seqLTE(segment.seq, collabWindow.minSeq)) {\n              combinedPartialLengths.minLength += segment.cachedLength;\n            } else {\n              if (segment.seq !== UnassignedSequenceNumber) {\n                PartialSequenceLengths.insertSegment(combinedPartialLengths, segment);\n              }\n            }\n            const removalInfo = mergeTree.getRemovalInfo(branchId, segBranchId, segment);\n            if (seqLTE(removalInfo.removedSeq, collabWindow.minSeq)) {\n              combinedPartialLengths.minLength -= segment.cachedLength;\n            } else {\n              if (removalInfo.removedSeq !== undefined && removalInfo.removedSeq !== UnassignedSequenceNumber) {\n                PartialSequenceLengths.insertSegment(combinedPartialLengths, segment, true, removalInfo);\n              }\n            }\n          }\n        }\n      }\n      // Post-process correctly-ordered partials computing sums and creating\n      // lists for each present client id\n      const seqPartials = combinedPartialLengths.partialLengths;\n      const seqPartialsLen = seqPartials.length;\n      let prevLen = 0;\n      for (let i = 0; i < seqPartialsLen; i++) {\n        seqPartials[i].len = prevLen + seqPartials[i].seglen;\n        prevLen = seqPartials[i].len;\n        combinedPartialLengths.addClientSeqNumberFromPartial(seqPartials[i]);\n      }\n      if (PartialSequenceLengths.options.verify) {\n        combinedPartialLengths.verify();\n      }\n    }\n    static getOverlapClients(overlapClientids, seglen) {\n      const bst = new RedBlackTree(compareNumbers);\n      for (const clientId of overlapClientids) {\n        bst.put(clientId, {\n          clientId,\n          seglen\n        });\n      }\n      return bst;\n    }\n    static accumulateRemoveClientOverlap(partialLength, overlapRemoveClientIds, seglen) {\n      if (partialLength.overlapRemoveClients) {\n        for (const clientId of overlapRemoveClientIds) {\n          const ovlapClientNode = partialLength.overlapRemoveClients.get(clientId);\n          if (!ovlapClientNode) {\n            partialLength.overlapRemoveClients.put(clientId, {\n              clientId,\n              seglen\n            });\n          } else {\n            ovlapClientNode.data.seglen += seglen;\n          }\n        }\n      } else {\n        partialLength.overlapRemoveClients = PartialSequenceLengths.getOverlapClients(overlapRemoveClientIds, seglen);\n      }\n    }\n    static insertSegment(combinedPartialLengths, segment, removedSeq = false, removalInfo) {\n      let seq = segment.seq;\n      let segmentLen = segment.cachedLength;\n      let clientId = segment.clientId;\n      let removeClientOverlap;\n      if (removedSeq) {\n        seq = removalInfo.removedSeq;\n        segmentLen = -segmentLen;\n        clientId = removalInfo.removedClientId;\n        if (removalInfo.removedClientOverlap) {\n          removeClientOverlap = removalInfo.removedClientOverlap;\n        }\n      }\n      const seqPartials = combinedPartialLengths.partialLengths;\n      const seqPartialsLen = seqPartials.length;\n      // Find the first entry with sequence number greater or equal to seq\n      let indexFirstGTE = 0;\n      for (; indexFirstGTE < seqPartialsLen; indexFirstGTE++) {\n        if (seqPartials[indexFirstGTE].seq >= seq) {\n          break;\n        }\n      }\n      if (indexFirstGTE < seqPartialsLen && seqPartials[indexFirstGTE].seq === seq) {\n        seqPartials[indexFirstGTE].seglen += segmentLen;\n        if (removeClientOverlap) {\n          PartialSequenceLengths.accumulateRemoveClientOverlap(seqPartials[indexFirstGTE], removeClientOverlap, segmentLen);\n        }\n      } else {\n        let pLen;\n        if (removeClientOverlap) {\n          const overlapClients = PartialSequenceLengths.getOverlapClients(removeClientOverlap, segmentLen);\n          pLen = {\n            seq,\n            clientId,\n            len: 0,\n            seglen: segmentLen,\n            overlapRemoveClients: overlapClients\n          };\n        } else {\n          pLen = {\n            seq,\n            clientId,\n            len: 0,\n            seglen: segmentLen\n          };\n        }\n        if (indexFirstGTE < seqPartialsLen) {\n          // Shift entries with greater sequence numbers\n          // TODO: investigate performance improvement using BST\n          for (let k = seqPartialsLen; k > indexFirstGTE; k--) {\n            seqPartials[k] = seqPartials[k - 1];\n          }\n          seqPartials[indexFirstGTE] = pLen;\n        } else {\n          seqPartials.push(pLen);\n        }\n      }\n    }\n    static addSeq(partialLengths, seq, seqSeglen, clientId) {\n      let seqPartialLen;\n      let penultPartialLen;\n      let leqIndex = latestLEQ(partialLengths, seq);\n      if (leqIndex >= 0) {\n        const pLen = partialLengths[leqIndex];\n        if (pLen.seq === seq) {\n          seqPartialLen = pLen;\n          leqIndex = latestLEQ(partialLengths, seq - 1);\n          if (leqIndex >= 0) {\n            penultPartialLen = partialLengths[leqIndex];\n          }\n        } else {\n          penultPartialLen = pLen;\n        }\n      }\n      if (seqPartialLen === undefined) {\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        seqPartialLen = {\n          clientId,\n          seglen: seqSeglen,\n          seq\n        };\n        partialLengths.push(seqPartialLen);\n      } else {\n        seqPartialLen.seglen = seqSeglen;\n        // Assert client id matches\n      }\n\n      if (penultPartialLen !== undefined) {\n        seqPartialLen.len = seqPartialLen.seglen + penultPartialLen.len;\n      } else {\n        seqPartialLen.len = seqPartialLen.seglen;\n      }\n    }\n    update(mergeTree, block, seq, clientId, collabWindow) {\n      const segBranchId = mergeTree.getBranchId(clientId);\n      // eslint-disable-next-line max-len\n      // console.log(`seg br ${segBranchId} cli ${glc(mergeTree, segment.clientId)} me ${glc(mergeTree, mergeTree.collabWindow.clientId)}`);\n      if (segBranchId === 0) {\n        this.updateBranch(mergeTree, 0, block, seq, clientId, collabWindow);\n      }\n      if (mergeTree.localBranchId > 0) {\n        for (let i = 0; i < mergeTree.localBranchId; i++) {\n          const branchId = i + 1;\n          if (segBranchId <= branchId) {\n            this.downstreamPartialLengths[i].updateBranch(mergeTree, branchId, block, seq, clientId, collabWindow);\n          }\n        }\n      }\n    }\n    getPartialLength(mergeTree, refSeq, clientId) {\n      const branchId = mergeTree.getBranchId(clientId);\n      if (MergeTree.traceTraversal) {\n        console.log(`plen branch ${branchId}`);\n      }\n      if (branchId > 0) {\n        return this.downstreamPartialLengths[branchId - 1].getBranchPartialLength(refSeq, clientId);\n      } else {\n        return this.getBranchPartialLength(refSeq, clientId);\n      }\n    }\n    toString(glc, indentCount = 0) {\n      let buf = this.branchToString(glc);\n      if (this.downstreamPartialLengths) {\n        for (let i = 0, len = this.downstreamPartialLengths.length; i < len; i++) {\n          buf += \"\\n\";\n          buf += internedSpaces(indentCount);\n          buf += this.downstreamPartialLengths[i].branchToString(glc, i + 1);\n        }\n      }\n      return buf;\n    }\n    getBranchPartialLength(refSeq, clientId) {\n      let pLen = this.minLength;\n      const seqIndex = latestLEQ(this.partialLengths, refSeq);\n      const cliLatestindex = this.cliLatest(clientId);\n      const cliSeq = this.clientSeqNumbers[clientId];\n      if (seqIndex >= 0) {\n        // Add the partial length up to refSeq\n        pLen += this.partialLengths[seqIndex].len;\n        if (cliLatestindex >= 0) {\n          const cliLatest = cliSeq[cliLatestindex];\n          if (cliLatest.seq > refSeq) {\n            // The client has local edits after refSeq, add in the length adjustments\n            pLen += cliLatest.len;\n            const precedingCliIndex = this.cliLatestLEQ(clientId, refSeq);\n            if (precedingCliIndex >= 0) {\n              pLen -= cliSeq[precedingCliIndex].len;\n            }\n          }\n        }\n      } else {\n        // RefSeq is before any of the partial lengths\n        // so just add in all local edits of that client (which should all be after the refSeq)\n        if (cliLatestindex >= 0) {\n          const cliLatest = cliSeq[cliLatestindex];\n          pLen += cliLatest.len;\n        }\n      }\n      return pLen;\n    }\n    // Clear away partial sums for sequence numbers earlier than the current window\n    zamboni(segmentWindow) {\n      function copyDown(partialLengths) {\n        const mindex = latestLEQ(partialLengths, segmentWindow.minSeq);\n        let minLength = 0;\n        // console.log(`mindex ${mindex}`);\n        if (mindex >= 0) {\n          minLength = partialLengths[mindex].len;\n          const seqCount = partialLengths.length;\n          if (mindex <= seqCount - 1) {\n            // Still some entries remaining\n            const remainingCount = seqCount - mindex - 1;\n            // Copy down\n            for (let i = 0; i < remainingCount; i++) {\n              partialLengths[i] = partialLengths[i + mindex + 1];\n              partialLengths[i].len -= minLength;\n            }\n            partialLengths.length = remainingCount;\n          }\n        }\n        return minLength;\n      }\n      this.minLength += copyDown(this.partialLengths);\n      // eslint-disable-next-line @typescript-eslint/no-for-in-array, guard-for-in, no-restricted-syntax\n      for (const clientId in this.clientSeqNumbers) {\n        const cliPartials = this.clientSeqNumbers[clientId];\n        if (cliPartials) {\n          copyDown(cliPartials);\n        }\n      }\n    }\n    addClientSeqNumber(clientId, seq, seglen) {\n      if (this.clientSeqNumbers[clientId] === undefined) {\n        this.clientSeqNumbers[clientId] = [];\n      }\n      const cli = this.clientSeqNumbers[clientId];\n      let pLen = seglen;\n      if (cli.length > 0) {\n        pLen += cli[cli.length - 1].len;\n      }\n      cli.push({\n        seq,\n        len: pLen,\n        seglen\n      });\n    }\n    // Assumes sequence number already coalesced\n    addClientSeqNumberFromPartial(partialLength) {\n      this.addClientSeqNumber(partialLength.clientId, partialLength.seq, partialLength.seglen);\n      if (partialLength.overlapRemoveClients) {\n        partialLength.overlapRemoveClients.map(oc => {\n          this.addClientSeqNumber(oc.data.clientId, partialLength.seq, oc.data.seglen);\n          return true;\n        });\n      }\n    }\n    // Assume: seq is latest sequence number; no structural change to sub-tree, but a segment\n    // with sequence number seq has been added within the sub-tree\n    // TODO: assert client id matches\n    updateBranch(mergeTree, branchId, node, seq, clientId, collabWindow) {\n      let seqSeglen = 0;\n      let segCount = 0;\n      // Compute length for seq across children\n      for (let i = 0; i < node.childCount; i++) {\n        const child = node.children[i];\n        if (!child.isLeaf()) {\n          const childBlock = child;\n          const branchPartialLengths = childBlock.partialLengths.partialLengthsForBranch(branchId);\n          const partialLengths = branchPartialLengths.partialLengths;\n          const seqIndex = latestLEQ(partialLengths, seq);\n          if (seqIndex >= 0) {\n            const leqPartial = partialLengths[seqIndex];\n            if (leqPartial.seq === seq) {\n              seqSeglen += leqPartial.seglen;\n            }\n          }\n          segCount += branchPartialLengths.segmentCount;\n        } else {\n          const segment = child;\n          const segBranchId = mergeTree.getBranchId(segment.clientId);\n          const removalInfo = mergeTree.getRemovalInfo(branchId, segBranchId, segment);\n          if (segment.seq === seq) {\n            if (removalInfo.removedSeq !== seq) {\n              seqSeglen += segment.cachedLength;\n            }\n          } else {\n            if (removalInfo.removedSeq === seq) {\n              seqSeglen -= segment.cachedLength;\n            }\n          }\n          segCount++;\n        }\n      }\n      this.segmentCount = segCount;\n      PartialSequenceLengths.addSeq(this.partialLengths, seq, seqSeglen, clientId);\n      if (this.clientSeqNumbers[clientId] === undefined) {\n        this.clientSeqNumbers[clientId] = [];\n      }\n      PartialSequenceLengths.addSeq(this.clientSeqNumbers[clientId], seq, seqSeglen);\n      //    console.log(this.toString());\n      if (PartialSequenceLengths.options.zamboni) {\n        this.zamboni(collabWindow);\n      }\n      if (PartialSequenceLengths.options.verify) {\n        this.verify();\n      }\n      //   console.log('ZZZ');\n      //   console.log(this.toString());\n    }\n\n    partialLengthsForBranch(branchId) {\n      if (branchId > 0) {\n        return this.downstreamPartialLengths[branchId - 1];\n      } else {\n        return this;\n      }\n    }\n    cliLatestLEQ(clientId, refSeq) {\n      const cliSeqs = this.clientSeqNumbers[clientId];\n      if (cliSeqs) {\n        return latestLEQ(cliSeqs, refSeq);\n      } else {\n        return -1;\n      }\n    }\n    cliLatest(clientId) {\n      const cliSeqs = this.clientSeqNumbers[clientId];\n      if (cliSeqs && cliSeqs.length > 0) {\n        return cliSeqs.length - 1;\n      } else {\n        return -1;\n      }\n    }\n    branchToString(glc, branchId = 0) {\n      let buf = \"\";\n      for (const partial of this.partialLengths) {\n        buf += `(${partial.seq},${partial.len}) `;\n      }\n      // eslint-disable-next-line @typescript-eslint/no-for-in-array, no-restricted-syntax\n      for (const clientId in this.clientSeqNumbers) {\n        if (this.clientSeqNumbers[clientId].length > 0) {\n          buf += `Client `;\n          if (glc) {\n            buf += `${glc(+clientId)}`;\n          } else {\n            buf += `${clientId}`;\n          }\n          buf += \"[\";\n          for (const partial of this.clientSeqNumbers[clientId]) {\n            buf += `(${partial.seq},${partial.len})`;\n          }\n          buf += \"]\";\n        }\n      }\n      buf = `Br ${branchId}, min(seq ${this.minSeq}): ${this.minLength}; sc: ${this.segmentCount};${buf}`;\n      return buf;\n    }\n    // Debug only\n    verifyPartialLengths(partialLengths, clientPartials) {\n      if (partialLengths.length === 0) {\n        return 0;\n      }\n      let lastSeqNum = 0;\n      let accumSegLen = 0;\n      let count = 0;\n      for (const partialLength of partialLengths) {\n        // Count total number of partial length\n        count++;\n        // Sequence number should be larger or equal to minseq\n        assert(this.minSeq <= partialLength.seq);\n        // Sequence number should be sorted\n        assert(lastSeqNum < partialLength.seq);\n        lastSeqNum = partialLength.seq;\n        // Len is a accumulation of all the seglen adjustments\n        accumSegLen += partialLength.seglen;\n        if (accumSegLen !== partialLength.len) {\n          assert(false);\n        }\n        if (clientPartials) {\n          // Client partials used to track local edits so we can account for them some refSeq.\n          // But the information we keep track of are since minSeq, so we keep track of more history\n          // then needed, and some of them doesn't make sense to be used for length calculations\n          // e.g. if you have this sequence, where the minSeq is #5 because of other clients\n          //    seq 10: client 1: insert seg #1\n          //    seq 11: client 2: delete seg #2 refseq: 10\n          // minLength is 0, we would have keep a record of seglen: -1 for clientPartialLengths for client 2\n          // So if you ask for partial length for client 2 @ seq 5, we will have return -1.\n          // However, that combination is invalid, since we should never see any ops with refseq < 10 for\n          // client 2 after seq 11.\n        } else {\n          // Len adjustment should not make length negative\n          if (this.minLength + partialLength.len < 0) {\n            assert(false);\n          }\n        }\n        if (partialLength.overlapRemoveClients) {\n          // Only the flat partialLengths can have overlapRemoveClients, the per client view shouldn't\n          assert(!clientPartials);\n          // Each overlap client count as one\n          count += partialLength.overlapRemoveClients.size();\n        }\n      }\n      return count;\n    }\n    verify() {\n      if (this.clientSeqNumbers) {\n        let cliCount = 0;\n        for (const cliSeq of this.clientSeqNumbers) {\n          if (cliSeq) {\n            cliCount += this.verifyPartialLengths(cliSeq, true);\n          }\n        }\n        // If we have client view, we should have the flat view\n        assert(!!this.partialLengths);\n        const flatCount = this.verifyPartialLengths(this.partialLengths, false);\n        // The number of partial lengths on the client view and flat view should be the same\n        assert(flatCount === cliCount);\n      } else {\n        // If we don't have a client view, we shouldn't have the flat view either\n        assert(!this.partialLengths);\n      }\n    }\n  }\n  PartialSequenceLengths.options = {\n    verify: false,\n    zamboni: true\n  };\n  //# sourceMappingURL=partialLengths.js.map\n  return PartialSequenceLengths;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}