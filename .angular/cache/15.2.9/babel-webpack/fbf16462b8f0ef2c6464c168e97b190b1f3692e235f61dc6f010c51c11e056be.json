{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, EventForwarder } from \"@fluidframework/common-utils\";\nimport { FluidObjectHandle } from \"@fluidframework/datastore\";\nimport { handleFromLegacyUri } from \"@fluidframework/request-handler\";\nimport { serviceRoutePathRoot } from \"../container-services\";\nimport { defaultFluidObjectRequestHandler } from \"../request-handlers\";\n/**\n * This is a bare-bones base class that does basic setup and enables for factory on an initialize call.\n * You probably don't want to inherit from this data store directly unless\n * you are creating another base data store class\n *\n * @typeParam I - The optional input types used to strongly type the data object\n */\nexport class PureDataObject extends EventForwarder {\n  constructor(props) {\n    super();\n    this._disposed = false;\n    this.runtime = props.runtime;\n    this.context = props.context;\n    this.providers = props.providers;\n    this.initProps = props.initProps;\n    assert(this.runtime._dataObject === undefined, 0x0bd /* \"Object runtime already has DataObject!\" */);\n    this.runtime._dataObject = this;\n    // Create a FluidObjectHandle with empty string as `path`. This is because reaching this PureDataObject is the\n    // same as reaching its routeContext (FluidDataStoreRuntime) so the relative path to it from the\n    // routeContext is empty.\n    this.innerHandle = new FluidObjectHandle(this, \"\", this.runtime.objectsRoutingContext);\n    // Container event handlers\n    this.runtime.once(\"dispose\", () => {\n      this._disposed = true;\n      this.dispose();\n    });\n  }\n  get disposed() {\n    return this._disposed;\n  }\n  get id() {\n    return this.runtime.id;\n  }\n  get IFluidRouter() {\n    return this;\n  }\n  get IFluidLoadable() {\n    return this;\n  }\n  get IFluidHandle() {\n    return this.innerHandle;\n  }\n  /**\n   * Handle to a data store\n   */\n  get handle() {\n    return this.innerHandle;\n  }\n  static getDataObject(runtime) {\n    return _asyncToGenerator(function* () {\n      const obj = runtime._dataObject;\n      assert(obj !== undefined, 0x0bc /* \"Runtime has no DataObject!\" */);\n      yield obj.finishInitialization(true);\n      return obj;\n    })();\n  }\n  // #region IFluidRouter\n  /**\n   * Return this object if someone requests it directly\n   * We will return this object in two scenarios:\n   *  1. the request url is a \"/\"\n   *  2. the request url is empty\n   */\n  request(req) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return defaultFluidObjectRequestHandler(_this, req);\n    })();\n  }\n  // #endregion IFluidRouter\n  // #region IFluidLoadable\n  // #endregion IFluidLoadable\n  /**\n   * Call this API to ensure PureDataObject is fully initialized.\n   * Initialization happens on demand, only on as-needed bases.\n   * In most cases you should allow factory/object to decide when to finish initialization.\n   * But if you are supplying your own implementation of DataStoreRuntime factory and overriding some methods\n   * and need a fully initialized object, then you can call this API to ensure object is fully initialized.\n   */\n  finishInitialization(existing) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.initializeP !== undefined) {\n        return _this2.initializeP;\n      }\n      _this2.initializeP = _this2.initializeInternal(existing);\n      return _this2.initializeP;\n    })();\n  }\n  /**\n   * Internal initialize implementation. Overwriting this will change the flow of the PureDataObject and should\n   * generally not be done.\n   *\n   * Calls initializingFirstTime, initializingFromExisting, and hasInitialized. Caller is\n   * responsible for ensuring this is only invoked once.\n   */\n  initializeInternal(existing) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      yield _this3.preInitialize();\n      if (existing) {\n        assert(_this3.initProps === undefined, 0x0be /* \"Trying to initialize from existing while initProps is set!\" */);\n        yield _this3.initializingFromExisting();\n      } else {\n        yield _this3.initializingFirstTime((_a = _this3.context.createProps) !== null && _a !== void 0 ? _a : _this3.initProps);\n      }\n      yield _this3.hasInitialized();\n    })();\n  }\n  /**\n   * Retrieve Fluid object using the handle get\n   *\n   * @param key - key that object (handle/id) is stored with in the directory\n   * @param directory - directory containing the object\n   * @param getObjectFromDirectory - optional callback for fetching object from the directory, allows users to\n   * define custom types/getters for object retrieval\n   */\n  getFluidObjectFromDirectory(key, directory, getObjectFromDirectory) {\n    return _asyncToGenerator(function* () {\n      const handleMaybe = getObjectFromDirectory ? getObjectFromDirectory(key, directory) : directory.get(key);\n      const handle = handleMaybe === null || handleMaybe === void 0 ? void 0 : handleMaybe.IFluidHandle;\n      if (handle) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return handle.get();\n      }\n    })();\n  }\n  /**\n   * Gets the service at a given id.\n   * @param id - service id\n   */\n  getService(id) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      return handleFromLegacyUri(`/${serviceRoutePathRoot}/${id}`, _this4.context.containerRuntime).get();\n    })();\n  }\n  /**\n   * Called every time the data store is initialized, before initializingFirstTime or\n   * initializingFromExisting is called.\n   */\n  preInitialize() {\n    return _asyncToGenerator(function* () {})();\n  }\n  /**\n   * Called the first time the data store is initialized (new creations with a new\n   * data store runtime)\n   *\n   * @param props - Optional props to be passed in on create\n   */\n  initializingFirstTime(props) {\n    return _asyncToGenerator(function* () {})();\n  }\n  /**\n   * Called every time but the first time the data store is initialized (creations\n   * with an existing data store runtime)\n   */\n  initializingFromExisting() {\n    return _asyncToGenerator(function* () {})();\n  }\n  /**\n   * Called every time the data store is initialized after create or existing.\n   */\n  hasInitialized() {\n    return _asyncToGenerator(function* () {})();\n  }\n  /**\n   * Called when the host container closes and disposes itself\n   */\n  dispose() {\n    super.dispose();\n  }\n}\n//# sourceMappingURL=pureDataObject.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}