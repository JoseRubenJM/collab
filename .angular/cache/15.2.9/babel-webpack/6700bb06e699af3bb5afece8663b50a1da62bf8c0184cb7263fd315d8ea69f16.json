{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Schema } from './interfaces';\nimport { TinyliciousClient } from \"@fluidframework/tinylicious-client\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../services/fluid-relay.service\";\nfunction EditorComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 3);\n    i0.ɵɵelement(1, \"button\", 4)(2, \"button\", 5)(3, \"button\", 6);\n    i0.ɵɵelementEnd();\n  }\n}\nconst _c0 = function () {\n  return {\n    height: \"320px\"\n  };\n};\n// import { Editor } from 'primeng/editor'\n// import { CollaborativeText } from '../services/collaborative-text.dataobject';\n// import { FluidLoaderService } from '../services/fluid-loader.service';\n// import { CollaborativeTextContainerRuntimeFactory } from \"../services/containerCode\";\n// import { ISharedStringHelperTextChangedEventArgs, SharedStringHelper } from \"./sharedStringHelper\";\nexport let EditorComponent = /*#__PURE__*/(() => {\n  class EditorComponent {\n    // dataObject!: CollaborativeText;\n    constructor(azureFluidRelayService, changeDetector) {\n      this.azureFluidRelayService = azureFluidRelayService;\n      this.changeDetector = changeDetector;\n      this.schema = Schema;\n      this.fluidContainer = '';\n      this.services = '';\n      this.id = '';\n      this.initialObjects = '';\n      this.description = '';\n      this.fluidContainerTiny = '';\n      // type: any = 'remote'\n      this.selectionEnd = 0;\n      this.selectionStart = 0;\n    }\n    ngOnInit() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        // this.client = this.azureFluidRelayService.getClient()\n        // const clientProps = {\n        // \tconnection: {\n        // \t\ttype: this.type,\n        // \t\ttenantId: \"58ac4cc5-399e-4fcc-a01f-b5ce17dcf891\",\n        // \t\ttokenProvider: new InsecureTokenProvider(\"a438d403becde61cbd444f59d2f7a07b\", { id: \"123\" }),\n        // \t\tendpoint: \"https://us.fluidrelay.azure.com\",\n        // \t},\n        // }\n        // this.client = new AzureClient(clientProps);\n        // // this.fluidContainer = await this.client.createContainer(this.schema);\n        // // this.id = await this.fluidContainer.container.attach();\n        // this.fluidContainer = await this.client.getContainer(\"0d5b09a1-4a7c-4703-a39e-77f5a2ae9c3b\", this.schema)\n        // this.initialObjects = this.fluidContainer.container.initialObjects\n        // this.sharedDescription = this.initialObjects.description\n        // this.description = this.sharedDescription.getText()\n        // console.log(this.description)\n        // // console.log(this.description)\n        // console.log(this.sharedDescription.getLength())\n        // this.sharedDescription.insertText(this.sharedDescription.getLength(), \"a\")\n        // console.log(this.sharedDescription.getText())\n        // // this.syncData()\n        // this.dataObject = await this.fluidService.loadDataObject<CollaborativeText>(CollaborativeTextContainerRuntimeFactory)\n        // this.sharedDescription = this.dataObject.text\n        const client = new TinyliciousClient();\n        // this.fluidContainerTiny = await client.createContainer(this.schema)\n        // const id = await this.fluidContainerTiny.container.attach()\n        _this.fluidContainer = yield client.getContainer('92a85476-0cc9-4f42-83f9-8b74ac0a7f66', _this.schema);\n        _this.sharedDescription = _this.fluidContainer.container.initialObjects.description;\n        // this.sharedDescriptionTiny.insertText(this.sharedDescriptionTiny.getLength(), \"a\")\n        console.log(_this.sharedDescription);\n        console.log(_this.sharedDescription.getText());\n        _this.description = _this.sharedDescription.getText();\n      })();\n    }\n    ngAfterViewInit() {\n      // Sets an event listener so we can update our state as the value changes\n      // this.sharedDescription.on(\"\", (event: any) => {\n      // this.sharedDescription.on(\"textChanged\", (event: any) => {\n      this.sharedDescription.on(\"sequenceDelta\", event => {\n        const newText = this.sharedDescription.getText();\n        console.log(newText);\n        // We only need to insert if the text changed.\n        if (newText === this.description) {\n          return;\n        }\n        // If the event is our own then just insert the text\n        if (event.isLocal) {\n          this.description = newText;\n          return;\n        }\n        // Because we did not make the change we need to manage the remote\n        // character insertion.\n        const remoteCaretStart = event.first.position;\n        const remoteCaretEnd = event.last.position + event.last.segment.cachedLength;\n        const charactersModifiedCount = newText.length - this.description.length;\n        this.updateSelection();\n        const currentCaretStart = this.selectionStart;\n        const currentCaretEnd = this.selectionEnd;\n        let newCaretStart = 0;\n        let newCaretEnd = 0;\n        // Remote text inserted/removed after our cp range\n        if (currentCaretEnd <= remoteCaretStart) {\n          // cp stays where it was before.\n          newCaretStart = currentCaretStart;\n          newCaretEnd = currentCaretEnd;\n        } else if (currentCaretStart > remoteCaretEnd - 1) {\n          // Remote text inserted/removed before our cp range\n          // We need to move our cp the number of characters inserted/removed\n          // to ensure we are in the same position\n          newCaretStart = currentCaretStart + charactersModifiedCount;\n          newCaretEnd = currentCaretEnd + charactersModifiedCount;\n        } else {\n          // Remote text is overlapping cp\n          // The remote changes occurred inside current selection\n          if (remoteCaretEnd <= currentCaretEnd && remoteCaretStart > currentCaretStart) {\n            // Our selection needs to include remote changes\n            newCaretStart = currentCaretStart;\n            newCaretEnd = currentCaretEnd + charactersModifiedCount;\n          } else if (remoteCaretEnd >= currentCaretEnd && remoteCaretStart <= currentCaretStart) {\n            // The remote changes encompass our location\n            // Our selection has been removed\n            // Move our cp to the beginning of the new text insertion\n            newCaretStart = remoteCaretStart;\n            newCaretEnd = remoteCaretStart;\n          } else {\n            // We have partial overlapping selection with the changes.\n            // This makes things a lot harder to manage so for now we will just remove the current selection\n            // and place it to the remote caret start.\n            newCaretStart = remoteCaretStart;\n            newCaretEnd = remoteCaretStart;\n          }\n        }\n        this.description = newText;\n        this.setCaretPosition(newCaretStart, newCaretEnd);\n        // The event we're listening for here fires outside of Angular\n        // so let it know to detect changes\n        this.changeDetector.detectChanges();\n      });\n    }\n    setCaretPosition(newStart, newEnd) {\n      // if (this.textArea) {\n      //     const textArea = this.textArea.nativeElement;\n      //     textArea.selectionStart = newStart;\n      //     textArea.selectionEnd = newEnd;\n      // }\n      this.editor.setSelection(newStart, 0);\n    }\n    updateSelection() {\n      // if (!this.textArea) {\n      //   return;\n      // }\n      // const textArea = this.textArea.nativeElement;\n      // this.selectionStart = textArea.selectionStart ? textArea.selectionStart : 0;\n      // this.selectionEnd = textArea.selectionEnd ? textArea.selectionEnd : 0;\n      this.selectionStart = this.editor.getSelection().index;\n      this.selectionEnd = this.editor.getSelection().index;\n    }\n    onTextChange(event) {\n      // }\n      // handleChange(event: any) {\n      // We need to set the value here to keep the input responsive to the user\n      // const currentTarget = event.currentTarget;\n      const newText = this.quillGetDeltaInsert(event.delta);\n      const charactersModifiedCount = this.description.length - newText.length;\n      this.description = newText;\n      // Get the new caret position and use that to get the text that was inserted\n      const newPosition = this.editor.getSelection().index;\n      const isTextInserted = newPosition - this.selectionStart > 0;\n      if (isTextInserted) {\n        const insertedText = newText.substring(this.selectionStart, newPosition);\n        const changeRangeLength = this.selectionEnd - this.selectionStart;\n        if (changeRangeLength === 0) {\n          console.log(this.selectionStart + ' ' + insertedText);\n          this.sharedDescription.insertText(this.selectionStart, insertedText);\n        } else {\n          this.sharedDescription.replaceText(this.selectionStart, this.selectionEnd, insertedText);\n        }\n      } else {\n        // Text was removed\n        this.sharedDescription.removeText(newPosition, newPosition + charactersModifiedCount);\n      }\n    }\n    onInitEditor(event) {\n      // console.log(event.editor.getSelection())\n      this.editor = event.editor;\n    }\n    quillGetDeltaInsert(delta) {\n      return delta.map(op => {\n        if (typeof op.insert === 'string') {\n          return op.insert;\n        } else {\n          return '';\n        }\n      }).join('');\n    }\n    quillGetDeltaPosition(delta) {\n      return delta.map(op => {\n        if (typeof op.retain === 'number') {\n          return op.retain;\n        } else {\n          return '';\n        }\n      }).join('');\n    }\n  }\n  EditorComponent.ɵfac = function EditorComponent_Factory(t) {\n    return new (t || EditorComponent)(i0.ɵɵdirectiveInject(i1.AzureFluidRelayService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n  EditorComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: EditorComponent,\n    selectors: [[\"app-editor\"]],\n    decls: 3,\n    vars: 4,\n    consts: [[3, \"ngModel\", \"onInit\", \"onTextChange\", \"ngModelChange\"], [\"editor\", \"\"], [\"pTemplate\", \"header\"], [1, \"ql-formats\"], [\"type\", \"button\", \"aria-label\", \"Bold\", 1, \"ql-bold\"], [\"type\", \"button\", \"aria-label\", \"Italic\", 1, \"ql-italic\"], [\"type\", \"button\", \"aria-label\", \"Underline\", 1, \"ql-underline\"]],\n    template: function EditorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"p-editor\", 0, 1);\n        i0.ɵɵlistener(\"onInit\", function EditorComponent_Template_p_editor_onInit_0_listener($event) {\n          return ctx.onInitEditor($event);\n        })(\"onTextChange\", function EditorComponent_Template_p_editor_onTextChange_0_listener($event) {\n          return ctx.onTextChange($event);\n        })(\"ngModelChange\", function EditorComponent_Template_p_editor_ngModelChange_0_listener($event) {\n          return ctx.description = $event;\n        });\n        i0.ɵɵtemplate(2, EditorComponent_ng_template_2_Template, 4, 0, \"ng-template\", 2);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵstyleMap(i0.ɵɵpureFunction0(3, _c0));\n        i0.ɵɵproperty(\"ngModel\", ctx.description);\n      }\n    },\n    styles: [\".p-editor-container .p-editor-content .ql-editor{background:#b7bdc8}\\n\"],\n    encapsulation: 2\n  });\n  return EditorComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}