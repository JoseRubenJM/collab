{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { parseHandles, serializeHandles, SharedObject, ValueType } from \"@fluidframework/shared-object-base\";\nexport function makeSerializable(localValue, serializer, bind) {\n  const value = localValue.makeSerialized(serializer, bind);\n  return {\n    type: value.type,\n    value: value.value && JSON.parse(value.value)\n  };\n}\n/**\n * Manages a contained plain value.  May also contain shared object handles.\n */\nexport class PlainLocalValue {\n  /**\n   * Create a new PlainLocalValue.\n   * @param value - The value to store, which may contain shared object handles\n   */\n  constructor(value) {\n    this.value = value;\n  }\n  /**\n   * {@inheritDoc ILocalValue.\"type\"}\n   */\n  get type() {\n    return ValueType[ValueType.Plain];\n  }\n  /**\n   * {@inheritDoc ILocalValue.makeSerialized}\n   */\n  makeSerialized(serializer, bind) {\n    // Stringify to convert to the serialized handle values - and then parse in order to create\n    // a POJO for the op\n    const value = serializeHandles(this.value, serializer, bind);\n    return {\n      type: this.type,\n      value\n    };\n  }\n}\n/**\n * Manages a contained value type.\n *\n * @privateRemarks\n * TODO: Should maybe be a generic\n *\n * @alpha\n */\nexport class ValueTypeLocalValue {\n  /**\n   * Create a new ValueTypeLocalValue.\n   * @param value - The instance of the value type stored within\n   * @param valueType - The type object of the value type stored within\n   */\n  constructor(value, valueType) {\n    this.value = value;\n    this.valueType = valueType;\n  }\n  /**\n   * {@inheritDoc ILocalValue.\"type\"}\n   */\n  get type() {\n    return this.valueType.name;\n  }\n  /**\n   * {@inheritDoc ILocalValue.makeSerialized}\n   */\n  makeSerialized(serializer, bind) {\n    const storedValueType = this.valueType.factory.store(this.value);\n    const value = serializeHandles(storedValueType, serializer, bind);\n    return {\n      type: this.type,\n      value\n    };\n  }\n  /**\n   * Get the handler for a given op of this value type.\n   * @param opName - The name of the operation that needs processing\n   * @returns The object which can process the given op\n   */\n  getOpHandler(opName) {\n    const handler = this.valueType.ops.get(opName);\n    if (!handler) {\n      throw new Error(\"Unknown type message\");\n    }\n    return handler;\n  }\n}\n/**\n * A LocalValueMaker enables a container type DDS to produce and store local values with minimal awareness of how\n * those objects are stored, serialized, and deserialized.\n */\nexport class LocalValueMaker {\n  /**\n   * Create a new LocalValueMaker.\n   * @param serializer - The serializer to serialize / parse handles.\n   */\n  constructor(serializer) {\n    this.serializer = serializer;\n    /**\n     * The value types this maker is able to produce.\n     */\n    this.valueTypes = new Map();\n  }\n  /**\n   * Register a value type this maker will be able to produce.\n   * @param type - The value type to register\n   * @alpha\n   */\n  registerValueType(type) {\n    this.valueTypes.set(type.name, type);\n  }\n  /**\n   * Create a new local value from an incoming serialized value.\n   * @param serializable - The serializable value to make local\n   */\n  fromSerializable(serializable) {\n    // Migrate from old shared value to handles\n    if (serializable.type === ValueType[ValueType.Shared]) {\n      serializable.type = ValueType[ValueType.Plain];\n      const handle = {\n        type: \"__fluid_handle__\",\n        url: serializable.value\n      };\n      serializable.value = handle;\n    }\n    const translatedValue = parseHandles(serializable.value, this.serializer);\n    return new PlainLocalValue(translatedValue);\n  }\n  /**\n   * Create a new local value from an incoming serialized value for value type\n   * @param serializable - The serializable value to make local\n   * @param emitter - The value op emitter, if the serializable is a value type\n   */\n  fromSerializableValueType(serializable, emitter) {\n    if (this.valueTypes.has(serializable.type)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const valueType = this.valueTypes.get(serializable.type);\n      serializable.value = parseHandles(serializable.value, this.serializer);\n      const localValue = valueType.factory.load(emitter, serializable.value);\n      return new ValueTypeLocalValue(localValue, valueType);\n    } else {\n      throw new Error(`Unknown value type \"${serializable.type}\"`);\n    }\n  }\n  /**\n   * Create a new local value containing a given plain object.\n   * @param value - The value to store\n   * @returns An ILocalValue containing the value\n   */\n  fromInMemory(value) {\n    if (SharedObject.is(value)) {\n      throw new Error(\"SharedObject sets are no longer supported. Instead set the SharedObject handle.\");\n    }\n    return new PlainLocalValue(value);\n  }\n  /**\n   * Create a new local value containing a value type.\n   * @param type - The type of the value type to create\n   * @param emitter - The IValueOpEmitter object that the new value type will use to emit ops\n   * @param params - The initialization arguments for the value type\n   * @returns An ILocalValue containing the new value type\n   * @alpha\n   */\n  makeValueType(type, emitter, params) {\n    const valueType = this.loadValueType(params, type, emitter);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return new ValueTypeLocalValue(valueType, this.valueTypes.get(type));\n  }\n  /**\n   * Create a new value type.\n   * @param params - The initialization arguments for the value type\n   * @param type - The type of value type to create\n   * @param emitter - The IValueOpEmitter object that the new value type will use to emit ops\n   * @returns The new value type\n   * @alpha\n   */\n  loadValueType(params, type, emitter) {\n    const valueType = this.valueTypes.get(type);\n    if (!valueType) {\n      throw new Error(`Unknown type '${type}' specified`);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return valueType.factory.load(emitter, params);\n  }\n}\n//# sourceMappingURL=localValues.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}