{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { MapFactory, SharedDirectory } from \"@fluidframework/map\";\nimport { RequestParser } from \"@fluidframework/runtime-utils\";\nimport { v4 as uuid } from \"uuid\";\nimport { BlobHandle } from \"./blobHandle\";\nimport { PureDataObject } from \"./pureDataObject\";\n/**\n * DataObject is a base data store that is primed with a root directory and task manager. It\n * ensures that both are created and ready before you can access it.\n *\n * Having a single root directory allows for easier development. Instead of creating\n * and registering channels with the runtime any new DDS that is set on the root\n * will automatically be registered.\n *\n * Generics:\n * O - represents a type that will define optional providers that will be injected\n * S - the initial state type that the produced data store may take during creation\n * E - represents events that will be available in the EventForwarder\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport class DataObject extends PureDataObject {\n  constructor() {\n    super(...arguments);\n    this.rootDirectoryId = \"root\";\n    this.bigBlobs = \"bigBlobs/\";\n  }\n  request(request) {\n    var _superprop_getRequest = () => super.request,\n      _this = this;\n    return _asyncToGenerator(function* () {\n      const url = request.url;\n      const requestParser = RequestParser.create({\n        url: request.url\n      });\n      const itemId = requestParser.pathParts[0];\n      if (itemId === \"bigBlobs\") {\n        const value = _this.root.get(requestParser.pathParts.join(\"/\"));\n        if (value === undefined) {\n          return {\n            mimeType: \"text/plain\",\n            status: 404,\n            value: `request ${url} not found`\n          };\n        }\n        return {\n          mimeType: \"fluid/object\",\n          status: 200,\n          value\n        };\n      } else {\n        return _superprop_getRequest().call(_this, request);\n      }\n    })();\n  }\n  /**\n   * The root directory will either be ready or will return an error. If an error is thrown\n   * the root has not been correctly created/set.\n   */\n  get root() {\n    if (!this.internalRoot) {\n      throw new Error(this.getUninitializedErrorString(`root`));\n    }\n    return this.internalRoot;\n  }\n  /**\n   * Returns the built-in task manager responsible for scheduling tasks.\n   */\n  get taskManager() {\n    if (!this.internalTaskManager) {\n      throw new Error(this.getUninitializedErrorString(`taskManager`));\n    }\n    return this.internalTaskManager;\n  }\n  /**\n   * Temporary implementation of blobs.\n   * Currently blobs are stored as properties on root map and we rely\n   * on map doing proper snapshot blob partitioning to reuse non-changing big properties.\n   * In future blobs would be implemented as first class citizen, using blob storage APIs\n   */\n  writeBlob(blob) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.runtime.logger.sendTelemetryEvent({\n        eventName: \"WriteBlob\",\n        size: blob.length\n      });\n      const path = `${_this2.bigBlobs}${uuid()}`;\n      _this2.root.set(path, blob);\n      return new BlobHandle(path, _this2.root, _this2.runtime.objectsRoutingContext);\n    })();\n  }\n  /**\n   * Initializes internal objects and calls initialization overrides.\n   * Caller is responsible for ensuring this is only invoked once.\n   */\n  initializeInternal() {\n    var _superprop_getInitializeInternal = () => super.initializeInternal,\n      _this3 = this;\n    return _asyncToGenerator(function* () {\n      // Initialize task manager.\n      _this3.internalTaskManager = yield _this3.context.containerRuntime.getTaskManager();\n      if (!_this3.runtime.existing) {\n        // Create a root directory and register it before calling initializingFirstTime\n        _this3.internalRoot = SharedDirectory.create(_this3.runtime, _this3.rootDirectoryId);\n        _this3.internalRoot.bindToContext();\n      } else {\n        // data store has a root directory so we just need to set it before calling initializingFromExisting\n        _this3.internalRoot = yield _this3.runtime.getChannel(_this3.rootDirectoryId);\n        // This will actually be an ISharedMap if the channel was previously created by the older version of\n        // DataObject which used a SharedMap.  Since SharedMap and SharedDirectory are compatible unless\n        // SharedDirectory-only commands are used on SharedMap, this will mostly just work for compatibility.\n        if (_this3.internalRoot.attributes.type === MapFactory.Type) {\n          _this3.runtime.logger.send({\n            category: \"generic\",\n            eventName: \"MapDataObject\",\n            message: \"Legacy document, SharedMap is masquerading as SharedDirectory in DataObject\"\n          });\n        }\n      }\n      yield _superprop_getInitializeInternal().call(_this3);\n    })();\n  }\n  getUninitializedErrorString(item) {\n    return `${item} must be initialized before being accessed.`;\n  }\n}\n//# sourceMappingURL=dataObject.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}