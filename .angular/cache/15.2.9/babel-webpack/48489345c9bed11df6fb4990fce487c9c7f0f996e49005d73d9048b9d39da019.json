{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { DataCorruptionError } from \"@fluidframework/container-utils\";\nimport { channelsTreeName, CreateSummarizerNodeSource } from \"@fluidframework/runtime-definitions\";\nimport { convertSnapshotTreeToSummaryTree, convertSummaryTreeToITree, convertToSummaryTree, SummaryTreeBuilder } from \"@fluidframework/runtime-utils\";\nimport { ChildLogger } from \"@fluidframework/telemetry-utils\";\nimport { AttachState } from \"@fluidframework/container-definitions\";\nimport { BlobCacheStorageService, buildSnapshotTree, readAndParseFromBlobs } from \"@fluidframework/driver-utils\";\nimport { assert, Lazy } from \"@fluidframework/common-utils\";\nimport { v4 as uuid } from \"uuid\";\nimport { TreeTreeEntry } from \"@fluidframework/protocol-base\";\nimport { GCDataBuilder } from \"@fluidframework/garbage-collector\";\nimport { DataStoreContexts } from \"./dataStoreContexts\";\nimport { RemotedFluidDataStoreContext, LocalFluidDataStoreContext, createAttributesBlob, LocalDetachedFluidDataStoreContext } from \"./dataStoreContext\";\nimport { dataStoreAttributesBlobName, nonDataStorePaths } from \"./snapshot\";\n/**\n * This class encapsulates data store handling. Currently it is only used by the container runtime,\n * but eventually could be hosted on any channel once we formalize the channel api boundary.\n */\nexport class DataStores {\n  constructor(baseSnapshot, runtime, submitAttachFn, getCreateChildSummarizerNodeFn, baseLogger, contexts = new DataStoreContexts(baseLogger)) {\n    var _a;\n    this.baseSnapshot = baseSnapshot;\n    this.runtime = runtime;\n    this.submitAttachFn = submitAttachFn;\n    this.getCreateChildSummarizerNodeFn = getCreateChildSummarizerNodeFn;\n    this.contexts = contexts;\n    // Stores tracked by the Domain\n    this.pendingAttach = new Map();\n    // 0.24 back-compat attachingBeforeSummary\n    this.attachOpFiredForDataStore = new Set();\n    this.disposeOnce = new Lazy(() => this.contexts.dispose());\n    this.dispose = () => this.disposeOnce.value;\n    this.logger = ChildLogger.create(baseLogger);\n    // Extract stores stored inside the snapshot\n    const fluidDataStores = new Map();\n    if (baseSnapshot) {\n      for (const [key, value] of Object.entries(baseSnapshot.trees)) {\n        fluidDataStores.set(key, value);\n      }\n    }\n    // Create a context for each of them\n    for (const [key, value] of fluidDataStores) {\n      let dataStoreContext;\n      // If we have a detached container, then create local data store contexts.\n      if (this.runtime.attachState !== AttachState.Detached) {\n        dataStoreContext = new RemotedFluidDataStoreContext(key, value, this.runtime, this.runtime.storage, this.runtime.scope, this.getCreateChildSummarizerNodeFn(key, {\n          type: CreateSummarizerNodeSource.FromSummary\n        }));\n      } else {\n        let pkgFromSnapshot;\n        if (typeof value !== \"object\") {\n          throw new Error(\"Snapshot should be there to load from!!\");\n        }\n        const snapshotTree = value;\n        // Need to rip through snapshot.\n        const attributes = readAndParseFromBlobs(snapshotTree.blobs, snapshotTree.blobs[dataStoreAttributesBlobName]);\n        // Use the snapshotFormatVersion to determine how the pkg is encoded in the snapshot.\n        // For snapshotFormatVersion = \"0.1\" or above, pkg is jsonified, otherwise it is just a string.\n        // However the feature of loading a detached container from snapshot, is added when the\n        // snapshotFormatVersion is at least \"0.1\", so we don't expect it to be anything else.\n        if (attributes.snapshotFormatVersion === \"0.1\" || attributes.snapshotFormatVersion === 2) {\n          pkgFromSnapshot = JSON.parse(attributes.pkg);\n        } else {\n          throw new Error(`Invalid snapshot format version ${attributes.snapshotFormatVersion}`);\n        }\n        dataStoreContext = new LocalFluidDataStoreContext(key, pkgFromSnapshot, this.runtime, this.runtime.storage, this.runtime.scope, this.getCreateChildSummarizerNodeFn(key, {\n          type: CreateSummarizerNodeSource.FromSummary\n        }), cr => this.bindFluidDataStore(cr), snapshotTree, (_a =\n        // If there is no isRootDataStore in the attributes blob, set it to true. This ensures that data\n        // stores in older documents are not garbage collected incorrectly. This may lead to additional\n        // roots in the document but they won't break.\n        attributes.isRootDataStore, _a !== null && _a !== void 0 ? _a : true));\n      }\n      this.contexts.addBoundOrRemoted(dataStoreContext);\n    }\n  }\n  processAttachMessage(message, local) {\n    var _a, _b;\n    const attachMessage = message.contents;\n    // The local object has already been attached\n    if (local) {\n      assert(this.pendingAttach.has(attachMessage.id));\n      (_a = this.contexts.get(attachMessage.id)) === null || _a === void 0 ? void 0 : _a.emit(\"attached\");\n      this.pendingAttach.delete(attachMessage.id);\n      return;\n    }\n    // If a non-local operation then go and create the object, otherwise mark it as officially attached.\n    if (this.contexts.has(attachMessage.id)) {\n      const error = new DataCorruptionError(\"Duplicate data store created with existing ID\", {\n        sequenceNumber: message.sequenceNumber,\n        clientId: message.clientId,\n        referenceSequenceNumber: message.referenceSequenceNumber\n      });\n      this.logger.sendErrorEvent({\n        eventName: \"DuplicateDataStoreId\"\n      }, error);\n      throw error;\n    }\n    const flatBlobs = new Map();\n    let snapshotTree;\n    if (attachMessage.snapshot) {\n      snapshotTree = buildSnapshotTree(attachMessage.snapshot.entries, flatBlobs);\n    }\n    // Include the type of attach message which is the pkg of the store to be\n    // used by RemotedFluidDataStoreContext in case it is not in the snapshot.\n    const pkg = [attachMessage.type];\n    const remotedFluidDataStoreContext = new RemotedFluidDataStoreContext(attachMessage.id, snapshotTree, this.runtime, new BlobCacheStorageService(this.runtime.storage, flatBlobs), this.runtime.scope, this.getCreateChildSummarizerNodeFn(attachMessage.id, {\n      type: CreateSummarizerNodeSource.FromAttach,\n      sequenceNumber: message.sequenceNumber,\n      snapshot: (_b = attachMessage.snapshot, _b !== null && _b !== void 0 ? _b : {\n        id: null,\n        entries: [createAttributesBlob(pkg, true /* isRootDataStore */)]\n      })\n    }), pkg);\n    // Resolve pending gets and store off any new ones\n    this.contexts.addBoundOrRemoted(remotedFluidDataStoreContext);\n    // Equivalent of nextTick() - Prefetch once all current ops have completed\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    Promise.resolve().then( /*#__PURE__*/_asyncToGenerator(function* () {\n      return remotedFluidDataStoreContext.realize();\n    }));\n  }\n  bindFluidDataStore(fluidDataStoreRuntime) {\n    const id = fluidDataStoreRuntime.id;\n    const localContext = this.contexts.getUnbound(id);\n    assert(!!localContext, \"Could not find unbound context to bind\");\n    // If the container is detached, we don't need to send OP or add to pending attach because\n    // we will summarize it while uploading the create new summary and make it known to other\n    // clients.\n    if (this.runtime.attachState !== AttachState.Detached) {\n      localContext.emit(\"attaching\");\n      const message = localContext.generateAttachMessage();\n      this.pendingAttach.set(id, message);\n      this.submitAttachFn(message);\n      this.attachOpFiredForDataStore.add(id);\n    }\n    this.contexts.bind(fluidDataStoreRuntime.id);\n  }\n  createDetachedDataStoreCore(pkg, isRoot, id = uuid()) {\n    const context = new LocalDetachedFluidDataStoreContext(id, pkg, this.runtime, this.runtime.storage, this.runtime.scope, this.getCreateChildSummarizerNodeFn(id, {\n      type: CreateSummarizerNodeSource.Local\n    }), cr => this.bindFluidDataStore(cr), undefined, isRoot);\n    this.contexts.addUnbound(context);\n    return context;\n  }\n  _createFluidDataStoreContext(pkg, id, isRoot, props) {\n    const context = new LocalFluidDataStoreContext(id, pkg, this.runtime, this.runtime.storage, this.runtime.scope, this.getCreateChildSummarizerNodeFn(id, {\n      type: CreateSummarizerNodeSource.Local\n    }), cr => this.bindFluidDataStore(cr), undefined, isRoot, props);\n    this.contexts.addUnbound(context);\n    return context;\n  }\n  get disposed() {\n    return this.disposeOnce.evaluated;\n  }\n  updateLeader() {\n    for (const [, context] of this.contexts) {\n      context.updateLeader(this.runtime.leader);\n    }\n  }\n  resubmitDataStoreOp(content, localOpMetadata) {\n    const envelope = content;\n    const context = this.contexts.get(envelope.address);\n    assert(!!context, \"There should be a store context for the op\");\n    context.reSubmit(envelope.contents, localOpMetadata);\n  }\n  processFluidDataStoreOp(message, local, localMessageMetadata) {\n    const envelope = message.contents;\n    const transformed = Object.assign(Object.assign({}, message), {\n      contents: envelope.contents\n    });\n    const context = this.contexts.get(envelope.address);\n    assert(!!context, \"There should be a store context for the op\");\n    context.process(transformed, local, localMessageMetadata);\n  }\n  getDataStore(id, wait) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const context = yield _this.contexts.getBoundOrRemoted(id, wait);\n      if (context === undefined) {\n        throw new Error(`DataStore ${id} does not yet exist or is not yet bound`);\n      }\n      return context.realize();\n    })();\n  }\n  processSignal(address, message, local) {\n    const context = this.contexts.get(address);\n    if (!context) {\n      // Attach message may not have been processed yet\n      assert(!local, \"Missing datastore for local signal\");\n      this.logger.sendTelemetryEvent({\n        eventName: \"SignalFluidDataStoreNotFound\",\n        fluidDataStoreId: address\n      });\n      return;\n    }\n    context.processSignal(message, local);\n  }\n  setConnectionState(connected, clientId) {\n    for (const [fluidDataStore, context] of this.contexts) {\n      try {\n        context.setConnectionState(connected, clientId);\n      } catch (error) {\n        this.logger.sendErrorEvent({\n          eventName: \"SetConnectionStateError\",\n          clientId,\n          fluidDataStore\n        }, error);\n      }\n    }\n  }\n  setAttachState(attachState) {\n    let eventName;\n    if (attachState === AttachState.Attaching) {\n      eventName = \"attaching\";\n    } else {\n      eventName = \"attached\";\n    }\n    for (const [, context] of this.contexts) {\n      // Fire only for bounded stores.\n      if (!this.contexts.isNotBound(context.id)) {\n        context.emit(eventName);\n      }\n    }\n  }\n  /**\n   * Notifies this object to take the snapshot of the container.\n   * @deprecated - Use summarize to get summary of the container runtime.\n   */\n  snapshot() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      // Iterate over each store and ask it to snapshot\n      const fluidDataStoreSnapshotsP = Array.from(_this2.contexts).map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* ([fluidDataStoreId, value]) {\n          const summaryTree = yield value.summarize(true /* fullTree */, false /* trackState */);\n          assert(summaryTree.summary.type === 1 /* Tree */, \"summarize should always return a tree when fullTree is true\");\n          // back-compat summary - Remove this once snapshot is removed.\n          const snapshot = convertSummaryTreeToITree(summaryTree.summary);\n          // If ID exists then previous commit is still valid\n          return {\n            fluidDataStoreId,\n            snapshot\n          };\n        });\n        return function (_x) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n      const entries = [];\n      // Add in module references to the store snapshots\n      const fluidDataStoreSnapshots = yield Promise.all(fluidDataStoreSnapshotsP);\n      // Sort for better diffing of snapshots (in replay tool, used to find bugs in snapshotting logic)\n      fluidDataStoreSnapshots.sort((a, b) => {\n        var _a;\n        return (_a = a) === null || _a === void 0 ? void 0 : _a.fluidDataStoreId.localeCompare(b.fluidDataStoreId);\n      });\n      for (const fluidDataStoreSnapshot of fluidDataStoreSnapshots) {\n        entries.push(new TreeTreeEntry(fluidDataStoreSnapshot.fluidDataStoreId, fluidDataStoreSnapshot.snapshot));\n      }\n      return entries;\n    })();\n  }\n  summarize(fullTree, trackState) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const gcDataBuilder = new GCDataBuilder();\n      const summaryBuilder = new SummaryTreeBuilder();\n      // Iterate over each store and ask it to snapshot\n      yield Promise.all(Array.from(_this3.contexts).filter(([_, context]) => {\n        // Summarizer works only with clients with no local changes!\n        assert(context.attachState !== AttachState.Attaching);\n        return context.attachState === AttachState.Attached;\n      }).map( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* ([contextId, context]) {\n          const contextSummary = yield context.summarize(fullTree, trackState);\n          summaryBuilder.addWithStats(contextId, contextSummary);\n          // back-compat 0.31 - Older versions will not have GC data in summary.\n          if (contextSummary.gcData !== undefined) {\n            // Prefix the child's id to the ids of its GC nodest. This gradually builds the id of each node to\n            // be a path from the root.\n            gcDataBuilder.prefixAndAddNodes(contextId, contextSummary.gcData.gcNodes);\n          }\n        });\n        return function (_x2) {\n          return _ref3.apply(this, arguments);\n        };\n      }()));\n      // Get the outbound routes and add a GC node for this channel.\n      gcDataBuilder.addNode(\"/\", yield _this3.getOutboundRoutes());\n      return Object.assign(Object.assign({}, summaryBuilder.getSummaryTree()), {\n        gcData: gcDataBuilder.getGCData()\n      });\n    })();\n  }\n  createSummary() {\n    const builder = new SummaryTreeBuilder();\n    // Attaching graph of some stores can cause other stores to get bound too.\n    // So keep taking summary until no new stores get bound.\n    let notBoundContextsLength;\n    do {\n      const builderTree = builder.summary.tree;\n      notBoundContextsLength = this.contexts.notBoundLength();\n      // Iterate over each data store and ask it to snapshot\n      Array.from(this.contexts).filter(([key, _]) =>\n      // Take summary of bounded data stores only, make sure we haven't summarized them already\n      // and no attach op has been fired for that data store because for loader versions <= 0.24\n      // we set attach state as \"attaching\" before taking createNew summary.\n      !(this.contexts.isNotBound(key) || builderTree[key] || this.attachOpFiredForDataStore.has(key))).map(([key, value]) => {\n        let dataStoreSummary;\n        if (value.isLoaded) {\n          const snapshot = value.generateAttachMessage().snapshot;\n          dataStoreSummary = convertToSummaryTree(snapshot, true);\n        } else {\n          // If this data store is not yet loaded, then there should be no changes in the snapshot from\n          // which it was created as it is detached container. So just use the previous snapshot.\n          assert(!!this.baseSnapshot, \"BaseSnapshot should be there as detached container loaded from snapshot\");\n          dataStoreSummary = convertSnapshotTreeToSummaryTree(this.baseSnapshot.trees[key]);\n        }\n        builder.addWithStats(key, dataStoreSummary);\n      });\n    } while (notBoundContextsLength !== this.contexts.notBoundLength());\n    return builder.getSummaryTree();\n  }\n  getGCData() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const builder = new GCDataBuilder();\n      // Iterate over each store and get their GC data.\n      yield Promise.all(Array.from(_this4.contexts).filter(([_, context]) => {\n        // Get GC data only for attached contexts. Detached contexts are not connected in the GC reference\n        // graph so any references they might have won't be connected as well.\n        return context.attachState === AttachState.Attached;\n      }).map( /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* ([contextId, context]) {\n          const contextGCData = yield context.getGCData();\n          // Prefix the child's id to the ids of GC nodes returned by it. This gradually builds the id of\n          // each node to be a path from the root.\n          builder.prefixAndAddNodes(contextId, contextGCData.gcNodes);\n        });\n        return function (_x3) {\n          return _ref4.apply(this, arguments);\n        };\n      }()));\n      // Get the outbound routes and add a GC node for this channel.\n      builder.addNode(\"/\", yield _this4.getOutboundRoutes());\n      return builder.getGCData();\n    })();\n  }\n  /**\n   * After GC has run, called to notify this Container's data stores of routes that are used in it.\n   * @param usedRoutes - The routes that are used in all data stores in this Container.\n   */\n  updateUsedRoutes(usedRoutes) {\n    var _a;\n    // Build a map of data store ids to routes used in it.\n    const usedRoutesMap = new Map();\n    for (const route of usedRoutes) {\n      assert(route.startsWith(\"/\"), \"Used route should always be an absolute route\");\n      const dataStoreId = route.split(\"/\")[1];\n      assert(this.contexts.has(dataStoreId), \"Used route does not belong to any known data store\");\n      const dataStoreRoute = route.slice(dataStoreId.length + 1);\n      const routes = usedRoutesMap.get(dataStoreId);\n      if (routes !== undefined) {\n        routes.push(dataStoreRoute);\n      } else {\n        usedRoutesMap.set(dataStoreId, [dataStoreRoute]);\n      }\n    }\n    // Update the used routes in each data store. Used routes is empty for unused data stores.\n    for (const [contextId, context] of this.contexts) {\n      context.updateUsedRoutes((_a = usedRoutesMap.get(contextId), _a !== null && _a !== void 0 ? _a : []));\n    }\n  }\n  /**\n   * Returns the outbound routes of this channel. Only root data stores are considered referenced and their paths are\n   * part of outbound routes.\n   */\n  getOutboundRoutes() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const outboundRoutes = [];\n      for (const [contextId, context] of _this5.contexts) {\n        const isRootDataStore = yield context.isRoot();\n        if (isRootDataStore) {\n          outboundRoutes.push(`/${contextId}`);\n        }\n      }\n      return outboundRoutes;\n    })();\n  }\n}\nexport function getSnapshotForDataStores(snapshot, snapshotFormatVersion) {\n  if (!snapshot) {\n    return undefined;\n  }\n  if (snapshotFormatVersion !== undefined) {\n    const dataStoresSnapshot = snapshot.trees[channelsTreeName];\n    assert(!!dataStoresSnapshot, `expected ${channelsTreeName} tree in snapshot`);\n    return dataStoresSnapshot;\n  } else {\n    // back-compat: strip out all non-datastore paths before giving to DataStores object.\n    const dataStoresTrees = {};\n    for (const [key, value] of Object.entries(snapshot.trees)) {\n      if (!nonDataStorePaths.includes(key)) {\n        dataStoresTrees[key] = value;\n      }\n    }\n    return Object.assign(Object.assign({}, snapshot), {\n      trees: dataStoresTrees\n    });\n  }\n}\n//# sourceMappingURL=dataStores.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}