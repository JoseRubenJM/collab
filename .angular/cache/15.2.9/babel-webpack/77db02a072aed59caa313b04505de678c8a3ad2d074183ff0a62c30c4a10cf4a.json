{"ast":null,"code":"\"use strict\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar _asyncToGenerator = require(\"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MockSharedObjectServices = exports.MockObjectStorageService = exports.MockEmptyDeltaConnection = exports.MockFluidDataStoreRuntime = exports.MockQuorumClients = exports.MockContainerRuntimeFactory = exports.MockContainerRuntime = exports.MockDeltaConnection = void 0;\nconst events_1 = require(\"events\");\nconst common_utils_1 = require(\"@fluidframework/common-utils\");\nconst container_definitions_1 = require(\"@fluidframework/container-definitions\");\nconst telemetry_utils_1 = require(\"@fluidframework/telemetry-utils\");\nconst protocol_definitions_1 = require(\"@fluidframework/protocol-definitions\");\nconst runtime_utils_1 = require(\"@fluidframework/runtime-utils\");\nconst uuid_1 = require(\"uuid\");\nconst mockDeltas_1 = require(\"./mockDeltas\");\n/**\n * Mock implementation of IDeltaConnection for testing\n */\nclass MockDeltaConnection {\n  constructor(submitFn, dirtyFn) {\n    this.submitFn = submitFn;\n    this.dirtyFn = dirtyFn;\n    this._connected = true;\n  }\n  get connected() {\n    return this._connected;\n  }\n  attach(handler) {\n    this.handler = handler;\n    handler.setConnectionState(this.connected);\n  }\n  submit(messageContent, localOpMetadata) {\n    return this.submitFn(messageContent, localOpMetadata);\n  }\n  dirty() {\n    this.dirtyFn();\n  }\n  setConnectionState(connected) {\n    var _a;\n    this._connected = connected;\n    (_a = this.handler) === null || _a === void 0 ? void 0 : _a.setConnectionState(connected);\n  }\n  process(message, local, localOpMetadata) {\n    var _a;\n    (_a = this.handler) === null || _a === void 0 ? void 0 : _a.process(message, local, localOpMetadata);\n  }\n  reSubmit(content, localOpMetadata) {\n    var _a;\n    (_a = this.handler) === null || _a === void 0 ? void 0 : _a.reSubmit(content, localOpMetadata);\n  }\n}\nexports.MockDeltaConnection = MockDeltaConnection;\n/**\n * Mock implementation of ContainerRuntime for testing basic submitting and processing of messages.\n * If test specific logic is required, extend this class and add the logic there. For an example, take a look\n * at MockContainerRuntimeForReconnection.\n */\nclass MockContainerRuntime {\n  constructor(dataStoreRuntime, factory) {\n    var _a;\n    this.dataStoreRuntime = dataStoreRuntime;\n    this.factory = factory;\n    this.clientSequenceNumber = 0;\n    this.deltaConnections = [];\n    this.pendingMessages = [];\n    this.deltaManager = new mockDeltas_1.MockDeltaManager();\n    // Set FluidDataStoreRuntime's deltaManager to ours so that they are in sync.\n    this.dataStoreRuntime.deltaManager = this.deltaManager;\n    this.dataStoreRuntime.quorum = factory.quorum;\n    // FluidDataStoreRuntime already creates a clientId, reuse that so they are in sync.\n    this.clientId = (_a = this.dataStoreRuntime.clientId) !== null && _a !== void 0 ? _a : (0, uuid_1.v4)();\n    factory.quorum.addMember(this.clientId, {});\n  }\n  createDeltaConnection() {\n    const deltaConnection = new MockDeltaConnection((messageContent, localOpMetadata) => this.submit(messageContent, localOpMetadata), () => this.dirty());\n    this.deltaConnections.push(deltaConnection);\n    return deltaConnection;\n  }\n  submit(messageContent, localOpMetadata) {\n    const clientSequenceNumber = this.clientSequenceNumber++;\n    const msg = {\n      clientId: this.clientId,\n      clientSequenceNumber,\n      contents: messageContent,\n      referenceSequenceNumber: this.deltaManager.lastSequenceNumber,\n      type: protocol_definitions_1.MessageType.Operation\n    };\n    this.factory.pushMessage(msg);\n    this.addPendingMessage(messageContent, localOpMetadata, clientSequenceNumber);\n    return clientSequenceNumber;\n  }\n  dirty() {}\n  process(message) {\n    this.deltaManager.lastSequenceNumber = message.sequenceNumber;\n    this.deltaManager.lastMessage = message;\n    this.deltaManager.minimumSequenceNumber = message.minimumSequenceNumber;\n    const [local, localOpMetadata] = this.processInternal(message);\n    this.deltaConnections.forEach(dc => {\n      dc.process(message, local, localOpMetadata);\n    });\n  }\n  addPendingMessage(content, localOpMetadata, clientSequenceNumber) {\n    const pendingMessage = {\n      content,\n      clientSequenceNumber,\n      localOpMetadata\n    };\n    this.pendingMessages.push(pendingMessage);\n  }\n  processInternal(message) {\n    let localOpMetadata;\n    const local = this.clientId === message.clientId;\n    if (local) {\n      const pendingMessage = this.pendingMessages.shift();\n      (0, common_utils_1.assert)((pendingMessage === null || pendingMessage === void 0 ? void 0 : pendingMessage.clientSequenceNumber) === message.clientSequenceNumber, \"Unexpected client sequence number from message\");\n      localOpMetadata = pendingMessage.localOpMetadata;\n    }\n    return [local, localOpMetadata];\n  }\n}\nexports.MockContainerRuntime = MockContainerRuntime;\n/**\n * Factory to create MockContainerRuntime for testing basic submitting and processing of messages.\n * This also acts as a very basic server that stores the messages from all the MockContainerRuntimes and\n * processes them when asked.\n * If test specific logic is required, extend this class and add the logic there. For an example, take a look\n * at MockContainerRuntimeFactoryForReconnection.\n */\nclass MockContainerRuntimeFactory {\n  constructor() {\n    this.sequenceNumber = 0;\n    this.minSeq = new Map();\n    this.quorum = new MockQuorumClients();\n    /**\n     * The MockContainerRuntimes we produce will push messages into this queue as they are submitted.\n     * This is playing the role of the orderer, establishing a single universal order for the messages generated.\n     * They are held in this queue until we explicitly choose to process them, at which time they are \"broadcast\" to\n     * each of the runtimes.\n     */\n    this.messages = [];\n    this.runtimes = [];\n  }\n  get outstandingMessageCount() {\n    return this.messages.length;\n  }\n  getMinSeq() {\n    let minSeq;\n    for (const [, clientSeq] of this.minSeq) {\n      if (!minSeq) {\n        minSeq = clientSeq;\n      } else {\n        minSeq = Math.min(minSeq, clientSeq);\n      }\n    }\n    return minSeq !== null && minSeq !== void 0 ? minSeq : 0;\n  }\n  createContainerRuntime(dataStoreRuntime) {\n    const containerRuntime = new MockContainerRuntime(dataStoreRuntime, this);\n    this.runtimes.push(containerRuntime);\n    return containerRuntime;\n  }\n  pushMessage(msg) {\n    if (msg.clientId && msg.referenceSequenceNumber !== undefined && !this.minSeq.has(msg.clientId)) {\n      this.minSeq.set(msg.clientId, msg.referenceSequenceNumber);\n    }\n    this.messages.push(msg);\n  }\n  /**\n   * Process one of the queued messages.  Throws if no messages are queued.\n   */\n  processOneMessage() {\n    if (this.messages.length === 0) {\n      throw new Error(\"Tried to process a message that did not exist\");\n    }\n    let msg = this.messages.shift();\n    // Explicitly JSON clone the value to match the behavior of going thru the wire.\n    msg = JSON.parse(JSON.stringify(msg));\n    this.minSeq.set(msg.clientId, msg.referenceSequenceNumber);\n    msg.sequenceNumber = ++this.sequenceNumber;\n    msg.minimumSequenceNumber = this.getMinSeq();\n    for (const runtime of this.runtimes) {\n      runtime.process(msg);\n    }\n  }\n  /**\n   * Process a given number of queued messages.  Throws if there are fewer messages queued than requested.\n   * @param count - the number of messages to process\n   */\n  processSomeMessages(count) {\n    if (count > this.messages.length) {\n      throw new Error(\"Tried to process more messages than exist\");\n    }\n    for (let i = 0; i < count; i++) {\n      this.processOneMessage();\n    }\n  }\n  /**\n   * Process all remaining messages in the queue.\n   */\n  processAllMessages() {\n    while (this.messages.length > 0) {\n      this.processOneMessage();\n    }\n  }\n}\nexports.MockContainerRuntimeFactory = MockContainerRuntimeFactory;\nclass MockQuorumClients {\n  constructor(...members) {\n    var _a;\n    this.eventEmitter = new events_1.EventEmitter();\n    this.disposed = false;\n    this.members = new Map((_a = members) !== null && _a !== void 0 ? _a : []);\n  }\n  addMember(id, client) {\n    this.members.set(id, client);\n    this.eventEmitter.emit(\"addMember\", id, client);\n  }\n  removeMember(id) {\n    if (this.members.delete(id)) {\n      this.eventEmitter.emit(\"removeMember\", id);\n    }\n  }\n  getMembers() {\n    return this.members;\n  }\n  getMember(clientId) {\n    return this.getMembers().get(clientId);\n  }\n  dispose() {\n    throw new Error(\"Method not implemented.\");\n  }\n  addListener(event, listener) {\n    throw new Error(\"Method not implemented.\");\n  }\n  on(event, listener) {\n    switch (event) {\n      case \"afterOn\":\n        this.eventEmitter.on(event, listener);\n        return this;\n      case \"addMember\":\n      case \"removeMember\":\n        this.eventEmitter.on(event, listener);\n        this.eventEmitter.emit(\"afterOn\", event);\n        return this;\n      default:\n        throw new Error(\"Method not implemented.\");\n    }\n  }\n  once(event, listener) {\n    throw new Error(\"Method not implemented.\");\n  }\n  prependListener(event, listener) {\n    throw new Error(\"Method not implemented.\");\n  }\n  prependOnceListener(event, listener) {\n    throw new Error(\"Method not implemented.\");\n  }\n  removeListener(event, listener) {\n    this.eventEmitter.removeListener(event, listener);\n    return this;\n  }\n  off(event, listener) {\n    this.eventEmitter.off(event, listener);\n    return this;\n  }\n  removeAllListeners(event) {\n    throw new Error(\"Method not implemented.\");\n  }\n  setMaxListeners(n) {\n    throw new Error(\"Method not implemented.\");\n  }\n  getMaxListeners() {\n    throw new Error(\"Method not implemented.\");\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  listeners(event) {\n    throw new Error(\"Method not implemented.\");\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  rawListeners(event) {\n    throw new Error(\"Method not implemented.\");\n  }\n  emit(event, ...args) {\n    throw new Error(\"Method not implemented.\");\n  }\n  eventNames() {\n    throw new Error(\"Method not implemented.\");\n  }\n  listenerCount(type) {\n    throw new Error(\"Method not implemented.\");\n  }\n}\nexports.MockQuorumClients = MockQuorumClients;\n/**\n * Mock implementation of IRuntime for testing that does nothing\n */\nclass MockFluidDataStoreRuntime extends events_1.EventEmitter {\n  constructor() {\n    super(...arguments);\n    this.documentId = undefined;\n    this.id = (0, uuid_1.v4)();\n    this.existing = undefined;\n    this.options = {};\n    this.clientId = (0, uuid_1.v4)();\n    this.path = \"\";\n    this.connected = true;\n    this.deltaManager = new mockDeltas_1.MockDeltaManager();\n    this.loader = undefined;\n    this.logger = telemetry_utils_1.DebugLogger.create(\"fluid:MockFluidDataStoreRuntime\");\n    this.quorum = new MockQuorumClients();\n    this._local = false;\n    this._disposed = false;\n  }\n  get IFluidHandleContext() {\n    return this;\n  }\n  get rootRoutingContext() {\n    return this;\n  }\n  get channelsRoutingContext() {\n    return this;\n  }\n  get objectsRoutingContext() {\n    return this;\n  }\n  get IFluidRouter() {\n    return this;\n  }\n  get absolutePath() {\n    return `/${this.id}`;\n  }\n  get local() {\n    return this._local;\n  }\n  set local(local) {\n    this._local = local;\n  }\n  get disposed() {\n    return this._disposed;\n  }\n  dispose() {\n    this._disposed = true;\n  }\n  getChannel(id) {\n    return _asyncToGenerator(function* () {\n      return null;\n    })();\n  }\n  createChannel(id, type) {\n    return null;\n  }\n  get isAttached() {\n    return !this.local;\n  }\n  get attachState() {\n    return this.local ? container_definitions_1.AttachState.Detached : container_definitions_1.AttachState.Attached;\n  }\n  bindChannel(channel) {\n    return;\n  }\n  attachGraph() {\n    return;\n  }\n  bindToContext() {\n    return;\n  }\n  bind(handle) {\n    return;\n  }\n  getQuorum() {\n    return this.quorum;\n  }\n  getAudience() {\n    return null;\n  }\n  save(message) {\n    return;\n  }\n  close() {\n    return _asyncToGenerator(function* () {\n      return;\n    })();\n  }\n  uploadBlob(blob) {\n    return _asyncToGenerator(function* () {\n      return null;\n    })();\n  }\n  getBlob(blobId) {\n    return _asyncToGenerator(function* () {\n      return null;\n    })();\n  }\n  submitMessage(type, content) {\n    return null;\n  }\n  submitSignal(type, content) {\n    return null;\n  }\n  process(message, local) {\n    return;\n  }\n  processSignal(message, local) {\n    return;\n  }\n  updateMinSequenceNumber(value) {\n    return;\n  }\n  setConnectionState(connected, clientId) {\n    return;\n  }\n  resolveHandle(request) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.request(request);\n    })();\n  }\n  request(request) {\n    return _asyncToGenerator(function* () {\n      return null;\n    })();\n  }\n  addedGCOutboundReference(srcHandle, outboundHandle) {}\n  summarize(fullTree, trackState) {\n    return _asyncToGenerator(function* () {\n      const stats = (0, runtime_utils_1.mergeStats)();\n      stats.treeNodeCount++;\n      return {\n        summary: {\n          type: protocol_definitions_1.SummaryType.Tree,\n          tree: {}\n        },\n        stats\n      };\n    })();\n  }\n  getGCData() {\n    return _asyncToGenerator(function* () {\n      return {\n        gcNodes: {}\n      };\n    })();\n  }\n  updateUsedRoutes(usedRoutes, gcTimestamp) {}\n  getAttachSnapshot() {\n    return [];\n  }\n  getAttachSummary() {\n    const stats = (0, runtime_utils_1.mergeStats)();\n    stats.treeNodeCount++;\n    return {\n      summary: {\n        type: protocol_definitions_1.SummaryType.Tree,\n        tree: {}\n      },\n      stats\n    };\n  }\n  setAttachState(attachState) {\n    return;\n  }\n  waitAttached() {\n    return _asyncToGenerator(function* () {\n      return;\n    })();\n  }\n  requestDataStore(request) {\n    return _asyncToGenerator(function* () {\n      return null;\n    })();\n  }\n  reSubmit(content, localOpMetadata) {\n    return;\n  }\n  applyStashedOp(content) {\n    return _asyncToGenerator(function* () {\n      return;\n    })();\n  }\n  rollback(message, localOpMetadata) {\n    return;\n  }\n}\nexports.MockFluidDataStoreRuntime = MockFluidDataStoreRuntime;\n/**\n * Mock implementation of IDeltaConnection\n */\nclass MockEmptyDeltaConnection {\n  constructor() {\n    this.connected = false;\n  }\n  attach(handler) {}\n  submit(messageContent) {\n    (0, common_utils_1.assert)(false, \"Throw submit error on mock empty delta connection\");\n    return 0;\n  }\n  dirty() {}\n}\nexports.MockEmptyDeltaConnection = MockEmptyDeltaConnection;\n/**\n * Mock implementation of IChannelStorageService\n */\nclass MockObjectStorageService {\n  constructor(contents) {\n    this.contents = contents;\n  }\n  readBlob(path) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return (0, common_utils_1.stringToBuffer)(_this2.contents[path], \"utf8\");\n    })();\n  }\n  contains(path) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      return _this3.contents[path] !== undefined;\n    })();\n  }\n  list(path) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const pathPartsLength = (0, runtime_utils_1.getNormalizedObjectStoragePathParts)(path).length;\n      return Object.keys(_this4.contents).filter(key => key.startsWith(path) && key.split(\"/\").length === pathPartsLength + 1);\n    })();\n  }\n}\nexports.MockObjectStorageService = MockObjectStorageService;\n/**\n * Mock implementation of IChannelServices\n */\nclass MockSharedObjectServices {\n  constructor(contents) {\n    this.deltaConnection = new MockEmptyDeltaConnection();\n    this.objectStorage = new MockObjectStorageService(contents);\n  }\n  static createFromSummary(summaryTree) {\n    const contents = {};\n    for (const [key, value] of Object.entries(summaryTree.tree)) {\n      (0, common_utils_1.assert)(value.type === protocol_definitions_1.SummaryType.Blob, \"Unexpected summary type on mock createFromSummary\");\n      contents[key] = value.content;\n    }\n    return new MockSharedObjectServices(contents);\n  }\n}\nexports.MockSharedObjectServices = MockSharedObjectServices;\n//# sourceMappingURL=mocks.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}