{"ast":null,"code":"import { SnapshotLegacy } from \"./snapshotlegacy\";\n/**\n * Returns true if the given 'spec' is an IJSONSegmentWithMergeInfo.\n */\nexport function hasMergeInfo(spec) {\n  return !!spec && typeof spec === \"object\" && \"json\" in spec;\n}\nexport function serializeAsMinSupportedVersion(path, chunk, logger, options, serializer, bind) {\n  var _a, _b, _c, _d;\n  let targetChuck;\n  if (chunk.version !== undefined) {\n    logger.send({\n      eventName: \"MergeTreeChunk:serializeAsMinSupportedVersion\",\n      category: \"generic\",\n      fromChunkVersion: chunk.version,\n      toChunkVersion: undefined\n    });\n  }\n  switch (chunk.version) {\n    case undefined:\n      targetChuck = chunk;\n      targetChuck.headerMetadata = buildHeaderMetadataForLegecyChunk(path, targetChuck, options);\n      break;\n    case \"1\":\n      const chunkV1 = chunk;\n      const headerMetadata = path === SnapshotLegacy.header ? chunkV1.headerMetadata : undefined;\n      targetChuck = {\n        version: undefined,\n        chunkStartSegmentIndex: chunkV1.startIndex,\n        chunkLengthChars: chunkV1.length,\n        chunkSegmentCount: chunkV1.segmentCount,\n        segmentTexts: chunkV1.segments,\n        totalLengthChars: (_a = headerMetadata) === null || _a === void 0 ? void 0 : _a.totalLength,\n        totalSegmentCount: (_b = headerMetadata) === null || _b === void 0 ? void 0 : _b.totalSegmentCount,\n        chunkSequenceNumber: (_c = headerMetadata) === null || _c === void 0 ? void 0 : _c.sequenceNumber,\n        chunkMinSequenceNumber: (_d = headerMetadata) === null || _d === void 0 ? void 0 : _d.minSequenceNumber,\n        headerMetadata\n      };\n      break;\n    default:\n      throw new Error(`Unsupported chunk path: ${path} version: ${chunk.version}`);\n  }\n  return serializer.stringify(targetChuck, bind);\n}\nexport function serializeAsMaxSupportedVersion(path, chunk, logger, options, serializer, bind) {\n  const targetChuck = toLatestVersion(path, chunk, logger, options);\n  return serializer.stringify(targetChuck, bind);\n}\nexport function toLatestVersion(path, chunk, logger, options) {\n  switch (chunk.version) {\n    case undefined:\n      {\n        const chunkLegacy = chunk;\n        return {\n          version: \"1\",\n          length: chunkLegacy.chunkLengthChars,\n          segmentCount: chunkLegacy.chunkSegmentCount,\n          headerMetadata: buildHeaderMetadataForLegecyChunk(path, chunkLegacy, options),\n          segments: chunkLegacy.segmentTexts,\n          startIndex: chunkLegacy.chunkStartSegmentIndex\n        };\n      }\n    case \"1\":\n      return chunk;\n    default:\n      throw new Error(`Unsupported chunk path: ${path} version: ${chunk.version}`);\n  }\n}\nfunction buildHeaderMetadataForLegecyChunk(path, chunk, options) {\n  if (path === SnapshotLegacy.header) {\n    if (chunk.headerMetadata !== undefined) {\n      return chunk.headerMetadata;\n    }\n    const chunkIds = [{\n      id: SnapshotLegacy.header\n    }];\n    if (chunk.chunkLengthChars < chunk.totalLengthChars) {\n      chunkIds.push({\n        id: SnapshotLegacy.body\n      });\n    }\n    return {\n      orderedChunkMetadata: chunkIds,\n      minSequenceNumber: chunk.chunkMinSequenceNumber,\n      sequenceNumber: chunk.chunkSequenceNumber,\n      totalLength: chunk.totalLengthChars,\n      totalSegmentCount: chunk.totalSegmentCount\n    };\n  }\n  return undefined;\n}\n//# sourceMappingURL=snapshotChunks.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}