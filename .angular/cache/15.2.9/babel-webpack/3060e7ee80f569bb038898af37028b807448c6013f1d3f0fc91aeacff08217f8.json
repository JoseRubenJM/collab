{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport assert from \"assert\";\nimport { buildHierarchy } from \"@fluidframework/protocol-base\";\nimport * as api from \"@fluidframework/protocol-definitions\";\nimport { debug } from \"./debug\";\nexport class GitManager {\n  constructor(historian) {\n    this.historian = historian;\n    this.blobCache = new Map();\n    this.commitCache = new Map();\n    this.treeCache = new Map();\n    this.refCache = new Map();\n  }\n  getHeader(id, sha) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const header = yield _this.historian.getHeader(sha);\n      // Cache blobs that were sent in the header\n      for (const blob of header.blobs) {\n        _this.blobCache.set(blob.sha, blob);\n      }\n      return buildHierarchy(header.tree);\n    })();\n  }\n  getFullTree(sha) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return _this2.historian.getFullTree(sha);\n    })();\n  }\n  getCommit(sha) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (_this3.commitCache.has(sha)) {\n        debug(`Cache hit on ${sha}`);\n        return _this3.commitCache.get(sha);\n      }\n      return _this3.historian.getCommit(sha);\n    })();\n  }\n  /**\n   * Reads the object with the given ID. We defer to the client implementation to do the actual read.\n   */\n  getCommits(shaOrRef, count) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      let sha = shaOrRef;\n      // See if the sha is really a ref and convert\n      if (_this4.refCache.has(shaOrRef)) {\n        debug(`Commit cache hit on ${shaOrRef}`);\n        sha = _this4.refCache.get(shaOrRef);\n        // Delete refcache after first use\n        _this4.refCache.delete(shaOrRef);\n        // If null is stored for the ref then there are no commits - return an empty array\n        if (!sha) {\n          return [];\n        }\n      }\n      // See if the commit sha is hashed and return it if so\n      if (_this4.commitCache.has(sha)) {\n        const commit = _this4.commitCache.get(sha);\n        return [{\n          commit: {\n            author: commit.author,\n            committer: commit.committer,\n            message: commit.message,\n            tree: commit.tree,\n            url: commit.url\n          },\n          parents: commit.parents,\n          sha: commit.sha,\n          url: commit.url\n        }];\n      }\n      // Otherwise fall back to the historian\n      return _this4.historian.getCommits(sha, count);\n    })();\n  }\n  /**\n   * Reads the object with the given ID. We defer to the client implementation to do the actual read.\n   */\n  getTree(root, recursive = true) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      if (_this5.treeCache.has(root)) {\n        debug(`Tree cache hit on ${root}`);\n        return _this5.treeCache.get(root);\n      }\n      return _this5.historian.getTree(root, recursive);\n    })();\n  }\n  getBlob(sha) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      if (_this6.blobCache.has(sha)) {\n        debug(`Blob cache hit on ${sha}`);\n        return _this6.blobCache.get(sha);\n      }\n      return _this6.historian.getBlob(sha);\n    })();\n  }\n  getRawUrl(sha) {\n    return `${this.historian.endpoint}/git/blobs/raw/${sha}`;\n  }\n  /**\n   * Retrieves the object at the given revision number\n   */\n  /* eslint-disable @typescript-eslint/promise-function-async */\n  getContent(commit, path) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return this.historian.getContent(path, commit);\n  }\n  createBlob(content, encoding) {\n    const blob = {\n      content,\n      encoding\n    };\n    return this.historian.createBlob(blob);\n  }\n  createGitTree(params) {\n    const treeP = this.historian.createTree(params);\n    return treeP;\n  }\n  createTree(files) {\n    return this.createTreeCore(files, 0);\n  }\n  /* eslint-enable @typescript-eslint/promise-function-async */\n  createCommit(commit) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      return _this7.historian.createCommit(commit);\n    })();\n  }\n  getRef(ref) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      return _this8.historian.getRef(`heads/${ref}`)\n      // eslint-disable-next-line @typescript-eslint/promise-function-async\n      .catch(error => {\n        if (error === 400 || error === 404) {\n          // eslint-disable-next-line no-null/no-null\n          return null;\n        } else {\n          return Promise.reject(error);\n        }\n      });\n    })();\n  }\n  createRef(branch, sha) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const createRefParams = {\n        ref: `refs/heads/${branch}`,\n        sha,\n        config: {\n          enabled: true\n        }\n      };\n      return _this9.historian.createRef(createRefParams);\n    })();\n  }\n  upsertRef(branch, commitSha) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      // Update (force) the ref to the new commit\n      const ref = {\n        force: true,\n        sha: commitSha,\n        config: {\n          enabled: true\n        }\n      };\n      return _this10.historian.updateRef(`heads/${branch}`, ref);\n    })();\n  }\n  addRef(ref, sha) {\n    this.refCache.set(ref, sha);\n  }\n  addCommit(commit) {\n    this.commitCache.set(commit.sha, commit);\n  }\n  addTree(tree) {\n    this.treeCache.set(tree.sha, tree);\n  }\n  addBlob(blob) {\n    this.blobCache.set(blob.sha, blob);\n  }\n  /**\n   * Writes to the object with the given ID\n   */\n  write(branch, inputTree, parents, message) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const tree = yield _this11.createTree(inputTree);\n      // Construct a commit for the tree\n      const commitParams = {\n        author: {\n          date: new Date().toISOString(),\n          email: \"kurtb@microsoft.com\",\n          name: \"Kurt Berglund\"\n        },\n        message,\n        parents,\n        tree: tree.sha\n      };\n      const commit = yield _this11.historian.createCommit(commitParams);\n      // Create or update depending on if ref exists.\n      // TODO optimize the update to know up front if the ref exists\n      const existingRef = yield _this11.getRef(branch);\n      if (existingRef) {\n        yield _this11.upsertRef(branch, commit.sha);\n      } else {\n        yield _this11.createRef(branch, commit.sha);\n      }\n      return commit;\n    })();\n  }\n  createTreeCore(files, depth) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      // If a id is specified use it rather than creating new\n      if (files.id) {\n        return _this12.getTree(files.id);\n      }\n      // Kick off the work to create all the tree values\n      const entriesP = [];\n      for (const entry of files.entries) {\n        /* eslint-disable no-case-declarations */\n        switch (api.TreeEntry[entry.type]) {\n          case api.TreeEntry.Blob:\n            const entryAsBlob = entry.value;\n            // Symlinks currently directly references a folder off the root of the tree. We adjust\n            // the path based on the depth of the tree\n            if (entry.mode === api.FileMode.Symlink) {\n              entryAsBlob.contents = _this12.translateSymlink(entryAsBlob.contents, depth);\n            }\n            const blobP = _this12.createBlob(entryAsBlob.contents, entryAsBlob.encoding);\n            entriesP.push(blobP);\n            break;\n          case api.TreeEntry.Tree:\n            const entryAsTree = entry.value;\n            const treeBlobP = _this12.createTreeCore(entryAsTree, depth + 1);\n            entriesP.push(treeBlobP);\n            break;\n          case api.TreeEntry.Commit:\n            entriesP.push(Promise.resolve({\n              sha: entry.value,\n              url: \"\"\n            }));\n            break;\n          default:\n            return Promise.reject(new Error(\"Unknown entry type\"));\n        }\n        /* eslint-enable no-case-declarations */\n      }\n      // Wait for them all to resolve\n      const entries = yield Promise.all(entriesP);\n      const tree = [];\n      assert(entries.length === files.entries.length);\n      // Construct a new tree from the collection of hashes\n      for (let i = 0; i < files.entries.length; i++) {\n        const type = files.entries[i].type === api.TreeEntry.Tree ? \"tree\" : files.entries[i].type === api.TreeEntry.Blob ? \"blob\" : \"commit\";\n        tree.push({\n          mode: files.entries[i].mode,\n          path: files.entries[i].path,\n          sha: entries[i].sha,\n          type\n        });\n      }\n      const requestBody = {\n        tree\n      };\n      const treeP = _this12.historian.createTree(requestBody);\n      return treeP;\n    })();\n  }\n  translateSymlink(link, depth) {\n    let prefix = \"\";\n    for (let i = 0; i <= depth; i++) {\n      prefix += \"../\";\n    }\n    return `${prefix}${link}`;\n  }\n}\n//# sourceMappingURL=gitManager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}