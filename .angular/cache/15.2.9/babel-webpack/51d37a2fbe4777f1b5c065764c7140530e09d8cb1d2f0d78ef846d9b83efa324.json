{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, Deferred, Lazy } from \"@fluidframework/common-utils\";\nimport { ChildLogger } from \"@fluidframework/telemetry-utils\";\nexport class DataStoreContexts {\n  constructor(baseLogger) {\n    this.notBoundContexts = new Set();\n    /** Attached and loaded context proxies */\n    this._contexts = new Map();\n    /**\n     * List of pending context waiting either to be bound or to arrive from another client.\n     * This covers the case where a local context has been created but not yet bound,\n     * or the case where a client knows a store will exist and is waiting on its creation,\n     * so that a caller may await the deferred's promise until such a time as the context is fully ready.\n     * This is a superset of _contexts, since contexts remain here once the Deferred resolves.\n     */\n    this.deferredContexts = new Map();\n    this.disposeOnce = new Lazy(() => {\n      // close/stop all store contexts\n      for (const [fluidDataStoreId, contextD] of this.deferredContexts) {\n        contextD.promise.then(context => {\n          context.dispose();\n        }).catch(contextError => {\n          this._logger.sendErrorEvent({\n            eventName: \"FluidDataStoreContextDisposeError\",\n            fluidDataStoreId\n          }, contextError);\n        });\n      }\n    });\n    this.dispose = () => this.disposeOnce.value;\n    this._logger = ChildLogger.create(baseLogger);\n  }\n  [Symbol.iterator]() {\n    return this._contexts.entries();\n  }\n  get size() {\n    return this._contexts.size;\n  }\n  get disposed() {\n    return this.disposeOnce.evaluated;\n  }\n  notBoundLength() {\n    return this.notBoundContexts.size;\n  }\n  isNotBound(id) {\n    return this.notBoundContexts.has(id);\n  }\n  has(id) {\n    return this._contexts.has(id);\n  }\n  get(id) {\n    return this._contexts.get(id);\n  }\n  delete(id) {\n    this.deferredContexts.delete(id);\n    this.notBoundContexts.delete(id);\n    return this._contexts.delete(id);\n  }\n  /**\n   * Return the unbound local context with the given id,\n   * or undefined if it's not found or not unbound.\n   */\n  getUnbound(id) {\n    const context = this._contexts.get(id);\n    if (context === undefined || !this.notBoundContexts.has(id)) {\n      return undefined;\n    }\n    return this._contexts.get(id);\n  }\n  /**\n   * Add the given context, marking it as to-be-bound\n   */\n  addUnbound(context) {\n    const id = context.id;\n    assert(!this._contexts.has(id), 0x158 /* \"Creating store with existing ID\" */);\n    this._contexts.set(id, context);\n    this.notBoundContexts.add(id);\n    this.ensureDeferred(id);\n  }\n  /**\n   * Get the context with the given id, once it exists locally and is attached.\n   * e.g. If created locally, it must be bound, or if created remotely then it's fine as soon as it's sync'd in.\n   * @param id - The id of the context to get\n   * @param wait - If false, return undefined if the context isn't present and ready now. Otherwise, wait for it.\n   */\n  getBoundOrRemoted(id, wait) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const deferredContext = _this.ensureDeferred(id);\n      if (!wait && !deferredContext.isCompleted) {\n        return undefined;\n      }\n      return deferredContext.promise;\n    })();\n  }\n  ensureDeferred(id) {\n    const deferred = this.deferredContexts.get(id);\n    if (deferred) {\n      return deferred;\n    }\n    const newDeferred = new Deferred();\n    this.deferredContexts.set(id, newDeferred);\n    return newDeferred;\n  }\n  /**\n   * Update this context as bound\n   */\n  bind(id) {\n    const removed = this.notBoundContexts.delete(id);\n    assert(removed, 0x159 /* \"The given id was not found in notBoundContexts to delete\" */);\n    this.resolveDeferred(id);\n  }\n  /**\n   * Triggers the deferred to resolve, indicating the context is not local-only\n   * @param id - The id of the context to resolve to\n   */\n  resolveDeferred(id) {\n    const context = this._contexts.get(id);\n    assert(!!context, 0x15a /* \"Cannot find context to resolve to\" */);\n    assert(!this.notBoundContexts.has(id), 0x15b /* \"Expected this id to already be removed from notBoundContexts\" */);\n    const deferred = this.deferredContexts.get(id);\n    assert(!!deferred, 0x15c /* \"Cannot find deferred to resolve\" */);\n    deferred.resolve(context);\n  }\n  /**\n   * Add the given context, marking it as not local-only.\n   * This could be because it's a local context that's been bound, or because it's a remote context.\n   * @param context - The context to add\n   */\n  addBoundOrRemoted(context) {\n    const id = context.id;\n    assert(!this._contexts.has(id), 0x15d /* \"Creating store with existing ID\" */);\n    this._contexts.set(id, context);\n    // Resolve the deferred immediately since this context is not unbound\n    this.ensureDeferred(id);\n    this.resolveDeferred(id);\n  }\n}\n//# sourceMappingURL=dataStoreContexts.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}