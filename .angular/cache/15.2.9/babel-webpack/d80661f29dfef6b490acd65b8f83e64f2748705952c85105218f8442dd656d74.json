{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { BindState, AttachState } from \"@fluidframework/container-definitions\";\nimport { assert, Deferred, LazyPromise, TypedEventEmitter, unreachableCase } from \"@fluidframework/common-utils\";\nimport { readAndParse } from \"@fluidframework/driver-utils\";\nimport { BlobTreeEntry } from \"@fluidframework/protocol-base\";\nimport { channelsTreeName, gcBlobKey } from \"@fluidframework/runtime-definitions\";\nimport { addBlobToSummary, convertSummaryTreeToITree } from \"@fluidframework/runtime-utils\";\nimport { dataStoreAttributesBlobName } from \"./snapshot\";\nfunction createAttributes(pkg, isRootDataStore) {\n  const stringifiedPkg = JSON.stringify(pkg);\n  return {\n    pkg: stringifiedPkg,\n    snapshotFormatVersion: \"0.1\",\n    isRootDataStore\n  };\n}\nexport function createAttributesBlob(pkg, isRootDataStore) {\n  const attributes = createAttributes(pkg, isRootDataStore);\n  return new BlobTreeEntry(dataStoreAttributesBlobName, JSON.stringify(attributes));\n}\n/**\n * Represents the context for the store. This context is passed to the store runtime.\n */\nexport class FluidDataStoreContext extends TypedEventEmitter {\n  constructor(_containerRuntime, id, existing, storage, scope, createSummarizerNode, bindState, isLocalDataStore, bindChannel, pkg) {\n    var _this;\n    super();\n    _this = this;\n    this._containerRuntime = _containerRuntime;\n    this.id = id;\n    this.existing = existing;\n    this.storage = storage;\n    this.scope = scope;\n    this.bindState = bindState;\n    this.isLocalDataStore = isLocalDataStore;\n    this.pkg = pkg;\n    this._disposed = false;\n    this.detachedRuntimeCreation = false;\n    this.loaded = false;\n    this.pending = [];\n    /**\n        @deprecated Dummy summary tracker for back compat\n        Should be remove in 0.31 and #3243 closed\n    */\n    this.summaryTracker = {\n      createOrGetChild: (key, sequenceNumber) => ({\n        updateLatestSequenceNumber: latestSequenceNumber => {}\n      })\n    };\n    // URIs use slashes as delimiters. Handles use URIs.\n    // Thus having slashes in types almost guarantees trouble down the road!\n    assert(id.indexOf(\"/\") === -1, `Data store ID contains slash: ${id}`);\n    this._attachState = this.containerRuntime.attachState !== AttachState.Detached && existing ? this.containerRuntime.attachState : AttachState.Detached;\n    this.bindToContext = () => {\n      assert(this.bindState === BindState.NotBound);\n      this.bindState = BindState.Binding;\n      assert(this.channel !== undefined);\n      bindChannel(this.channel);\n      this.bindState = BindState.Bound;\n    };\n    const thisSummarizeInternal = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (fullTree, trackState) {\n        return _this.summarizeInternal(fullTree, trackState);\n      });\n      return function thisSummarizeInternal(_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    // Add self route (empty string) to used routes in the summarizer node. If GC is enabled, the used routes will\n    // be updated as per the GC data.\n    this.summarizerNode = createSummarizerNode(thisSummarizeInternal, /*#__PURE__*/_asyncToGenerator(function* () {\n      return _this.getGCDataInternal();\n    }), /*#__PURE__*/_asyncToGenerator(function* () {\n      return _this.getInitialGCSummaryDetails();\n    }), [\"\"] /* usedRoutes */);\n  }\n\n  get documentId() {\n    return this._containerRuntime.id;\n  }\n  get packagePath() {\n    assert(this.pkg !== undefined);\n    return this.pkg;\n  }\n  get options() {\n    return this._containerRuntime.options;\n  }\n  get clientId() {\n    return this._containerRuntime.clientId;\n  }\n  get deltaManager() {\n    return this._containerRuntime.deltaManager;\n  }\n  get connected() {\n    return this._containerRuntime.connected;\n  }\n  get leader() {\n    return this._containerRuntime.leader;\n  }\n  get snapshotFn() {\n    return this._containerRuntime.snapshotFn;\n  }\n  get branch() {\n    return this._containerRuntime.branch;\n  }\n  get loader() {\n    return this._containerRuntime.loader;\n  }\n  get containerRuntime() {\n    return this._containerRuntime;\n  }\n  get isLoaded() {\n    return this.loaded;\n  }\n  /**\n   * @deprecated 0.17 Issue #1888 Rename IHostRuntime to IContainerRuntime and refactor usages\n   * Use containerRuntime instead of hostRuntime\n   */\n  get hostRuntime() {\n    return this._containerRuntime;\n  }\n  get baseSnapshot() {\n    return this._baseSnapshot;\n  }\n  get disposed() {\n    return this._disposed;\n  }\n  get attachState() {\n    return this._attachState;\n  }\n  get IFluidDataStoreRegistry() {\n    return this.registry;\n  }\n  isRoot() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return (yield _this2.getInitialSnapshotDetails()).isRootDataStore;\n    })();\n  }\n  dispose() {\n    if (this._disposed) {\n      return;\n    }\n    this._disposed = true;\n    // Dispose any pending runtime after it gets fulfilled\n    if (this.channelDeferred) {\n      this.channelDeferred.promise.then(runtime => {\n        runtime.dispose();\n      }).catch(error => {\n        this._containerRuntime.logger.sendErrorEvent({\n          eventName: \"ChannelDisposeError\",\n          fluidDataStoreId: this.id\n        }, error);\n      });\n    }\n  }\n  rejectDeferredRealize(reason) {\n    const error = new Error(reason);\n    // Error messages contain package names that is considered Personal Identifiable Information\n    // Mark it as such, so that if it ever reaches telemetry pipeline, it has a chance to remove it.\n    error.containsPII = true;\n    throw error;\n  }\n  realize() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      assert(!_this3.detachedRuntimeCreation);\n      if (!_this3.channelDeferred) {\n        _this3.channelDeferred = new Deferred();\n        _this3.realizeCore().catch(error => {\n          var _a;\n          (_a = _this3.channelDeferred) === null || _a === void 0 ? void 0 : _a.reject(error);\n        });\n      }\n      return _this3.channelDeferred.promise;\n    })();\n  }\n  factoryFromPackagePath(packages) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      assert(_this4.pkg === packages);\n      let entry;\n      let registry = _this4._containerRuntime.IFluidDataStoreRegistry;\n      let lastPkg;\n      for (const pkg of packages) {\n        if (!registry) {\n          _this4.rejectDeferredRealize(`No registry for ${lastPkg} package`);\n        }\n        lastPkg = pkg;\n        entry = yield registry.get(pkg);\n        if (!entry) {\n          _this4.rejectDeferredRealize(`Registry does not contain entry for the package ${pkg}`);\n        }\n        registry = entry.IFluidDataStoreRegistry;\n      }\n      const factory = (_a = entry) === null || _a === void 0 ? void 0 : _a.IFluidDataStoreFactory;\n      if (factory === undefined) {\n        _this4.rejectDeferredRealize(`Can't find factory for ${lastPkg} package`);\n      }\n      return {\n        factory,\n        registry\n      };\n    })();\n  }\n  realizeCore() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const details = yield _this5.getInitialSnapshotDetails();\n      // Base snapshot is the baseline where pending ops are applied to.\n      // It is important that this be in sync with the pending ops, and also\n      // that it is set here, before bindRuntime is called.\n      _this5._baseSnapshot = details.snapshot;\n      const packages = details.pkg;\n      const {\n        factory,\n        registry\n      } = yield _this5.factoryFromPackagePath(packages);\n      assert(_this5.registry === undefined);\n      _this5.registry = registry;\n      const channel = yield factory.instantiateDataStore(_this5);\n      assert(channel !== undefined);\n      _this5.bindRuntime(channel);\n    })();\n  }\n  /**\n   * Notifies this object about changes in the connection state.\n   * @param value - New connection state.\n   * @param clientId - ID of the client. It's old ID when in disconnected state and\n   * it's new client ID when we are connecting or connected.\n   */\n  setConnectionState(connected, clientId) {\n    this.verifyNotClosed();\n    // Connection events are ignored if the store is not yet loaded\n    if (!this.loaded) {\n      return;\n    }\n    assert(this.connected === connected);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.channel.setConnectionState(connected, clientId);\n  }\n  process(messageArg, local, localOpMetadata) {\n    var _a, _b;\n    this.verifyNotClosed();\n    const innerContents = messageArg.contents;\n    const message = Object.assign(Object.assign({}, messageArg), {\n      type: innerContents.type,\n      contents: innerContents.content\n    });\n    this.summarizerNode.recordChange(message);\n    if (this.loaded) {\n      return (_a = this.channel) === null || _a === void 0 ? void 0 : _a.process(message, local, localOpMetadata);\n    } else {\n      assert(!local, \"local store channel is not loaded\");\n      (_b = this.pending) === null || _b === void 0 ? void 0 : _b.push(message);\n    }\n  }\n  processSignal(message, local) {\n    var _a;\n    this.verifyNotClosed();\n    // Signals are ignored if the store is not yet loaded\n    if (!this.loaded) {\n      return;\n    }\n    (_a = this.channel) === null || _a === void 0 ? void 0 : _a.processSignal(message, local);\n  }\n  getQuorum() {\n    return this._containerRuntime.getQuorum();\n  }\n  getAudience() {\n    return this._containerRuntime.getAudience();\n  }\n  /**\n   * Returns a summary at the current sequence number.\n   * @param fullTree - true to bypass optimizations and force a full summary tree\n   * @param trackState - This tells whether we should track state from this summary.\n   */\n  summarize(fullTree = false, trackState = true) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      return _this6.summarizerNode.summarize(fullTree, trackState);\n    })();\n  }\n  summarizeInternal(fullTree, trackState) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      yield _this7.realize();\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const summarizeResult = yield _this7.channel.summarize(fullTree, trackState);\n      // Add data store's attributes to the summary.\n      const {\n        pkg,\n        isRootDataStore\n      } = yield _this7.getInitialSnapshotDetails();\n      const attributes = createAttributes(pkg, isRootDataStore);\n      addBlobToSummary(summarizeResult, dataStoreAttributesBlobName, JSON.stringify(attributes));\n      // Add GC details to the summary.\n      const gcDetails = {\n        usedRoutes: _this7.summarizerNode.usedRoutes,\n        gcData: summarizeResult.gcData\n      };\n      addBlobToSummary(summarizeResult, gcBlobKey, JSON.stringify(gcDetails));\n      return Object.assign(Object.assign({}, summarizeResult), {\n        id: _this7.id\n      });\n    })();\n  }\n  getGCData() {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      return _this8.summarizerNode.getGCData();\n    })();\n  }\n  getGCDataInternal() {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      yield _this9.realize();\n      assert(_this9.channel !== undefined, \"Channel should not be undefined when running GC\");\n      // back-compat - 0.31. Older data store runtimes will not have getGCData API.\n      if (_this9.channel.getGCData === undefined) {\n        return {\n          gcNodes: {}\n        };\n      }\n      return _this9.channel.getGCData();\n    })();\n  }\n  /**\n   * After GC has run, called to notify this data store of routes that are used in it.\n   * @param usedRoutes - The routes that are used in this data store.\n   */\n  updateUsedRoutes(usedRoutes) {\n    // Currently, only data stores can be collected. Once we have GC at DDS layer, the DDS' in the data store will\n    // also be notified of their used routes. See - https://github.com/microsoft/FluidFramework/issues/4611\n    // Update the used routes in this data store's summarizer node.\n    this.summarizerNode.usedRoutes = usedRoutes;\n  }\n  /**\n   * @deprecated 0.18.Should call request on the runtime directly\n   */\n  request(request) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const runtime = yield _this10.realize();\n      return runtime.request(request);\n    })();\n  }\n  submitMessage(type, content, localOpMetadata) {\n    this.verifyNotClosed();\n    assert(!!this.channel);\n    const fluidDataStoreContent = {\n      content,\n      type\n    };\n    this._containerRuntime.submitDataStoreOp(this.id, fluidDataStoreContent, localOpMetadata);\n  }\n  /**\n   * This is called from a SharedSummaryBlock that does not generate ops but only wants to be part of the summary.\n   * It indicates that there is data in the object that needs to be summarized.\n   * We will update the latestSequenceNumber of the summary tracker of this\n   * store and of the object's channel.\n   *\n   * @param address - The address of the channel that is dirty.\n   *\n   */\n  setChannelDirty(address) {\n    this.verifyNotClosed();\n    // Get the latest sequence number.\n    const latestSequenceNumber = this.deltaManager.lastSequenceNumber;\n    this.summarizerNode.invalidate(latestSequenceNumber);\n    const channelSummarizerNode = this.summarizerNode.getChild(address);\n    if (channelSummarizerNode) {\n      channelSummarizerNode.invalidate(latestSequenceNumber); // TODO: lazy load problem?\n    }\n  }\n\n  submitSignal(type, content) {\n    this.verifyNotClosed();\n    assert(!!this.channel);\n    return this._containerRuntime.submitDataStoreSignal(this.id, type, content);\n  }\n  raiseContainerWarning(warning) {\n    this.containerRuntime.raiseContainerWarning(warning);\n  }\n  /**\n   * Updates the leader.\n   * @param leadership - Whether this client is the new leader or not.\n   */\n  updateLeader(leadership) {\n    // Leader events are ignored if the store is not yet loaded\n    if (!this.loaded) {\n      return;\n    }\n    if (leadership) {\n      this.emit(\"leader\");\n    } else {\n      this.emit(\"notleader\");\n    }\n  }\n  bindRuntime(channel) {\n    var _a;\n    if (this.channel) {\n      throw new Error(\"Runtime already bound\");\n    }\n    try {\n      assert(!this.detachedRuntimeCreation);\n      assert(this.channelDeferred !== undefined);\n      assert(this.pkg !== undefined);\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const pending = this.pending;\n      if (pending.length > 0) {\n        // Apply all pending ops\n        for (const op of pending) {\n          channel.process(op, false, undefined /* localOpMetadata */);\n        }\n      }\n\n      this.pending = undefined;\n      // And now mark the runtime active\n      this.loaded = true;\n      this.channel = channel;\n      // Freeze the package path to ensure that someone doesn't modify it when it is\n      // returned in packagePath().\n      Object.freeze(this.pkg);\n      // And notify the pending promise it is now available\n      this.channelDeferred.resolve(this.channel);\n    } catch (error) {\n      (_a = this.channelDeferred) === null || _a === void 0 ? void 0 : _a.reject(error);\n    }\n    // notify the runtime if they want to propagate up. Used for logging.\n    this._containerRuntime.notifyDataStoreInstantiated(this);\n  }\n  getAbsoluteUrl(relativeUrl) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      if (_this11.attachState !== AttachState.Attached) {\n        return undefined;\n      }\n      return _this11._containerRuntime.getAbsoluteUrl(relativeUrl);\n    })();\n  }\n  reSubmit(contents, localOpMetadata) {\n    assert(!!this.channel, \"Channel must exist when resubmitting ops\");\n    const innerContents = contents;\n    this.channel.reSubmit(innerContents.type, innerContents.content, localOpMetadata);\n  }\n  verifyNotClosed() {\n    if (this._disposed) {\n      throw new Error(\"Context is closed\");\n    }\n  }\n  getCreateChildSummarizerNodeFn(id, createParam) {\n    return (summarizeInternal, getGCDataFn, getInitialGCSummaryDetailsFn, usedRoutes) => this.summarizerNode.createChild(summarizeInternal, id, createParam,\n    // DDS will not create failure summaries\n    {\n      throwOnFailure: true\n    }, getGCDataFn, getInitialGCSummaryDetailsFn, usedRoutes);\n  }\n  uploadBlob(blob) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      return _this12.containerRuntime.uploadBlob(blob);\n    })();\n  }\n}\nexport class RemotedFluidDataStoreContext extends FluidDataStoreContext {\n  constructor(id, initSnapshotValue, runtime, storage, scope, createSummarizerNode, pkg) {\n    var _this13;\n    super(runtime, id, true, storage, scope, createSummarizerNode, BindState.Bound, false, () => {\n      throw new Error(\"Already attached\");\n    }, pkg);\n    _this13 = this;\n    this.initSnapshotValue = initSnapshotValue;\n    this.initialSnapshotDetailsP = new LazyPromise( /*#__PURE__*/_asyncToGenerator(function* () {\n      var _a, _b;\n      let tree;\n      let isRootDataStore = true;\n      if (typeof _this13.initSnapshotValue === \"string\") {\n        const commit = (yield _this13.storage.getVersions(_this13.initSnapshotValue, 1))[0];\n        tree = (_a = yield _this13.storage.getSnapshotTree(commit), _a !== null && _a !== void 0 ? _a : undefined);\n      } else {\n        tree = _this13.initSnapshotValue;\n      }\n      const localReadAndParse = /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator(function* (id) {\n          return readAndParse(_this13.storage, id);\n        });\n        return function localReadAndParse(_x3) {\n          return _ref5.apply(this, arguments);\n        };\n      }();\n      if (tree) {\n        const loadedSummary = yield _this13.summarizerNode.loadBaseSummary(tree, localReadAndParse);\n        tree = loadedSummary.baseSummary;\n        // Prepend outstanding ops to pending queue of ops to process.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        _this13.pending = loadedSummary.outstandingOps.concat(_this13.pending);\n      }\n      if (!!tree && tree.blobs[dataStoreAttributesBlobName] !== undefined) {\n        // Need to rip through snapshot and use that to populate extraBlobs\n        const attributes = yield localReadAndParse(tree.blobs[dataStoreAttributesBlobName]);\n        let pkgFromSnapshot;\n        // Use the snapshotFormatVersion to determine how the pkg is encoded in the snapshot.\n        // For snapshotFormatVersion = \"0.1\" or above, pkg is jsonified, otherwise it is just a string.\n        switch (attributes.snapshotFormatVersion) {\n          case undefined:\n            {\n              if (attributes.pkg.startsWith(\"[\\\"\") && attributes.pkg.endsWith(\"\\\"]\")) {\n                pkgFromSnapshot = JSON.parse(attributes.pkg);\n              } else {\n                pkgFromSnapshot = [attributes.pkg];\n              }\n              break;\n            }\n          case 2:\n            {\n              tree = tree.trees[channelsTreeName];\n              // Intentional fallthrough, since package is still JSON\n            }\n\n          case \"0.1\":\n            {\n              pkgFromSnapshot = JSON.parse(attributes.pkg);\n              break;\n            }\n          default:\n            {\n              unreachableCase(attributes.snapshotFormatVersion, `Invalid snapshot format version ${attributes.snapshotFormatVersion}`);\n            }\n        }\n        _this13.pkg = pkgFromSnapshot;\n        /**\n         * If there is no isRootDataStore in the attributes blob, set it to true. This will ensure that\n         * data stores in older documents are not garbage collected incorrectly. This may lead to additional\n         * roots in the document but they won't break.\n         */\n        isRootDataStore = (_b = attributes.isRootDataStore, _b !== null && _b !== void 0 ? _b : true);\n      }\n      return {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        pkg: _this13.pkg,\n        snapshot: tree,\n        isRootDataStore\n      };\n    }));\n    this.gcDetailsInInitialSummaryP = new LazyPromise( /*#__PURE__*/_asyncToGenerator(function* () {\n      // If the initial snapshot is undefined or string, the snapshot is in old format and won't have GC details.\n      if (!(!_this13.initSnapshotValue || typeof _this13.initSnapshotValue === \"string\") && _this13.initSnapshotValue.blobs[gcBlobKey] !== undefined) {\n        return readAndParse(_this13.storage, _this13.initSnapshotValue.blobs[gcBlobKey]);\n      } else {\n        return {};\n      }\n    }));\n  }\n  getInitialSnapshotDetails() {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      return _this14.initialSnapshotDetailsP;\n    })();\n  }\n  getInitialGCSummaryDetails() {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      return _this15.gcDetailsInInitialSummaryP;\n    })();\n  }\n  generateAttachMessage() {\n    throw new Error(\"Cannot attach remote store\");\n  }\n}\n/**\n * Base class for detached & attached context classes\n */\nexport class LocalFluidDataStoreContextBase extends FluidDataStoreContext {\n  constructor(id, pkg, runtime, storage, scope, createSummarizerNode, bindChannel, snapshotTree, isRootDataStore,\n  /**\n   * @deprecated 0.16 Issue #1635, #3631\n   */\n  createProps) {\n    super(runtime, id, snapshotTree !== undefined ? true : false, storage, scope, createSummarizerNode, snapshotTree ? BindState.Bound : BindState.NotBound, true, bindChannel, pkg);\n    this.snapshotTree = snapshotTree;\n    this.isRootDataStore = isRootDataStore;\n    this.createProps = createProps;\n    this.attachListeners();\n  }\n  attachListeners() {\n    this.once(\"attaching\", () => {\n      assert(this.attachState === AttachState.Detached, \"Should move from detached to attaching\");\n      this._attachState = AttachState.Attaching;\n    });\n    this.once(\"attached\", () => {\n      assert(this.attachState === AttachState.Attaching, \"Should move from attaching to attached\");\n      this._attachState = AttachState.Attached;\n    });\n  }\n  generateAttachMessage() {\n    assert(this.channel !== undefined, \"There should be a channel when generating attach message\");\n    assert(this.pkg !== undefined, \"pkg should be available in local data store context\");\n    assert(this.isRootDataStore !== undefined, \"isRootDataStore should be available in local data store context\");\n    const summarizeResult = this.channel.getAttachSummary();\n    // Add data store's attributes to the summary.\n    const attributes = createAttributes(this.pkg, this.isRootDataStore);\n    addBlobToSummary(summarizeResult, dataStoreAttributesBlobName, JSON.stringify(attributes));\n    // Add GC details to the summary.\n    const gcDetails = {\n      usedRoutes: this.summarizerNode.usedRoutes,\n      gcData: summarizeResult.gcData\n    };\n    addBlobToSummary(summarizeResult, gcBlobKey, JSON.stringify(gcDetails));\n    // Attach message needs the summary in ITree format. Convert the ISummaryTree into an ITree.\n    const snapshot = convertSummaryTreeToITree(summarizeResult.summary);\n    const message = {\n      id: this.id,\n      snapshot,\n      type: this.pkg[this.pkg.length - 1]\n    };\n    return message;\n  }\n  getInitialSnapshotDetails() {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      assert(_this16.pkg !== undefined, \"pkg should be available in local data store\");\n      assert(_this16.isRootDataStore !== undefined, \"isRootDataStore should be available in local data store\");\n      return {\n        pkg: _this16.pkg,\n        snapshot: _this16.snapshotTree,\n        isRootDataStore: _this16.isRootDataStore\n      };\n    })();\n  }\n  getInitialGCSummaryDetails() {\n    return _asyncToGenerator(function* () {\n      // Local data store does not have initial summary.\n      return {};\n    })();\n  }\n}\n/**\n * context implementation for \"attached\" data store runtime.\n * Various workflows (snapshot creation, requests) result in .realize() being called\n * on context, resulting in instantiation and attachment of runtime.\n * Runtime is created using data store factory that is associated with this context.\n */\nexport class LocalFluidDataStoreContext extends LocalFluidDataStoreContextBase {\n  constructor(id, pkg, runtime, storage, scope, createSummarizerNode, bindChannel, snapshotTree, isRootDataStore,\n  /**\n   * @deprecated 0.16 Issue #1635, #3631\n   */\n  createProps) {\n    super(id, pkg, runtime, storage, scope, createSummarizerNode, bindChannel, snapshotTree, isRootDataStore, createProps);\n  }\n}\n/**\n * Detached context. Data Store runtime will be attached to it by attachRuntime() call\n * Before attachment happens, this context is not associated with particular type of runtime\n * or factory, i.e. it's package path is undefined.\n * Attachment process provides all missing parts - package path, data store runtime, and data store factory\n */\nexport class LocalDetachedFluidDataStoreContext extends LocalFluidDataStoreContextBase {\n  constructor(id, pkg, runtime, storage, scope, createSummarizerNode, bindChannel, snapshotTree, isRootDataStore) {\n    super(id, pkg, runtime, storage, scope, createSummarizerNode, bindChannel, snapshotTree, isRootDataStore);\n    this.detachedRuntimeCreation = true;\n  }\n  attachRuntime(registry, dataStoreRuntime) {\n    var _superprop_getBindRuntime = () => super.bindRuntime,\n      _this17 = this;\n    return _asyncToGenerator(function* () {\n      assert(_this17.detachedRuntimeCreation);\n      assert(_this17.channelDeferred === undefined);\n      const factory = registry.IFluidDataStoreFactory;\n      const entry = yield _this17.factoryFromPackagePath(_this17.pkg);\n      assert(entry.factory === factory);\n      assert(_this17.registry === undefined);\n      _this17.registry = entry.registry;\n      _this17.detachedRuntimeCreation = false;\n      _this17.channelDeferred = new Deferred();\n      _superprop_getBindRuntime().call(_this17, dataStoreRuntime);\n      if (_this17.isRootDataStore) {\n        dataStoreRuntime.bindToContext();\n      }\n    })();\n  }\n  getInitialSnapshotDetails() {\n    var _superprop_getGetInitialSnapshotDetails = () => super.getInitialSnapshotDetails,\n      _this18 = this;\n    return _asyncToGenerator(function* () {\n      if (_this18.detachedRuntimeCreation) {\n        throw new Error(\"Detached Fluid Data Store context can't be realized! Please attach runtime first!\");\n      }\n      return _superprop_getGetInitialSnapshotDetails().call(_this18);\n    })();\n  }\n}\n//# sourceMappingURL=dataStoreContext.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}