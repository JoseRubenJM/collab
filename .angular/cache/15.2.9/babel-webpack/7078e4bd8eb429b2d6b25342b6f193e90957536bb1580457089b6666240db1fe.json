{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { TaskManagerFactory } from \"@fluidframework/agent-scheduler\";\nimport { AttachState } from \"@fluidframework/container-definitions\";\nimport { assert, Trace, TypedEventEmitter, unreachableCase } from \"@fluidframework/common-utils\";\nimport { ChildLogger, raiseConnectedEvent, PerformanceEvent } from \"@fluidframework/telemetry-utils\";\nimport { readAndParse, readAndParseFromBlobs } from \"@fluidframework/driver-utils\";\nimport { CreateContainerError } from \"@fluidframework/container-utils\";\nimport { runGarbageCollection } from \"@fluidframework/garbage-collector\";\nimport { BlobTreeEntry } from \"@fluidframework/protocol-base\";\nimport { MessageType } from \"@fluidframework/protocol-definitions\";\nimport { FlushMode } from \"@fluidframework/runtime-definitions\";\nimport { addBlobToSummary, addTreeToSummary, convertToSummaryTree, createRootSummarizerNodeWithGC, FluidSerializer, requestFluidObject, RequestParser } from \"@fluidframework/runtime-utils\";\nimport { v4 as uuid } from \"uuid\";\nimport { ContainerFluidHandleContext } from \"./containerHandleContext\";\nimport { FluidDataStoreRegistry } from \"./dataStoreRegistry\";\nimport { debug } from \"./debug\";\nimport { Summarizer } from \"./summarizer\";\nimport { SummaryManager } from \"./summaryManager\";\nimport { analyzeTasks } from \"./taskAnalyzer\";\nimport { DeltaScheduler } from \"./deltaScheduler\";\nimport { ReportOpPerfTelemetry } from \"./connectionTelemetry\";\nimport { PendingStateManager } from \"./pendingStateManager\";\nimport { pkgVersion } from \"./packageVersion\";\nimport { BlobManager } from \"./blobManager\";\nimport { DataStores, getSnapshotForDataStores } from \"./dataStores\";\nimport { blobsTreeName, chunksBlobName, metadataBlobName } from \"./snapshot\";\nexport var ContainerMessageType = /*#__PURE__*/(() => {\n  (function (ContainerMessageType) {\n    // An op to be delivered to store\n    ContainerMessageType[\"FluidDataStoreOp\"] = \"component\";\n    // Creates a new store\n    ContainerMessageType[\"Attach\"] = \"attach\";\n    // Chunked operation.\n    ContainerMessageType[\"ChunkedOp\"] = \"chunkedOp\";\n    ContainerMessageType[\"BlobAttach\"] = \"blobAttach\";\n  })(ContainerMessageType || (ContainerMessageType = {}));\n  return ContainerMessageType;\n})();\n// Consider idle 5s of no activity. And snapshot if a minute has gone by with no snapshot.\nconst IdleDetectionTime = 5000;\nconst DefaultSummaryConfiguration = {\n  idleTime: IdleDetectionTime,\n  maxTime: IdleDetectionTime * 12,\n  // Snapshot if 1000 ops received since last snapshot.\n  maxOps: 1000,\n  // Wait 2 minutes for summary ack\n  maxAckWaitTime: 120000\n};\nexport function isRuntimeMessage(message) {\n  switch (message.type) {\n    case ContainerMessageType.FluidDataStoreOp:\n    case ContainerMessageType.ChunkedOp:\n    case ContainerMessageType.Attach:\n    case ContainerMessageType.BlobAttach:\n    case MessageType.Operation:\n      return true;\n    default:\n      return false;\n  }\n}\nexport function unpackRuntimeMessage(message) {\n  if (message.type === MessageType.Operation) {\n    // legacy op format?\n    if (message.contents.address !== undefined && message.contents.type === undefined) {\n      message.type = ContainerMessageType.FluidDataStoreOp;\n    } else {\n      // new format\n      const innerContents = message.contents;\n      assert(innerContents.type !== undefined);\n      message.type = innerContents.type;\n      message.contents = innerContents.contents;\n    }\n    assert(isRuntimeMessage(message));\n  } else {\n    // Legacy format, but it's already \"unpacked\",\n    // i.e. message.type is actually ContainerMessageType.\n    // Nothing to do in such case.\n  }\n  return message;\n}\nexport class ScheduleManager {\n  constructor(deltaManager, emitter, logger) {\n    this.deltaManager = deltaManager;\n    this.emitter = emitter;\n    this.logger = logger;\n    this.localPaused = false;\n    this.deltaScheduler = new DeltaScheduler(this.deltaManager, ChildLogger.create(this.logger, \"DeltaScheduler\"));\n    // Listen for delta manager sends and add batch metadata to messages\n    this.deltaManager.on(\"prepareSend\", messages => {\n      if (messages.length === 0) {\n        return;\n      }\n      // First message will have the batch flag set to true if doing a batched send\n      const firstMessageMetadata = messages[0].metadata;\n      if (!firstMessageMetadata || !firstMessageMetadata.batch) {\n        return;\n      }\n      // If the batch contains only a single op, clear the batch flag.\n      if (messages.length === 1) {\n        delete firstMessageMetadata.batch;\n        return;\n      }\n      // Set the batch flag to false on the last message to indicate the end of the send batch\n      const lastMessage = messages[messages.length - 1];\n      lastMessage.metadata = Object.assign(Object.assign({}, lastMessage.metadata), {\n        batch: false\n      });\n    });\n    // Listen for updates and peek at the inbound\n    this.deltaManager.inbound.on(\"push\", message => {\n      this.trackPending(message);\n      this.updatePauseState(message.sequenceNumber);\n    });\n    const allPending = this.deltaManager.inbound.toArray();\n    for (const pending of allPending) {\n      this.trackPending(pending);\n    }\n    // Based on track pending update the pause state\n    this.updatePauseState(this.deltaManager.lastSequenceNumber);\n  }\n  beginOperation(message) {\n    var _a, _b;\n    if (this.batchClientId !== message.clientId) {\n      // As a back stop for any bugs marking the end of a batch - if the client ID flipped, we\n      // consider the previous batch over.\n      if (this.batchClientId) {\n        this.emitter.emit(\"batchEnd\", \"Did not receive real batchEnd message\", undefined);\n        this.deltaScheduler.batchEnd();\n        this.logger.sendTelemetryEvent({\n          eventName: \"BatchEndNotReceived\",\n          clientId: this.batchClientId,\n          sequenceNumber: message.sequenceNumber\n        });\n      }\n      // This could be the beginning of a new batch or an individual message.\n      this.emitter.emit(\"batchBegin\", message);\n      this.deltaScheduler.batchBegin();\n      const batch = (_b = (_a = message) === null || _a === void 0 ? void 0 : _a.metadata) === null || _b === void 0 ? void 0 : _b.batch;\n      if (batch) {\n        this.batchClientId = message.clientId;\n      } else {\n        this.batchClientId = undefined;\n      }\n    }\n  }\n  endOperation(error, message) {\n    var _a, _b;\n    if (error) {\n      this.batchClientId = undefined;\n      this.emitter.emit(\"batchEnd\", error, message);\n      this.deltaScheduler.batchEnd();\n      return;\n    }\n    this.updatePauseState(message.sequenceNumber);\n    const batch = (_b = (_a = message) === null || _a === void 0 ? void 0 : _a.metadata) === null || _b === void 0 ? void 0 : _b.batch;\n    // If no batchClientId has been set then we're in an individual batch. Else, if we get\n    // batch end metadata, this is end of the current batch.\n    if (!this.batchClientId || batch === false) {\n      this.batchClientId = undefined;\n      this.emitter.emit(\"batchEnd\", undefined, message);\n      this.deltaScheduler.batchEnd();\n      return;\n    }\n  }\n  setPaused(localPaused) {\n    // Return early if no change in value\n    if (this.localPaused === localPaused) {\n      return;\n    }\n    this.localPaused = localPaused;\n    if (localPaused) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.deltaManager.inbound.pause();\n    } else {\n      this.deltaManager.inbound.resume();\n    }\n  }\n  updatePauseState(sequenceNumber) {\n    // If the inbound queue is ever empty we pause it and wait for new events\n    if (this.deltaManager.inbound.length === 0) {\n      this.setPaused(true);\n      return;\n    }\n    // If no message has caused the pause flag to be set, or the next message up is not the one we need to pause at\n    // then we simply continue processing\n    if (!this.pauseSequenceNumber || sequenceNumber + 1 < this.pauseSequenceNumber) {\n      this.setPaused(false);\n    } else {\n      // Otherwise the next message requires us to pause\n      this.setPaused(true);\n    }\n  }\n  trackPending(message) {\n    const metadata = message.metadata;\n    // Protocol messages are never part of a runtime batch of messages\n    if (!isRuntimeMessage(message)) {\n      this.pauseSequenceNumber = undefined;\n      this.pauseClientId = undefined;\n      return;\n    }\n    const batchMetadata = metadata ? metadata.batch : undefined;\n    // If the client ID changes then we can move the pause point. If it stayed the same then we need to check.\n    if (this.pauseClientId === message.clientId) {\n      if (batchMetadata !== undefined) {\n        // If batchMetadata is not undefined then if it's true we've begun a new batch - if false we've ended\n        // the previous one\n        this.pauseSequenceNumber = batchMetadata ? message.sequenceNumber : undefined;\n        this.pauseClientId = batchMetadata ? this.pauseClientId : undefined;\n      }\n    } else {\n      // We check the batch flag for the new clientID - if true we pause otherwise we reset the tracking data\n      this.pauseSequenceNumber = batchMetadata ? message.sequenceNumber : undefined;\n      this.pauseClientId = batchMetadata ? message.clientId : undefined;\n    }\n  }\n}\nexport const taskSchedulerId = \"_scheduler\";\n// Wraps the provided list of packages and augments with some system level services.\nclass ContainerRuntimeDataStoreRegistry extends FluidDataStoreRegistry {\n  constructor(namedEntries) {\n    super([...namedEntries, TaskManagerFactory.registryEntry]);\n  }\n}\n/**\n * Represents the runtime of the container. Contains helper functions/state of the container.\n * It will define the store level mappings.\n */\nexport class ContainerRuntime extends TypedEventEmitter {\n  constructor(context, registry, metadata = {\n    snapshotFormatVersion: undefined\n  }, chunks, runtimeOptions = {\n    generateSummaries: true,\n    enableWorker: false\n  }, containerScope, requestHandler) {\n    var _this;\n    var _a, _b;\n    super();\n    _this = this;\n    this.context = context;\n    this.registry = registry;\n    this.runtimeOptions = runtimeOptions;\n    this.containerScope = containerScope;\n    this.requestHandler = requestHandler;\n    // 0.24 back-compat attachingBeforeSummary\n    this.runtimeVersion = pkgVersion;\n    this.tasks = [];\n    this._flushMode = FlushMode.Automatic;\n    this.needsFlush = false;\n    this.flushTrigger = false;\n    // Always matched IAgentScheduler.leader property\n    this._leader = false;\n    this._disposed = false;\n    this.dirtyDocument = false;\n    this.emitDirtyDocumentEvent = true;\n    this._connected = this.context.connected;\n    this.chunkMap = new Map(chunks);\n    this.IFluidHandleContext = new ContainerFluidHandleContext(\"\", this);\n    this.IFluidSerializer = new FluidSerializer(this.IFluidHandleContext);\n    this.logger = ChildLogger.create(context.logger, undefined, {\n      runtimeVersion: pkgVersion\n    });\n    this._logger = ChildLogger.create(this.logger, \"ContainerRuntime\");\n    this.latestSummaryAck = {\n      proposalHandle: undefined,\n      ackHandle: (_a = this.context.getLoadedFromVersion()) === null || _a === void 0 ? void 0 : _a.id\n    };\n    const loadedFromSequenceNumber = this.deltaManager.initialSequenceNumber;\n    this.summarizerNode = createRootSummarizerNodeWithGC(this.logger,\n    /*#__PURE__*/\n    // Summarize function to call when summarize is called. Summarizer node always tracks summary state.\n    function () {\n      var _ref = _asyncToGenerator(function* (fullTree, trackState) {\n        return _this.summarizeInternal(fullTree, trackState);\n      });\n      return function (_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }(),\n    // Latest change sequence number, no changes since summary applied yet\n    loadedFromSequenceNumber,\n    // Summary reference sequence number, undefined if no summary yet\n    context.baseSnapshot ? loadedFromSequenceNumber : undefined, {\n      // Must set to false to prevent sending summary handle which would be pointing to\n      // a summary with an older protocol state.\n      canReuseHandle: false,\n      // Must set to true to throw on any data stores failure that was too severe to be handled.\n      // We also are not decoding the base summaries at the root.\n      throwOnFailure: true,\n      // If GC is disabled, let the summarizer node know so that it does not track GC state.\n      gcDisabled: this.runtimeOptions.disableGC\n    });\n    this.dataStores = new DataStores(getSnapshotForDataStores(context.baseSnapshot, metadata.snapshotFormatVersion), this, attachMsg => this.submit(ContainerMessageType.Attach, attachMsg), (id, createParam) => (summarizeInternal, getGCDataFn, getInitialGCSummaryDetailsFn) => this.summarizerNode.createChild(summarizeInternal, id, createParam, undefined, getGCDataFn, getInitialGCSummaryDetailsFn), this._logger);\n    this.blobManager = new BlobManager(this.IFluidHandleContext, () => this.storage, blobId => this.submit(ContainerMessageType.BlobAttach, undefined, undefined, {\n      blobId\n    }));\n    this.blobManager.load((_b = context.baseSnapshot) === null || _b === void 0 ? void 0 : _b.trees[blobsTreeName]);\n    this.scheduleManager = new ScheduleManager(context.deltaManager, this, ChildLogger.create(this.logger, \"ScheduleManager\"));\n    this.deltaSender = this.deltaManager;\n    this.pendingStateManager = new PendingStateManager(this);\n    this.context.quorum.on(\"removeMember\", clientId => {\n      this.clearPartialChunks(clientId);\n    });\n    this.context.quorum.on(\"addProposal\", proposal => {\n      if (proposal.key === \"code\" || proposal.key === \"code2\") {\n        this.emit(\"codeDetailsProposed\", proposal.value, proposal);\n      }\n    });\n    if (this.context.previousRuntimeState === undefined || this.context.previousRuntimeState.state === undefined) {\n      this.previousState = {};\n    } else {\n      this.previousState = this.context.previousRuntimeState.state;\n    }\n    // We always create the summarizer in the case that we are asked to generate summaries. But this may\n    // want to be on demand instead.\n    // Don't use optimizations when generating summaries with a document loaded using snapshots.\n    // This will ensure we correctly convert old documents.\n    this.summarizer = new Summarizer(\"/_summarizer\", this /* ISummarizerRuntime */, () => this.summaryConfiguration, this /* ISummarizerInternalsProvider */, this.IFluidHandleContext, this.previousState.summaryCollection);\n    // Create the SummaryManager and mark the initial state\n    this.summaryManager = new SummaryManager(context, this.runtimeOptions.generateSummaries !== false, !!this.runtimeOptions.enableWorker, this.logger, summarizer => {\n      this.nextSummarizerP = summarizer;\n    }, this.previousState.nextSummarizerP, !!this.previousState.reload, this.runtimeOptions.initialSummarizerDelayMs);\n    if (this.connected) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.summaryManager.setConnected(this.context.clientId);\n    }\n    this.deltaManager.on(\"readonly\", readonly => {\n      // we accumulate ops while being in read-only state.\n      // once user gets write permissions and we have active connection, flush all pending ops.\n      assert(readonly === this.deltaManager.readonly, \"inconsistent readonly property/event state\");\n      // We need to be very careful with when we (re)send pending ops, to ensure that we only send ops\n      // when we either never send an op, or attempted to send it but we know for sure it was not\n      // sequenced by server and will never be sequenced (i.e. was lost)\n      // For loss of connection, we wait for our own \"join\" op and use it a a barrier to know all the\n      // ops that made it from previous connection, before switching clientId and raising \"connected\" event\n      // But with read-only permissions, if we transition between read-only and r/w states while on same\n      // connection, then we have no good signal to tell us when it's safe to send ops we accumulated while\n      // being in read-only state.\n      // For that reason, we support getting to read-only state only when disconnected. This ensures that we\n      // can rely on same safety mechanism and resend ops only when we establish new connection.\n      // This is applicable for read-only permissions (event is raised before connection is properly registered),\n      // but it's an extra requirement for Container.forceReadonly() API\n      assert(!readonly || !this.connected, \"Unsafe to transition to read-only state!\");\n      this.replayPendingStates();\n    });\n    ReportOpPerfTelemetry(this.context.clientId, this.deltaManager, this.logger);\n  }\n  get IContainerRuntime() {\n    return this;\n  }\n  get IContainerRuntimeDirtyable() {\n    return this;\n  }\n  get IFluidRouter() {\n    return this;\n  }\n  /**\n   * Load the stores from a snapshot and returns the runtime.\n   * @param context - Context of the container.\n   * @param registry - Mapping to the stores.\n   * @param requestHandlers - Request handlers for the container runtime\n   * @param runtimeOptions - Additional options to be passed to the runtime\n   */\n  static load(context, registryEntries, requestHandler, runtimeOptions, containerScope = context.scope) {\n    return _asyncToGenerator(function* () {\n      var _a;\n      // Back-compat: <= 0.18 loader\n      if (context.deltaManager.lastSequenceNumber === undefined) {\n        Object.defineProperty(context.deltaManager, \"lastSequenceNumber\", {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n          get: () => context.deltaManager.referenceSequenceNumber\n        });\n      }\n      const registry = new ContainerRuntimeDataStoreRegistry(registryEntries);\n      const tryFetchBlob = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (blobName) {\n          var _a;\n          const blobId = (_a = context.baseSnapshot) === null || _a === void 0 ? void 0 : _a.blobs[blobName];\n          if (context.baseSnapshot && blobId) {\n            return context.storage ? readAndParse(context.storage, blobId) : readAndParseFromBlobs(context.baseSnapshot.blobs, blobId);\n          }\n        });\n        return function tryFetchBlob(_x3) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      const chunks = (_a = yield tryFetchBlob(chunksBlobName), _a !== null && _a !== void 0 ? _a : []);\n      const metadata = yield tryFetchBlob(metadataBlobName);\n      const runtime = new ContainerRuntime(context, registry, metadata, chunks, runtimeOptions, containerScope, requestHandler);\n      // Create all internal data stores if not already existing on storage or loaded a detached\n      // container from snapshot(ex. draft mode).\n      if (!context.existing) {\n        yield runtime.createRootDataStore(TaskManagerFactory.type, taskSchedulerId);\n      }\n      runtime.subscribeToLeadership();\n      return runtime;\n    })();\n  }\n  get id() {\n    return this.context.id;\n  }\n  get existing() {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.context.existing;\n  }\n  get options() {\n    return this.context.options;\n  }\n  get clientId() {\n    return this.context.clientId;\n  }\n  get clientDetails() {\n    return this.context.clientDetails;\n  }\n  get deltaManager() {\n    return this.context.deltaManager;\n  }\n  get storage() {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.context.storage;\n  }\n  get branch() {\n    return this.context.branch;\n  }\n  get snapshotFn() {\n    return this.context.snapshotFn;\n  }\n  get reSubmitFn() {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    return this.reSubmit;\n  }\n  get closeFn() {\n    return this.context.closeFn;\n  }\n  get loader() {\n    return this.context.loader;\n  }\n  get flushMode() {\n    return this._flushMode;\n  }\n  get scope() {\n    return this.containerScope;\n  }\n  get IFluidDataStoreRegistry() {\n    return this.registry;\n  }\n  get attachState() {\n    if (this.context.attachState !== undefined) {\n      return this.context.attachState;\n    }\n    // 0.21 back-compat isAttached\n    return this.context.isAttached() ? AttachState.Attached : AttachState.Detached;\n  }\n  get connected() {\n    return this._connected;\n  }\n  get leader() {\n    return this._leader;\n  }\n  get summarizerClientId() {\n    return this.summaryManager.summarizer;\n  }\n  get summaryConfiguration() {\n    var _a, _b;\n    return Object.assign(Object.assign(Object.assign({}, DefaultSummaryConfiguration), (_b = (_a = this.context) === null || _a === void 0 ? void 0 : _a.serviceConfiguration) === null || _b === void 0 ? void 0 : _b.summary), this.runtimeOptions.summaryConfigOverrides);\n  }\n  get disposed() {\n    return this._disposed;\n  }\n  dispose(error) {\n    var _a;\n    if (this._disposed) {\n      return;\n    }\n    this._disposed = true;\n    this.logger.sendTelemetryEvent({\n      eventName: \"ContainerRuntimeDisposed\",\n      category: \"generic\",\n      isDirty: this.isDocumentDirty(),\n      lastSequenceNumber: this.deltaManager.lastSequenceNumber,\n      attachState: this.attachState,\n      message: (_a = error) === null || _a === void 0 ? void 0 : _a.message\n    });\n    this.summaryManager.dispose();\n    this.summarizer.dispose();\n    this.dataStores.dispose();\n    this.emit(\"dispose\");\n    this.removeAllListeners();\n  }\n  get IFluidTokenProvider() {\n    if (this.options && this.options.intelligence) {\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n      return {\n        intelligence: this.options.intelligence\n      };\n    }\n    return undefined;\n  }\n  get IFluidConfiguration() {\n    return this.context.configuration;\n  }\n  /**\n   * Notifies this object about the request made to the container.\n   * @param request - Request made to the handler.\n   */\n  request(request) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const parser = RequestParser.create(request);\n      const id = parser.pathParts[0];\n      if (id === \"_summarizer\" && parser.pathParts.length === 1) {\n        return {\n          status: 200,\n          mimeType: \"fluid/object\",\n          value: _this2.summarizer\n        };\n      }\n      if (_this2.requestHandler !== undefined) {\n        return _this2.requestHandler(parser, _this2);\n      }\n      return {\n        status: 404,\n        mimeType: \"text/plain\",\n        value: \"resource not found\"\n      };\n    })();\n  }\n  /**\n   * Resolves URI representing handle\n   * @param request - Request made to the handler.\n   */\n  resolveHandle(request) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      const requestParser = RequestParser.create(request);\n      const id = requestParser.pathParts[0];\n      if (id === \"_channels\") {\n        return _this3.resolveHandle(requestParser.createSubRequest(1));\n      }\n      if (id === BlobManager.basePath && requestParser.isLeaf(2)) {\n        const handle = yield _this3.blobManager.getBlob(requestParser.pathParts[1]);\n        if (handle) {\n          return {\n            status: 200,\n            mimeType: \"fluid/object\",\n            value: handle.get()\n          };\n        } else {\n          return {\n            status: 404,\n            mimeType: \"text/plain\",\n            value: \"blob not found\"\n          };\n        }\n      } else if (requestParser.pathParts.length > 0) {\n        const wait = typeof ((_a = request.headers) === null || _a === void 0 ? void 0 : _a.wait) === \"boolean\" ? request.headers.wait : undefined;\n        const dataStore = yield _this3.getDataStore(id, wait);\n        const subRequest = requestParser.createSubRequest(1);\n        // We always expect createSubRequest to include a leading slash, but asserting here to protect against\n        // unintentionally modifying the url if that changes.\n        assert(subRequest.url.startsWith(\"/\"), \"Expected createSubRequest url to include a leading slash\");\n        return dataStore.IFluidRouter.request(subRequest);\n      }\n      return {\n        status: 404,\n        mimeType: \"text/plain\",\n        value: \"resource not found\"\n      };\n    })();\n  }\n  /**\n   * Notifies this object to take the snapshot of the container.\n   * @deprecated - Use summarize to get summary of the container runtime.\n   */\n  snapshot() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const root = {\n        entries: yield _this4.dataStores.snapshot()\n      };\n      if (_this4.chunkMap.size > 0) {\n        root.entries.push(new BlobTreeEntry(chunksBlobName, JSON.stringify([..._this4.chunkMap])));\n      }\n      return root;\n    })();\n  }\n  addContainerBlobsToSummary(summaryTree) {\n    if (this.chunkMap.size > 0) {\n      const content = JSON.stringify([...this.chunkMap]);\n      addBlobToSummary(summaryTree, chunksBlobName, content);\n    }\n    const blobsTree = convertToSummaryTree(this.blobManager.snapshot(), false);\n    addTreeToSummary(summaryTree, blobsTreeName, blobsTree);\n  }\n  requestSnapshot(tagMessage) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      return _this5.context.requestSnapshot(tagMessage);\n    })();\n  }\n  stop() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      _this6.verifyNotClosed();\n      const snapshot = yield _this6.snapshot();\n      const state = {\n        reload: true,\n        summaryCollection: _this6.summarizer.summaryCollection,\n        nextSummarizerP: _this6.nextSummarizerP,\n        nextSummarizerD: _this6.nextSummarizerD\n      };\n      _this6.dispose(new Error(\"ContainerRuntimeStopped\"));\n      return {\n        snapshot,\n        state\n      };\n    })();\n  }\n  replayPendingStates() {\n    // We need to be able to send ops to replay states\n    if (!this.canSendOps()) {\n      return;\n    }\n    // We need to temporary clear the dirty flags and disable\n    // dirty state change events to detect whether replaying ops\n    // has any effect.\n    // Save the old state, reset to false, disable event emit\n    const oldState = this.dirtyDocument;\n    this.dirtyDocument = false;\n    this.emitDirtyDocumentEvent = false;\n    // replay the ops\n    this.pendingStateManager.replayPendingStates();\n    // Save the new start and restore the old state, re-enable event emit\n    const newState = this.dirtyDocument;\n    this.dirtyDocument = oldState;\n    this.emitDirtyDocumentEvent = true;\n    // Officially transition from the old state to the new state.\n    this.updateDocumentDirtyState(newState);\n  }\n  setConnectionState(connected, clientId) {\n    this.verifyNotClosed();\n    // There might be no change of state due to Container calling this API after loading runtime.\n    const changeOfState = this._connected !== connected;\n    this._connected = connected;\n    if (changeOfState) {\n      this.replayPendingStates();\n    }\n    this.dataStores.setConnectionState(connected, clientId);\n    raiseConnectedEvent(this._logger, this, connected, clientId);\n    if (connected) {\n      assert(!!clientId);\n      this.summaryManager.setConnected(clientId);\n    } else {\n      this.summaryManager.setDisconnected();\n    }\n  }\n  process(messageArg, local) {\n    var _a, _b;\n    this.verifyNotClosed();\n    // If it's not message for runtime, bail out right away.\n    if (!isRuntimeMessage(messageArg)) {\n      return;\n    }\n    // Do shallow copy of message, as methods below will modify it.\n    // There might be multiple container instances receiving same message\n    // We do not need to make deep copy, as each layer will just replace message.content itself,\n    // but would not modify contents details\n    let message = Object.assign({}, messageArg);\n    let error;\n    // Surround the actual processing of the operation with messages to the schedule manager indicating\n    // the beginning and end. This allows it to emit appropriate events and/or pause the processing of new\n    // messages once a batch has been fully processed.\n    this.scheduleManager.beginOperation(message);\n    try {\n      message = unpackRuntimeMessage(message);\n      // Chunk processing must come first given that we will transform the message to the unchunked version\n      // once all pieces are available\n      message = this.processRemoteChunkedMessage(message);\n      let localMessageMetadata;\n      if (local) {\n        // Call the PendingStateManager to process local messages.\n        // Do not process local chunked ops until all pieces are available.\n        if (message.type !== ContainerMessageType.ChunkedOp) {\n          localMessageMetadata = this.pendingStateManager.processPendingLocalMessage(message);\n        }\n        // If there are no more pending messages after processing a local message,\n        // the document is no longer dirty.\n        if (!this.pendingStateManager.hasPendingMessages()) {\n          this.updateDocumentDirtyState(false);\n        }\n      }\n      switch (message.type) {\n        case ContainerMessageType.Attach:\n          this.dataStores.processAttachMessage(message, local);\n          break;\n        case ContainerMessageType.FluidDataStoreOp:\n          this.dataStores.processFluidDataStoreOp(message, local, localMessageMetadata);\n          break;\n        case ContainerMessageType.BlobAttach:\n          assert((_b = (_a = message) === null || _a === void 0 ? void 0 : _a.metadata) === null || _b === void 0 ? void 0 : _b.blobId);\n          this.blobManager.addBlobId(message.metadata.blobId);\n          break;\n        default:\n      }\n      this.emit(\"op\", message);\n    } catch (e) {\n      error = e;\n      throw e;\n    } finally {\n      this.scheduleManager.endOperation(error, message);\n    }\n  }\n  processSignal(message, local) {\n    const envelope = message.content;\n    const transformed = {\n      clientId: message.clientId,\n      content: envelope.contents.content,\n      type: envelope.contents.type\n    };\n    if (envelope.address === undefined) {\n      // No address indicates a container signal message.\n      this.emit(\"signal\", transformed, local);\n      return;\n    }\n    this.dataStores.processSignal(envelope.address, transformed, local);\n  }\n  getRootDataStore(id, wait = true) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      return _this7.dataStores.getDataStore(id, wait);\n    })();\n  }\n  getDataStore(id, wait = true) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      return _this8.dataStores.getDataStore(id, wait);\n    })();\n  }\n  notifyDataStoreInstantiated(context) {\n    const fluidDataStorePkgName = context.packagePath[context.packagePath.length - 1];\n    const registryPath = `/${context.packagePath.slice(0, context.packagePath.length - 1).join(\"/\")}`;\n    this.emit(\"fluidDataStoreInstantiated\", fluidDataStorePkgName, registryPath, !context.existing);\n  }\n  setFlushMode(mode) {\n    if (mode === this._flushMode) {\n      return;\n    }\n    // If switching to manual mode add a warning trace indicating the underlying loader does not support\n    // this feature yet. Can remove in 0.9.\n    if (!this.deltaSender && mode === FlushMode.Manual) {\n      debug(\"DeltaManager does not yet support flush modes\");\n      return;\n    }\n    // Flush any pending batches if switching back to automatic\n    if (mode === FlushMode.Automatic) {\n      this.flush();\n    }\n    this._flushMode = mode;\n    // Let the PendingStateManager know that FlushMode has been updated.\n    this.pendingStateManager.onFlushModeUpdated(mode);\n  }\n  flush() {\n    if (!this.deltaSender) {\n      debug(\"DeltaManager does not yet support flush modes\");\n      return;\n    }\n    // Let the PendingStateManager know that there was an attempt to flush messages.\n    // Note that this should happen before the `this.needsFlush` check below because in the scenario where we are\n    // not connected, `this.needsFlush` will be false but the PendingStateManager might have pending messages and\n    // hence needs to track this.\n    this.pendingStateManager.onFlush();\n    // If flush has already been called then exit early\n    if (!this.needsFlush) {\n      return;\n    }\n    this.needsFlush = false;\n    return this.deltaSender.flush();\n  }\n  orderSequentially(callback) {\n    // If flush mode is already manual we are either\n    // nested in another orderSequentially, or\n    // the app is flushing manually, in which\n    // case this invocation doesn't own\n    // flushing.\n    if (this.flushMode === FlushMode.Manual) {\n      callback();\n    } else {\n      const savedFlushMode = this.flushMode;\n      this.setFlushMode(FlushMode.Manual);\n      try {\n        callback();\n      } finally {\n        this.flush();\n        this.setFlushMode(savedFlushMode);\n      }\n    }\n  }\n  createDataStore(pkg) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      return _this9._createDataStore(pkg, false /* isRoot */);\n    })();\n  }\n\n  createRootDataStore(pkg, rootDataStoreId) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const fluidDataStore = yield _this10._createDataStore(pkg, true /* isRoot */, rootDataStoreId);\n      fluidDataStore.bindToContext();\n      return fluidDataStore;\n    })();\n  }\n  createDetachedRootDataStore(pkg, rootDataStoreId) {\n    return this.dataStores.createDetachedDataStoreCore(pkg, true, rootDataStoreId);\n  }\n  createDetachedDataStore(pkg) {\n    return this.dataStores.createDetachedDataStoreCore(pkg, false);\n  }\n  _createDataStoreWithProps(pkg, props, id = uuid()) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      return _this11.dataStores._createFluidDataStoreContext(Array.isArray(pkg) ? pkg : [pkg], id, false /* isRoot */, props).realize();\n    })();\n  }\n  _createDataStore(pkg, isRoot, id = uuid()) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      return _this12.dataStores._createFluidDataStoreContext(Array.isArray(pkg) ? pkg : [pkg], id, isRoot).realize();\n    })();\n  }\n  canSendOps() {\n    return this.connected && !this.deltaManager.readonly;\n  }\n  getQuorum() {\n    return this.context.quorum;\n  }\n  getAudience() {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.context.audience;\n  }\n  raiseContainerWarning(warning) {\n    this.context.raiseContainerWarning(warning);\n  }\n  /**\n   * Notifies this object to register tasks to be performed.\n   * @param tasks - List of tasks.\n   * @param version - Version of the Fluid package.\n   */\n  registerTasks(tasks, version) {\n    this.verifyNotClosed();\n    this.tasks = tasks;\n    this.version = version;\n    if (this.leader) {\n      this.runTaskAnalyzer();\n    }\n  }\n  /**\n   * Returns true of document is dirty, i.e. there are some pending local changes that\n   * either were not sent out to delta stream or were not yet acknowledged.\n   */\n  isDocumentDirty() {\n    return this.dirtyDocument;\n  }\n  /**\n   * Will return true for any message that affect the dirty state of this document\n   * This function can be used to filter out any runtime operations that should not be affecting whether or not\n   * the IFluidDataStoreRuntime.isDocumentDirty call returns true/false\n   * @param type - The type of ContainerRuntime message that is being checked\n   * @param contents - The contents of the message that is being verified\n   */\n  isMessageDirtyable(message) {\n    assert(isRuntimeMessage(message) === true, \"Message passed for dirtyable check should be a container runtime message\");\n    return this.isContainerMessageDirtyable(message.type, message.contents);\n  }\n  isContainerMessageDirtyable(type, contents) {\n    if (type === ContainerMessageType.Attach) {\n      const attachMessage = contents;\n      if (attachMessage.id === taskSchedulerId) {\n        return false;\n      }\n    } else if (type === ContainerMessageType.FluidDataStoreOp) {\n      const envelope = contents;\n      if (envelope.address === taskSchedulerId) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Submits the signal to be sent to other clients.\n   * @param type - Type of the signal.\n   * @param content - Content of the signal.\n   */\n  submitSignal(type, content) {\n    this.verifyNotClosed();\n    const envelope = {\n      address: undefined,\n      contents: {\n        type,\n        content\n      }\n    };\n    return this.context.submitSignalFn(envelope);\n  }\n  submitDataStoreSignal(address, type, content) {\n    const envelope = {\n      address,\n      contents: {\n        type,\n        content\n      }\n    };\n    return this.context.submitSignalFn(envelope);\n  }\n  /**\n   * Returns a summary of the runtime at the current sequence number.\n   * @param fullTree - true to bypass optimizations and force a full summary tree.\n   * @param trackState - This tells whether we should track state from this summary.\n   */\n  summarize(fullTree = false, trackState = true) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const summarizeResult = yield _this13.summarizerNode.summarize(fullTree, trackState);\n      assert(summarizeResult.summary.type === 1 /* Tree */, \"Container Runtime's summarize should always return a tree\");\n      return summarizeResult;\n    })();\n  }\n  summarizeInternal(fullTree, trackState) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const summarizeResult = yield _this14.dataStores.summarize(fullTree, trackState);\n      _this14.addContainerBlobsToSummary(summarizeResult);\n      return Object.assign(Object.assign({}, summarizeResult), {\n        id: \"\"\n      });\n    })();\n  }\n  setAttachState(attachState) {\n    if (attachState === AttachState.Attaching) {\n      assert(this.attachState === AttachState.Attaching, \"Container Context should already be in attaching state\");\n    } else {\n      assert(this.attachState === AttachState.Attached, \"Container Context should already be in attached state\");\n    }\n    this.dataStores.setAttachState(attachState);\n  }\n  createSummary() {\n    const summaryTree = this.dataStores.createSummary();\n    this.addContainerBlobsToSummary(summaryTree);\n    return summaryTree.summary;\n  }\n  getAbsoluteUrl(relativeUrl) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      if (_this15.context.getAbsoluteUrl === undefined) {\n        throw new Error(\"Driver does not implement getAbsoluteUrl\");\n      }\n      if (_this15.attachState !== AttachState.Attached) {\n        return undefined;\n      }\n      return _this15.context.getAbsoluteUrl(relativeUrl);\n    })();\n  }\n  /** Implementation of ISummarizerInternalsProvider.generateSummary */\n  generateSummary(fullTree = false, safe = false, summaryLogger) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const summaryRefSeqNum = _this16.deltaManager.lastSequenceNumber;\n      const message = `Summary @${summaryRefSeqNum}:${_this16.deltaManager.minimumSequenceNumber}`;\n      _this16.summarizerNode.startSummary(summaryRefSeqNum, summaryLogger);\n      try {\n        yield _this16.deltaManager.inbound.pause();\n        const attemptData = {\n          referenceSequenceNumber: summaryRefSeqNum,\n          submitted: false\n        };\n        if (!_this16.connected) {\n          // If summarizer loses connection it will never reconnect\n          return Object.assign(Object.assign({}, attemptData), {\n            reason: \"disconnected\"\n          });\n        }\n        if (!_this16.runtimeOptions.disableGC) {\n          // Get the container's GC data and run GC on the reference graph in it.\n          const gcData = yield _this16.dataStores.getGCData();\n          const {\n            referencedNodeIds\n          } = runGarbageCollection(gcData.gcNodes, [\"/\"], _this16.logger);\n          // Update our summarizer node's used routes. Updating used routes in summarizer node before summarizing\n          // is required and asserted by the the summarizer node. We are the root and are always referenced, so\n          // the used routes is only self-route (empty string).\n          _this16.summarizerNode.updateUsedRoutes([\"\"]);\n          // Remove this node's route (\"/\") and notify data stores of routes that are used in it.\n          const usedRoutes = referencedNodeIds.filter(id => {\n            return id !== \"/\";\n          });\n          _this16.dataStores.updateUsedRoutes(usedRoutes);\n        }\n        const trace = Trace.start();\n        const summarizeResult = yield _this16.summarize(fullTree || safe, true /* trackState */);\n        const generateData = {\n          summaryStats: summarizeResult.stats,\n          generateDuration: trace.trace().duration\n        };\n        if (!_this16.connected) {\n          return Object.assign(Object.assign(Object.assign({}, attemptData), generateData), {\n            reason: \"disconnected\"\n          });\n        }\n        // Ensure that lastSequenceNumber has not changed after pausing\n        const lastSequenceNumber = _this16.deltaManager.lastSequenceNumber;\n        assert(lastSequenceNumber === summaryRefSeqNum, `lastSequenceNumber changed while paused. ${lastSequenceNumber} !== ${summaryRefSeqNum}`);\n        const handle = yield _this16.storage.uploadSummaryWithContext(summarizeResult.summary, _this16.latestSummaryAck);\n        // safe mode refreshes the latest summary ack\n        if (safe) {\n          const version = yield _this16.getVersionFromStorage(_this16.id);\n          yield _this16.refreshLatestSummaryAck(undefined, version.id, new ChildLogger(summaryLogger, undefined, {\n            safeSummary: true\n          }), version);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const parent = _this16.latestSummaryAck.ackHandle;\n        const summaryMessage = {\n          handle,\n          head: parent,\n          message,\n          parents: parent ? [parent] : []\n        };\n        const uploadData = {\n          handle,\n          uploadDuration: trace.trace().duration\n        };\n        if (!_this16.connected) {\n          return Object.assign(Object.assign(Object.assign(Object.assign({}, attemptData), generateData), uploadData), {\n            reason: \"disconnected\"\n          });\n        }\n        // We need the summary op's reference sequence number to match our summary sequence number\n        // Otherwise we'll get the wrong sequence number stamped on the summary's .protocol attributes\n        assert(_this16.deltaManager.lastSequenceNumber === summaryRefSeqNum, `lastSequenceNumber changed before the summary op could be submitted. ` + `${_this16.deltaManager.lastSequenceNumber} !== ${summaryRefSeqNum}`);\n        const clientSequenceNumber = _this16.submitSystemMessage(MessageType.Summarize, summaryMessage);\n        _this16.summarizerNode.completeSummary(handle);\n        return Object.assign(Object.assign(Object.assign(Object.assign({}, attemptData), generateData), uploadData), {\n          submitted: true,\n          clientSequenceNumber,\n          submitOpDuration: trace.trace().duration\n        });\n      } finally {\n        // Cleanup wip summary in case of failure\n        _this16.summarizerNode.clearSummary();\n        // Restart the delta manager\n        _this16.deltaManager.inbound.resume();\n      }\n    })();\n  }\n  processRemoteChunkedMessage(message) {\n    if (message.type !== ContainerMessageType.ChunkedOp) {\n      return message;\n    }\n    const clientId = message.clientId;\n    const chunkedContent = message.contents;\n    this.addChunk(clientId, chunkedContent);\n    if (chunkedContent.chunkId === chunkedContent.totalChunks) {\n      const newMessage = Object.assign({}, message);\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const serializedContent = this.chunkMap.get(clientId).join(\"\");\n      newMessage.contents = JSON.parse(serializedContent);\n      newMessage.type = chunkedContent.originalType;\n      this.clearPartialChunks(clientId);\n      return newMessage;\n    }\n    return message;\n  }\n  addChunk(clientId, chunkedContent) {\n    let map = this.chunkMap.get(clientId);\n    if (map === undefined) {\n      map = [];\n      this.chunkMap.set(clientId, map);\n    }\n    assert(chunkedContent.chunkId === map.length + 1); // 1-based indexing\n    map.push(chunkedContent.contents);\n  }\n  clearPartialChunks(clientId) {\n    if (this.chunkMap.has(clientId)) {\n      this.chunkMap.delete(clientId);\n    }\n  }\n  updateDocumentDirtyState(dirty) {\n    if (this.dirtyDocument === dirty) {\n      return;\n    }\n    this.dirtyDocument = dirty;\n    if (this.emitDirtyDocumentEvent) {\n      this.emit(dirty ? \"dirtyDocument\" : \"savedDocument\");\n    }\n  }\n  submitDataStoreOp(id, contents, localOpMetadata = undefined) {\n    const envelope = {\n      address: id,\n      contents\n    };\n    this.submit(ContainerMessageType.FluidDataStoreOp, envelope, localOpMetadata);\n  }\n  uploadBlob(blob) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      return _this17.blobManager.createBlob(blob);\n    })();\n  }\n  submit(type, content, localOpMetadata = undefined, opMetadata = undefined) {\n    this.verifyNotClosed();\n    let clientSequenceNumber = -1;\n    if (this.canSendOps()) {\n      const serializedContent = JSON.stringify(content);\n      const maxOpSize = this.context.deltaManager.maxMessageSize;\n      // If in manual flush mode we will trigger a flush at the next turn break\n      if (this.flushMode === FlushMode.Manual && !this.needsFlush) {\n        // eslint-disable-next-line no-param-reassign\n        opMetadata = Object.assign(Object.assign({}, opMetadata), {\n          batch: true\n        });\n        this.needsFlush = true;\n        // Use Promise.resolve().then() to queue a microtask to detect the end of the turn and force a flush.\n        if (!this.flushTrigger) {\n          // eslint-disable-next-line @typescript-eslint/no-floating-promises\n          Promise.resolve().then(() => {\n            this.flushTrigger = false;\n            this.flush();\n          });\n        }\n      }\n      // Note: Chunking will increase content beyond maxOpSize because we JSON'ing JSON payload -\n      // there will be a lot of escape characters that can make it up to 2x bigger!\n      // This is Ok, because DeltaManager.shouldSplit() will have 2 * maxMessageSize limit\n      if (!serializedContent || serializedContent.length <= maxOpSize) {\n        clientSequenceNumber = this.submitRuntimeMessage(type, content, /* batch: */this._flushMode === FlushMode.Manual, opMetadata);\n      } else {\n        clientSequenceNumber = this.submitChunkedMessage(type, serializedContent, maxOpSize);\n      }\n    }\n    // Let the PendingStateManager know that a message was submitted.\n    this.pendingStateManager.onSubmitMessage(type, clientSequenceNumber, content, localOpMetadata, opMetadata);\n    if (this.isContainerMessageDirtyable(type, content)) {\n      this.updateDocumentDirtyState(true);\n    }\n  }\n  submitChunkedMessage(type, content, maxOpSize) {\n    const contentLength = content.length;\n    const chunkN = Math.floor((contentLength - 1) / maxOpSize) + 1;\n    let offset = 0;\n    let clientSequenceNumber = 0;\n    for (let i = 1; i <= chunkN; i = i + 1) {\n      const chunkedOp = {\n        chunkId: i,\n        contents: content.substr(offset, maxOpSize),\n        originalType: type,\n        totalChunks: chunkN\n      };\n      offset += maxOpSize;\n      clientSequenceNumber = this.submitRuntimeMessage(ContainerMessageType.ChunkedOp, chunkedOp, false);\n    }\n    return clientSequenceNumber;\n  }\n  submitSystemMessage(type, contents) {\n    this.verifyNotClosed();\n    assert(this.connected);\n    // System message should not be sent in the middle of the batch.\n    // That said, we can preserve existing behavior by not flushing existing buffer.\n    // That might be not what caller hopes to get, but we can look deeper if telemetry tells us it's a problem.\n    const middleOfBatch = this.flushMode === FlushMode.Manual && this.needsFlush;\n    if (middleOfBatch) {\n      this._logger.sendErrorEvent({\n        eventName: \"submitSystemMessageError\",\n        type\n      });\n    }\n    return this.context.submitFn(type, contents, middleOfBatch);\n  }\n  submitRuntimeMessage(type, contents, batch, appData) {\n    const payload = {\n      type,\n      contents\n    };\n    return this.context.submitFn(MessageType.Operation, payload, batch, appData);\n  }\n  /**\n   * Throw an error if the runtime is closed.  Methods that are expected to potentially\n   * be called after dispose due to asynchrony should not call this.\n   */\n  verifyNotClosed() {\n    if (this._disposed) {\n      throw new Error(\"Runtime is closed\");\n    }\n  }\n  /**\n   * Finds the right store and asks it to resubmit the message. This typically happens when we\n   * reconnect and there are pending messages.\n   * @param content - The content of the original message.\n   * @param localOpMetadata - The local metadata associated with the original message.\n   */\n  reSubmit(type, content, localOpMetadata, opMetadata) {\n    switch (type) {\n      case ContainerMessageType.FluidDataStoreOp:\n        // For Operations, call resubmitDataStoreOp which will find the right store\n        // and trigger resubmission on it.\n        this.dataStores.resubmitDataStoreOp(content, localOpMetadata);\n        break;\n      case ContainerMessageType.Attach:\n        this.submit(type, content, localOpMetadata);\n        break;\n      case ContainerMessageType.ChunkedOp:\n        throw new Error(`chunkedOp not expected here`);\n      case ContainerMessageType.BlobAttach:\n        this.submit(type, content, localOpMetadata, opMetadata);\n        break;\n      default:\n        unreachableCase(type, `Unknown ContainerMessageType: ${type}`);\n    }\n  }\n  subscribeToLeadership() {\n    var _this18 = this;\n    if (this.context.clientDetails.capabilities.interactive) {\n      this.getScheduler().then(scheduler => {\n        const LeaderTaskId = \"leader\";\n        // Each client expresses interest to be a leader.\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        scheduler.pick(LeaderTaskId, /*#__PURE__*/_asyncToGenerator(function* () {\n          assert(!_this18._leader);\n          _this18.updateLeader(true);\n        }));\n        scheduler.on(\"lost\", key => {\n          if (key === LeaderTaskId) {\n            assert(this._leader);\n            this._leader = false;\n            this.updateLeader(false);\n          }\n        });\n      }).catch(err => {\n        this.closeFn(CreateContainerError(err));\n      });\n      this.context.quorum.on(\"removeMember\", () => {\n        if (this.leader) {\n          this.runTaskAnalyzer();\n        }\n      });\n    }\n  }\n  getTaskManager() {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      return requestFluidObject(yield _this19.getDataStore(taskSchedulerId, true), \"\");\n    })();\n  }\n  getScheduler() {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      const taskManager = yield _this20.getTaskManager();\n      return taskManager.IAgentScheduler;\n    })();\n  }\n  updateLeader(leadership) {\n    this._leader = leadership;\n    if (this.leader) {\n      assert(this.clientId === undefined || this.connected && this.deltaManager && this.deltaManager.active);\n      this.emit(\"leader\");\n    } else {\n      this.emit(\"notleader\");\n    }\n    this.dataStores.updateLeader();\n    if (this.leader) {\n      this.runTaskAnalyzer();\n    }\n  }\n  /**\n   * On a client joining/departure, decide whether this client is the new leader.\n   * If so, calculate if there are any unhandled tasks for browsers and remote agents.\n   * Emit local help message for this browser and submits a remote help message for agents.\n   */\n  runTaskAnalyzer() {\n    // Analyze the current state and ask for local and remote help separately.\n    // If called for detached container, the clientId would not be assigned and it is disconnected. In this\n    // case, all tasks are run by the detached container. Called only if a leader. If we have a clientId,\n    // then we should be connected as leadership is lost on losing connection.\n    const helpTasks = this.clientId === undefined ? {\n      browser: this.tasks,\n      robot: []\n    } : analyzeTasks(this.clientId, this.getQuorum().getMembers(), this.tasks);\n    if (helpTasks && (helpTasks.browser.length > 0 || helpTasks.robot.length > 0)) {\n      if (helpTasks.browser.length > 0) {\n        const localHelpMessage = {\n          tasks: helpTasks.browser,\n          version: this.version\n        };\n        debug(`Requesting local help for ${helpTasks.browser}`);\n        this.emit(\"localHelp\", localHelpMessage);\n      }\n      if (helpTasks.robot.length > 0) {\n        const remoteHelpMessage = {\n          tasks: helpTasks.robot,\n          version: this.version\n        };\n        debug(`Requesting remote help for ${helpTasks.robot}`);\n        this.submitSystemMessage(MessageType.RemoteHelp, remoteHelpMessage);\n      }\n    }\n  }\n  /** Implementation of ISummarizerInternalsProvider.refreshLatestSummaryAck */\n  refreshLatestSummaryAck(proposalHandle, ackHandle, summaryLogger, version) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      _this21.latestSummaryAck = {\n        proposalHandle,\n        ackHandle\n      };\n      const getSnapshot = /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* () {\n          const perfEvent = PerformanceEvent.start(summaryLogger, {\n            eventName: \"RefreshLatestSummaryGetSnapshot\",\n            hasVersion: !!version\n          });\n          const stats = {};\n          let snapshot;\n          try {\n            const trace = Trace.start();\n            const versionToUse = version !== null && version !== void 0 ? version : yield _this21.getVersionFromStorage(ackHandle);\n            stats.getVersionDuration = trace.trace().duration;\n            snapshot = yield _this21.getSnapshotFromStorage(versionToUse);\n            stats.getSnapshotDuration = trace.trace().duration;\n          } catch (error) {\n            perfEvent.cancel(stats, error);\n            throw error;\n          }\n          perfEvent.end(stats);\n          return snapshot;\n        });\n        return function getSnapshot() {\n          return _ref4.apply(this, arguments);\n        };\n      }();\n      yield _this21.summarizerNode.refreshLatestSummary(proposalHandle, getSnapshot, /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator(function* (id) {\n          return readAndParse(_this21.storage, id);\n        });\n        return function (_x4) {\n          return _ref5.apply(this, arguments);\n        };\n      }(), summaryLogger);\n    })();\n  }\n  getVersionFromStorage(versionId) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      const versions = yield _this22.storage.getVersions(versionId, 1);\n      assert(!!versions && !!versions[0], \"Failed to get version from storage\");\n      return versions[0];\n    })();\n  }\n  getSnapshotFromStorage(version) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      const snapshot = yield _this23.storage.getSnapshotTree(version);\n      assert(!!snapshot, \"Failed to get snapshot from storage\");\n      return snapshot;\n    })();\n  }\n}\n//# sourceMappingURL=containerRuntime.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}