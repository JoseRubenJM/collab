{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { schema } from '../interfaces/fluid';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../services/azure-fluid-relay.service\";\nconst _c0 = [\"textArea\"];\nexport let CollaborativeTextAreaComponent = /*#__PURE__*/(() => {\n  class CollaborativeTextAreaComponent {\n    constructor(azureClient) {\n      this.azureClient = azureClient;\n      this.text = '';\n      this.selectionEnd = 0;\n      this.selectionStart = 0;\n      this.schema = schema;\n    }\n    ngOnInit() {\n      return __awaiter(this, void 0, void 0, function* () {\n        this.client = this.azureClient.getClient();\n        // this.fluidContainer = await this.client.createContainer(this.schema)\n        // const id = await this.fluidContainer.container.attach()\n        // console.log(id)\n        this.fluidContainer = yield this.client.getContainer('2164a0e1-fba8-4300-9bc0-b6cc4b143e3a', this.schema);\n        this.sharedDescription = this.fluidContainer.container.initialObjects.description;\n        console.log(this.sharedDescription);\n        this.text = this.sharedDescription.getText();\n        // initialize sync here\n        this.syncData();\n      });\n    }\n    syncData() {\n      if (!this.sharedDescription) {\n        return;\n      }\n      console.log('init');\n      // Sets an event listener so we can update our state as the value changes\n      this.sharedDescription.on('sequenceDelta', event => {\n        console.log(event);\n        const newText = this.sharedDescription.getText();\n        // We only need to insert if the text changed.\n        if (newText === this.text) {\n          return;\n        }\n        // If the event is our own then just insert the text\n        if (event.isLocal) {\n          this.text = newText;\n          return;\n        }\n        // Because we did not make the change we need to manage the remote\n        // character insertion.\n        const remoteCaretStart = event.first.position;\n        const remoteCaretEnd = event.last.position + event.last.segment.cachedLength;\n        const charactersModifiedCount = newText.length - this.text.length;\n        this.updateSelection();\n        const currentCaretStart = this.selectionStart;\n        const currentCaretEnd = this.selectionEnd;\n        let newCaretStart = 0;\n        let newCaretEnd = 0;\n        // Remote text inserted/removed after our cp range\n        if (currentCaretEnd <= remoteCaretStart) {\n          // cp stays where it was before.\n          newCaretStart = currentCaretStart;\n          newCaretEnd = currentCaretEnd;\n        } else if (currentCaretStart > remoteCaretEnd - 1) {\n          // Remote text inserted/removed before our cp range\n          // We need to move our cp the number of characters inserted/removed\n          // to ensure we are in the same position\n          newCaretStart = currentCaretStart + charactersModifiedCount;\n          newCaretEnd = currentCaretEnd + charactersModifiedCount;\n        } else {\n          // Remote text is overlapping cp\n          // The remote changes occurred inside current selection\n          if (remoteCaretEnd <= currentCaretEnd && remoteCaretStart > currentCaretStart) {\n            // Our selection needs to include remote changes\n            newCaretStart = currentCaretStart;\n            newCaretEnd = currentCaretEnd + charactersModifiedCount;\n          } else if (remoteCaretEnd >= currentCaretEnd && remoteCaretStart <= currentCaretStart) {\n            // The remote changes encompass our location\n            // Our selection has been removed\n            // Move our cp to the beginning of the new text insertion\n            newCaretStart = remoteCaretStart;\n            newCaretEnd = remoteCaretStart;\n          } else {\n            // We have partial overlapping selection with the changes.\n            // This makes things a lot harder to manage so for now we will just remove the current selection\n            // and place it to the remote caret start.\n            newCaretStart = remoteCaretStart;\n            newCaretEnd = remoteCaretStart;\n          }\n        }\n        this.text = newText;\n        this.setCaretPosition(newCaretStart, newCaretEnd);\n        // The event we're listening for here fires outside of Angular\n        // so let it know to detect changes\n        // this.changeDetector.detectChanges()\n      });\n    }\n\n    setCaretPosition(newStart, newEnd) {\n      if (this.textArea) {\n        const textArea = this.textArea.nativeElement;\n        textArea.selectionStart = newStart;\n        textArea.selectionEnd = newEnd;\n      }\n    }\n    updateSelection() {\n      if (!this.textArea) {\n        return;\n      }\n      const textArea = this.textArea.nativeElement;\n      this.selectionStart = textArea.selectionStart ? textArea.selectionStart : 0;\n      this.selectionEnd = textArea.selectionEnd ? textArea.selectionEnd : 0;\n    }\n    handleChange(event) {\n      // We need to set the value here to keep the input responsive to the user\n      const currentTarget = event.currentTarget;\n      const newText = currentTarget.value;\n      const charactersModifiedCount = this.text.length - newText.length;\n      this.text = newText;\n      // Get the new caret position and use that to get the text that was inserted\n      const newPosition = currentTarget.selectionStart ? currentTarget.selectionStart : 0;\n      const isTextInserted = newPosition - this.selectionStart > 0;\n      if (isTextInserted) {\n        const insertedText = newText.substring(this.selectionStart, newPosition);\n        const changeRangeLength = this.selectionEnd - this.selectionStart;\n        if (changeRangeLength === 0) {\n          console.log(insertedText);\n          this.sharedDescription.insertText(this.selectionStart, insertedText);\n        } else {\n          this.sharedDescription.replaceText(this.selectionStart, this.selectionEnd, insertedText);\n        }\n      } else {\n        // Text was removed\n        this.sharedDescription.removeText(newPosition, newPosition + charactersModifiedCount);\n      }\n    }\n  }\n  CollaborativeTextAreaComponent.ɵfac = function CollaborativeTextAreaComponent_Factory(t) {\n    return new (t || CollaborativeTextAreaComponent)(i0.ɵɵdirectiveInject(i1.AzureFluidRelayService));\n  };\n  CollaborativeTextAreaComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: CollaborativeTextAreaComponent,\n    selectors: [[\"app-collaborative-text-area\"]],\n    viewQuery: function CollaborativeTextAreaComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.textArea = _t.first);\n      }\n    },\n    decls: 2,\n    vars: 1,\n    consts: [[\"rows\", \"20\", \"cols\", \"50\", 1, \"\", 3, \"value\", \"beforeinput\", \"keydown\", \"click\", \"contextmenu\", \"input\"], [\"textArea\", \"\"]],\n    template: function CollaborativeTextAreaComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"textarea\", 0, 1);\n        i0.ɵɵlistener(\"beforeinput\", function CollaborativeTextAreaComponent_Template_textarea_beforeinput_0_listener() {\n          return ctx.updateSelection();\n        })(\"keydown\", function CollaborativeTextAreaComponent_Template_textarea_keydown_0_listener() {\n          return ctx.updateSelection();\n        })(\"click\", function CollaborativeTextAreaComponent_Template_textarea_click_0_listener() {\n          return ctx.updateSelection();\n        })(\"contextmenu\", function CollaborativeTextAreaComponent_Template_textarea_contextmenu_0_listener() {\n          return ctx.updateSelection();\n        })(\"input\", function CollaborativeTextAreaComponent_Template_textarea_input_0_listener($event) {\n          return ctx.handleChange($event);\n        });\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"value\", ctx.text);\n      }\n    },\n    encapsulation: 2\n  });\n  return CollaborativeTextAreaComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}