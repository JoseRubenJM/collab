{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport * as base64js from \"base64-js\";\n/**\n * Converts a Uint8Array to a string of the provided encoding\n * Useful when the array might be an IsoBuffer\n * @param arr - The array to convert\n * @param encoding - Optional target encoding; only \"utf8\" and \"base64\" are\n * supported, with \"utf8\" being default\n * @returns The converted string\n */\nexport function Uint8ArrayToString(arr, encoding) {\n  switch (encoding) {\n    case \"base64\":\n      {\n        return base64js.fromByteArray(arr);\n      }\n    case \"utf8\":\n    case \"utf-8\":\n    case undefined:\n      {\n        return new TextDecoder().decode(arr);\n      }\n    default:\n      {\n        throw new Error(\"invalid/unsupported encoding\");\n      }\n  }\n}\n/**\n * Minimal implementation of Buffer for our usages in the browser environment.\n */\nexport class IsoBuffer extends Uint8Array {\n  /**\n   * Convert the buffer to a string.\n   * Only supports encoding the whole string (unlike the Node Buffer equivalent)\n   * and only utf8 and base64 encodings\n   * @param encoding\n   */\n  toString(encoding) {\n    return Uint8ArrayToString(this, encoding);\n  }\n  /**\n   * @param value - string | ArrayBuffer\n   * @param encodingOrOffset - string | number\n   * @param length - number\n   */\n  static from(value, encodingOrOffset, length) {\n    if (typeof value === \"string\") {\n      return IsoBuffer.fromString(value, encodingOrOffset);\n    } else if (value instanceof ArrayBuffer) {\n      return IsoBuffer.fromArrayBuffer(value, encodingOrOffset, length);\n    } else {\n      throw new TypeError();\n    }\n  }\n  static fromArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n    const offset = byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0;\n    const validLength = byteLength !== null && byteLength !== void 0 ? byteLength : arrayBuffer.byteLength - offset;\n    if (offset < 0 || offset > arrayBuffer.byteLength || validLength < 0 || validLength + offset > arrayBuffer.byteLength) {\n      throw new RangeError();\n    }\n    return new IsoBuffer(arrayBuffer, offset, validLength);\n  }\n  static fromString(str, encoding) {\n    switch (encoding) {\n      case \"base64\":\n        {\n          const sanitizedString = this.sanitizeBase64(str);\n          const encoded = base64js.toByteArray(sanitizedString);\n          return new IsoBuffer(encoded.buffer);\n        }\n      case \"utf8\":\n      case \"utf-8\":\n      case undefined:\n        {\n          const encoded = new TextEncoder().encode(str);\n          return new IsoBuffer(encoded.buffer);\n        }\n      default:\n        {\n          throw new Error(\"invalid/unsupported encoding\");\n        }\n    }\n  }\n  static isBuffer(obj) {\n    throw new Error(\"unimplemented\");\n  }\n  /**\n   * Sanitize a base64 string to provide to base64-js library.  base64-js\n   * is not as tolerant of the same malformed base64 as Node's Buffer is.\n   * @param str\n   */\n  static sanitizeBase64(str) {\n    let sanitizedStr = str;\n    // Remove everything after padding - Node buffer ignores everything\n    // after any padding whereas base64-js does not\n    sanitizedStr = sanitizedStr.split(\"=\")[0];\n    // Remove invalid characters - Node buffer strips invalid characters\n    // whereas base64-js replaces them with \"A\"\n    sanitizedStr = sanitizedStr.replace(/[^\\w+-/]/g, \"\");\n    // Check for missing padding - Node buffer tolerates missing padding\n    // whereas base64-js does not\n    if (sanitizedStr.length % 4 !== 0) {\n      const paddingArray = [\"\", \"===\", \"==\", \"=\"];\n      sanitizedStr += paddingArray[sanitizedStr.length % 4];\n    }\n    return sanitizedStr;\n  }\n}\n//# sourceMappingURL=bufferBrowser.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}