{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport url from \"url\";\nimport { BatchManager, TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport ws from \"isomorphic-ws\";\nconst protocolVersion = \"^0.1.0\";\n/**\n * Represents a connection to a stream of delta updates for routerlicious driver.\n */\nexport class WSDeltaConnection extends TypedEventEmitter {\n  constructor(tenantId, documentId, token, client, urlStr) {\n    super();\n    this.documentId = documentId;\n    const p = url.parse(urlStr);\n    const protocol = p.protocol === \"https:\" ? \"wss\" : \"ws\";\n    const wsUrl = `${protocol}://${p.host}${p.pathname}`;\n    this.socket = new ws(`${wsUrl}?documentId${encodeURIComponent(documentId)}&tenantId${encodeURIComponent(tenantId)}`);\n    this.socket.onopen = () => {\n      const connectMessage = {\n        client,\n        id: documentId,\n        mode: client.mode,\n        tenantId,\n        token,\n        versions: [protocolVersion]\n      };\n      this.sendMessage(JSON.stringify([\"connect\", connectMessage]));\n    };\n    this.socket.onmessage = ev => {\n      this.handleMessage(ev.data);\n    };\n    this.socket.onclose = ev => {\n      this.emit(\"disconnect\", ev.reason);\n    };\n    this.socket.onerror = error => {\n      // TODO need to understand if an error will always result in a close\n      this.emit(\"error\", error);\n      if (this.socket.readyState === ws.CONNECTING || this.socket.readyState === ws.OPEN) {\n        this.socket.close(-1, error.toString());\n      }\n    };\n    this.once(\"connect_document_success\", connectedMessage => {\n      this.details = connectedMessage;\n    });\n    this.submitManager = new BatchManager((submitType, work) => {\n      this.sendMessage(JSON.stringify([submitType, this.details.clientId, work]));\n    });\n  }\n  /**\n   * Represents a connection to a stream of delta updates for routerlicious driver.\n   *\n   * @param tenantId - Id of the tenant.\n   * @param id - Id of the document.\n   * @param token - Token for authorization.\n   * @param client - Client id of the client that connects to socket.\n   * @param urlStr - url to connect to delta stream.\n   * @returns Delta connection to the stream.\n   */\n  static create(tenantId, id, token, client, urlStr) {\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        const connection = new WSDeltaConnection(tenantId, id, token, client, urlStr);\n        const resolveHandler = () => {\n          resolve(connection);\n          connection.removeListener(\"disconnected\", rejectHandler);\n        };\n        const rejectHandler = error => {\n          reject(error);\n          connection.removeListener(\"connect_document_success\", resolveHandler);\n        };\n        connection.once(\"disconnected\", rejectHandler);\n        connection.once(\"connect_document_success\", resolveHandler);\n      });\n    })();\n  }\n  get clientId() {\n    return this.details.clientId;\n  }\n  get mode() {\n    return this.details.mode;\n  }\n  get claims() {\n    return this.details.claims;\n  }\n  get existing() {\n    return this.details.existing;\n  }\n  get maxMessageSize() {\n    return this.details.maxMessageSize;\n  }\n  get version() {\n    return this.details.version;\n  }\n  get initialMessages() {\n    return this.details.initialMessages;\n  }\n  get initialSignals() {\n    return this.details.initialSignals;\n  }\n  get initialClients() {\n    return this.details.initialClients;\n  }\n  get serviceConfiguration() {\n    return this.details.serviceConfiguration;\n  }\n  /**\n   * Submits a new delta operation to the server\n   */\n  submit(messages) {\n    this.submitManager.add(\"submitOp\", messages);\n  }\n  /**\n   * Submits a new signal to the server\n   */\n  submitSignal(message) {\n    this.submitManager.add(\"submitSignal\", message);\n  }\n  close() {\n    this.socket.close();\n  }\n  handleMessage(data) {\n    const args = JSON.parse(data);\n    this.emit(args[0], ...args.slice(1));\n  }\n  sendMessage(message) {\n    // NOTE: We use which is isomorphic-ws, and it maps either to WebSocket (in browser) or ws (in Node.js)\n    // Later has callback (2nd argument to send), but the former does not!\n    // If you are enabling WebSockets (this code path is not used right now), and this causes trouble,\n    // please refactor code appropriately to make it work, and not lose error notifications in either case!\n    this.socket.send(message, error => {\n      if (error) {\n        this.emit(\"error\", error);\n      }\n    });\n  }\n}\n//# sourceMappingURL=wsDeltaConnection.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}