{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, fromBase64ToUtf8, TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport { addBlobToTree } from \"@fluidframework/protocol-base\";\nimport { MessageType } from \"@fluidframework/protocol-definitions\";\nimport { SharedObject, ValueType } from \"@fluidframework/shared-object-base\";\nimport * as path from \"path-browserify\";\nimport { debug } from \"./debug\";\nimport { LocalValueMaker, makeSerializable } from \"./localValues\";\nimport { pkgVersion } from \"./packageVersion\";\n// We use path-browserify since this code can run safely on the server or the browser.\n// We standardize on using posix slashes everywhere.\nconst posix = path.posix;\nconst snapshotFileName = \"header\";\nfunction serializeDirectory(root, serializer) {\n  const MinValueSizeSeparateSnapshotBlob = 8 * 1024;\n  const tree = {\n    entries: []\n  };\n  let counter = 0;\n  const blobs = [];\n  const stack = [];\n  const content = {};\n  stack.push([root, content]);\n  while (stack.length > 0) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const [currentSubDir, currentSubDirObject] = stack.pop();\n    for (const [key, value] of currentSubDir.getSerializedStorage(serializer)) {\n      if (!currentSubDirObject.storage) {\n        currentSubDirObject.storage = {};\n      }\n      const result = {\n        type: value.type,\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        value: value.value && JSON.parse(value.value)\n      };\n      if (value.value && value.value.length >= MinValueSizeSeparateSnapshotBlob) {\n        const extraContent = {};\n        let largeContent = extraContent;\n        if (currentSubDir.absolutePath !== posix.sep) {\n          for (const dir of currentSubDir.absolutePath.substr(1).split(posix.sep)) {\n            const subDataObject = {};\n            largeContent.subdirectories = {\n              [dir]: subDataObject\n            };\n            largeContent = subDataObject;\n          }\n        }\n        largeContent.storage = {\n          [key]: result\n        };\n        const blobName = `blob${counter}`;\n        counter++;\n        blobs.push(blobName);\n        addBlobToTree(tree, blobName, extraContent);\n      } else {\n        currentSubDirObject.storage[key] = result;\n      }\n    }\n    for (const [subdirName, subdir] of currentSubDir.subdirectories()) {\n      if (!currentSubDirObject.subdirectories) {\n        currentSubDirObject.subdirectories = {};\n      }\n      const subDataObject = {};\n      currentSubDirObject.subdirectories[subdirName] = subDataObject;\n      stack.push([subdir, subDataObject]);\n    }\n  }\n  const newFormat = {\n    blobs,\n    content\n  };\n  addBlobToTree(tree, snapshotFileName, newFormat);\n  return tree;\n}\n/**\n * The factory that defines the directory.\n * @sealed\n */\nexport class DirectoryFactory {\n  /**\n   * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.\"type\"}\n   */\n  get type() {\n    return DirectoryFactory.Type;\n  }\n  /**\n   * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}\n   */\n  get attributes() {\n    return DirectoryFactory.Attributes;\n  }\n  /**\n   * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}\n   */\n  load(runtime, id, services, attributes) {\n    return _asyncToGenerator(function* () {\n      const directory = new SharedDirectory(id, runtime, attributes);\n      yield directory.load(services);\n      return directory;\n    })();\n  }\n  /**\n   * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.create}\n   */\n  create(runtime, id) {\n    const directory = new SharedDirectory(id, runtime, DirectoryFactory.Attributes);\n    directory.initializeLocal();\n    return directory;\n  }\n}\n/**\n * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.\"type\"}\n */\nDirectoryFactory.Type = \"https://graph.microsoft.com/types/directory\";\n/**\n * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}\n */\nDirectoryFactory.Attributes = {\n  type: DirectoryFactory.Type,\n  snapshotFormatVersion: \"0.1\",\n  packageVersion: pkgVersion\n};\n/**\n * SharedDirectory provides a hierarchical organization of map-like data structures as SubDirectories.\n * The values stored within can be accessed like a map, and the hierarchy can be navigated using path syntax.\n * SubDirectories can be retrieved for use as working directories.\n *\n * @example\n * ```ts\n * mySharedDirectory.createSubDirectory(\"a\").createSubDirectory(\"b\").createSubDirectory(\"c\").set(\"foo\", val1);\n * const mySubDir = mySharedDirectory.getWorkingDirectory(\"/a/b/c\");\n * mySubDir.get(\"foo\"); // returns val1\n * ```\n *\n * @sealed\n */\nexport class SharedDirectory extends SharedObject {\n  /**\n   * Constructs a new shared directory. If the object is non-local an id and service interfaces will\n   * be provided.\n   * @param id - String identifier for the SharedDirectory\n   * @param runtime - Data store runtime\n   * @param type - Type identifier\n   */\n  constructor(id, runtime, attributes) {\n    super(id, runtime, attributes);\n    /**\n     * String representation for the class.\n     */\n    this[Symbol.toStringTag] = \"SharedDirectory\";\n    /**\n     * Root of the SharedDirectory, most operations on the SharedDirectory itself act on the root.\n     */\n    this.root = new SubDirectory(this, this.runtime, this.serializer, posix.sep);\n    /**\n     * Mapping of op types to message handlers.\n     */\n    this.messageHandlers = new Map();\n    this.localValueMaker = new LocalValueMaker(this.serializer);\n    this.setMessageHandlers();\n    // Mirror the containedValueChanged op on the SharedDirectory\n    this.root.on(\"containedValueChanged\", (changed, local) => {\n      this.emit(\"containedValueChanged\", changed, local, this);\n    });\n  }\n  /**\n   * Create a new shared directory\n   *\n   * @param runtime - Data store runtime the new shared directory belongs to\n   * @param id - Optional name of the shared directory\n   * @returns Newly create shared directory (but not attached yet)\n   */\n  static create(runtime, id) {\n    return runtime.createChannel(id, DirectoryFactory.Type);\n  }\n  /**\n   * Get a factory for SharedDirectory to register with the data store.\n   *\n   * @returns A factory that creates and load SharedDirectory\n   */\n  static getFactory() {\n    return new DirectoryFactory();\n  }\n  /**\n   * {@inheritDoc IDirectory.absolutePath}\n   */\n  get absolutePath() {\n    return this.root.absolutePath;\n  }\n  /**\n   * {@inheritDoc IDirectory.get}\n   */\n  get(key) {\n    return this.root.get(key);\n  }\n  /**\n   * {@inheritDoc IDirectory.wait}\n   */\n  wait(key) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.root.wait(key);\n    })();\n  }\n  /**\n   * {@inheritDoc IDirectory.set}\n   */\n  set(key, value) {\n    this.root.set(key, value);\n    return this;\n  }\n  /**\n   * Deletes the given key from within this IDirectory.\n   * @param key - The key to delete\n   * @returns True if the key existed and was deleted, false if it did not exist\n   */\n  delete(key) {\n    return this.root.delete(key);\n  }\n  /**\n   * Deletes all keys from within this IDirectory.\n   */\n  clear() {\n    this.root.clear();\n  }\n  /**\n   * Checks whether the given key exists in this IDirectory.\n   * @param key - The key to check\n   * @returns True if the key exists, false otherwise\n   */\n  has(key) {\n    return this.root.has(key);\n  }\n  /**\n   * The number of entries under this IDirectory.\n   */\n  get size() {\n    return this.root.size;\n  }\n  /**\n   * Issue a callback on each entry under this IDirectory.\n   * @param callback - Callback to issue\n   */\n  forEach(callback) {\n    this.root.forEach(callback);\n  }\n  /**\n   * Get an iterator over the entries under this IDirectory.\n   * @returns The iterator\n   */\n  [Symbol.iterator]() {\n    return this.root[Symbol.iterator]();\n  }\n  /**\n   * Get an iterator over the entries under this IDirectory.\n   * @returns The iterator\n   */\n  entries() {\n    return this.root.entries();\n  }\n  /**\n   * Get an iterator over the keys under this IDirectory.\n   * @returns The iterator\n   */\n  keys() {\n    return this.root.keys();\n  }\n  /**\n   * Get an iterator over the values under this IDirectory.\n   * @returns The iterator\n   */\n  values() {\n    return this.root.values();\n  }\n  /**\n   * {@inheritDoc IDirectory.createSubDirectory}\n   */\n  createSubDirectory(subdirName) {\n    return this.root.createSubDirectory(subdirName);\n  }\n  /**\n   * {@inheritDoc IDirectory.getSubDirectory}\n   */\n  getSubDirectory(subdirName) {\n    return this.root.getSubDirectory(subdirName);\n  }\n  /**\n   * {@inheritDoc IDirectory.hasSubDirectory}\n   */\n  hasSubDirectory(subdirName) {\n    return this.root.hasSubDirectory(subdirName);\n  }\n  /**\n   * {@inheritDoc IDirectory.deleteSubDirectory}\n   */\n  deleteSubDirectory(subdirName) {\n    return this.root.deleteSubDirectory(subdirName);\n  }\n  /**\n   * {@inheritDoc IDirectory.subdirectories}\n   */\n  subdirectories() {\n    return this.root.subdirectories();\n  }\n  /**\n   * {@inheritDoc IDirectory.getWorkingDirectory}\n   */\n  getWorkingDirectory(relativePath) {\n    const absolutePath = this.makeAbsolute(relativePath);\n    if (absolutePath === posix.sep) {\n      return this.root;\n    }\n    let currentSubDir = this.root;\n    const subdirs = absolutePath.substr(1).split(posix.sep);\n    for (const subdir of subdirs) {\n      currentSubDir = currentSubDir.getSubDirectory(subdir);\n      if (!currentSubDir) {\n        return undefined;\n      }\n    }\n    return currentSubDir;\n  }\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.snapshotCore}\n   */\n  snapshotCore(serializer) {\n    return serializeDirectory(this.root, serializer);\n  }\n  /**\n   * Submits an operation\n   * @param op - Op to submit\n   * @param localOpMetadata - The local metadata associated with the op. We send a unique id that is used to track\n   * this op while it has not been ack'd. This will be sent when we receive this op back from the server.\n   * @internal\n   */\n  submitDirectoryMessage(op, localOpMetadata) {\n    this.submitLocalMessage(op, localOpMetadata);\n  }\n  /**\n   * Create an emitter for a value type to emit ops from the given key and path.\n   * @param key - The key of the directory that the value type will be stored on\n   * @param absolutePath - The absolute path of the subdirectory storing the value type\n   * @returns A value op emitter for the given key and path\n   * @internal\n   */\n  makeDirectoryValueOpEmitter(key, absolutePath) {\n    const emit = (opName, previousValue, params) => {\n      const op = {\n        key,\n        path: absolutePath,\n        type: \"act\",\n        value: {\n          opName,\n          value: params\n        }\n      };\n      // Send the localOpMetadata as undefined because we don't care about the ack.\n      this.submitDirectoryMessage(op, undefined /* localOpMetadata */);\n      const event = {\n        key,\n        path: absolutePath,\n        previousValue\n      };\n      this.emit(\"valueChanged\", event, true, null, this);\n    };\n    return {\n      emit\n    };\n  }\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.onDisconnect}\n   */\n  onDisconnect() {\n    debug(`Directory ${this.id} is now disconnected`);\n  }\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.reSubmitCore}\n   */\n  reSubmitCore(content, localOpMetadata) {\n    const message = content;\n    const handler = this.messageHandlers.get(message.type);\n    assert(handler !== undefined, `Missing message handler for message type: ${message.type}`);\n    handler.submit(message, localOpMetadata);\n  }\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}\n   */\n  loadCore(storage) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const header = yield storage.read(snapshotFileName);\n      const data = JSON.parse(fromBase64ToUtf8(header));\n      const newFormat = data;\n      if (Array.isArray(newFormat.blobs)) {\n        // New storage format\n        _this2.populate(newFormat.content);\n        yield Promise.all(newFormat.blobs.map( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (blob) {\n            const blobContent = yield storage.read(blob);\n            const dataExtra = JSON.parse(fromBase64ToUtf8(blobContent));\n            _this2.populate(dataExtra);\n          });\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }()));\n      } else {\n        // Old storage format\n        _this2.populate(data);\n      }\n    })();\n  }\n  /**\n   * Populate the directory with the given directory data.\n   * @param data - A JSON string containing serialized directory data\n   * @internal\n   */\n  populate(data) {\n    const stack = [];\n    stack.push([this.root, data]);\n    while (stack.length > 0) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const [currentSubDir, currentSubDirObject] = stack.pop();\n      if (currentSubDirObject.subdirectories) {\n        for (const [subdirName, subdirObject] of Object.entries(currentSubDirObject.subdirectories)) {\n          let newSubDir = currentSubDir.getSubDirectory(subdirName);\n          if (!newSubDir) {\n            newSubDir = new SubDirectory(this, this.runtime, this.serializer, posix.join(currentSubDir.absolutePath, subdirName));\n            currentSubDir.populateSubDirectory(subdirName, newSubDir);\n          }\n          stack.push([newSubDir, subdirObject]);\n        }\n      }\n      if (currentSubDirObject.storage) {\n        for (const [key, serializable] of Object.entries(currentSubDirObject.storage)) {\n          const localValue = this.makeLocal(key, currentSubDir.absolutePath, serializable);\n          currentSubDir.populateStorage(key, localValue);\n        }\n      }\n    }\n  }\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.registerCore}\n   */\n  registerCore() {\n    const subdirsToRegisterFrom = new Array();\n    subdirsToRegisterFrom.push(this.root);\n    for (const currentSubDir of subdirsToRegisterFrom) {\n      for (const value of currentSubDir.values()) {\n        if (SharedObject.is(value)) {\n          value.bindToContext();\n        }\n      }\n      for (const [, subdir] of currentSubDir.subdirectories()) {\n        subdirsToRegisterFrom.push(subdir);\n      }\n    }\n  }\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.processCore}\n   */\n  processCore(message, local, localOpMetadata) {\n    if (message.type === MessageType.Operation) {\n      const op = message.contents;\n      const handler = this.messageHandlers.get(op.type);\n      assert(handler !== undefined, `Missing message handler for message type: ${message.type}`);\n      handler.process(op, local, message, localOpMetadata);\n    }\n  }\n  /**\n   * Converts the given relative path to absolute against the root.\n   * @param relativePath - The path to convert\n   */\n  makeAbsolute(relativePath) {\n    return posix.resolve(posix.sep, relativePath);\n  }\n  /**\n   * The remote ISerializableValue we're receiving (either as a result of a snapshot load or an incoming set op)\n   * will have the information we need to create a real object, but will not be the real object yet.  For example,\n   * we might know it's a map and the ID but not have the actual map or its data yet.  makeLocal's job\n   * is to convert that information into a real object for local usage.\n   * @param key - Key of element being converted\n   * @param absolutePath - Path of element being converted\n   * @param serializable - The remote information that we can convert into a real object\n   * @returns The local value that was produced\n   */\n  makeLocal(key, absolutePath, serializable) {\n    if (serializable.type === ValueType[ValueType.Plain] || serializable.type === ValueType[ValueType.Shared]) {\n      return this.localValueMaker.fromSerializable(serializable);\n    } else {\n      return this.localValueMaker.fromSerializableValueType(serializable, this.makeDirectoryValueOpEmitter(key, absolutePath));\n    }\n  }\n  /**\n   * Set the message handlers for the directory.\n   */\n  setMessageHandlers() {\n    this.messageHandlers.set(\"clear\", {\n      process: (op, local, message, localOpMetadata) => {\n        const subdir = this.getWorkingDirectory(op.path);\n        if (subdir) {\n          subdir.processClearMessage(op, local, message, localOpMetadata);\n        }\n      },\n      submit: (op, localOpMetadata) => {\n        const subdir = this.getWorkingDirectory(op.path);\n        if (subdir) {\n          // We don't reuse the metadata but send a new one on each submit.\n          subdir.submitClearMessage(op);\n        }\n      }\n    });\n    this.messageHandlers.set(\"delete\", {\n      process: (op, local, message, localOpMetadata) => {\n        const subdir = this.getWorkingDirectory(op.path);\n        if (subdir) {\n          subdir.processDeleteMessage(op, local, message, localOpMetadata);\n        }\n      },\n      submit: (op, localOpMetadata) => {\n        const subdir = this.getWorkingDirectory(op.path);\n        if (subdir) {\n          // We don't reuse the metadata but send a new one on each submit.\n          subdir.submitKeyMessage(op);\n        }\n      }\n    });\n    this.messageHandlers.set(\"set\", {\n      process: (op, local, message, localOpMetadata) => {\n        const subdir = this.getWorkingDirectory(op.path);\n        if (subdir) {\n          const context = local ? undefined : this.makeLocal(op.key, op.path, op.value);\n          subdir.processSetMessage(op, context, local, message, localOpMetadata);\n        }\n      },\n      submit: (op, localOpMetadata) => {\n        const subdir = this.getWorkingDirectory(op.path);\n        if (subdir) {\n          // We don't reuse the metadata but send a new one on each submit.\n          subdir.submitKeyMessage(op);\n        }\n      }\n    });\n    this.messageHandlers.set(\"createSubDirectory\", {\n      process: (op, local, message, localOpMetadata) => {\n        const parentSubdir = this.getWorkingDirectory(op.path);\n        if (parentSubdir) {\n          parentSubdir.processCreateSubDirectoryMessage(op, local, message, localOpMetadata);\n        }\n      },\n      submit: (op, localOpMetadata) => {\n        const parentSubdir = this.getWorkingDirectory(op.path);\n        if (parentSubdir) {\n          // We don't reuse the metadata but send a new one on each submit.\n          parentSubdir.submitSubDirectoryMessage(op);\n        }\n      }\n    });\n    this.messageHandlers.set(\"deleteSubDirectory\", {\n      process: (op, local, message, localOpMetadata) => {\n        const parentSubdir = this.getWorkingDirectory(op.path);\n        if (parentSubdir) {\n          parentSubdir.processDeleteSubDirectoryMessage(op, local, message, localOpMetadata);\n        }\n      },\n      submit: (op, localOpMetadata) => {\n        const parentSubdir = this.getWorkingDirectory(op.path);\n        if (parentSubdir) {\n          // We don't reuse the metadata but send a new one on each submit.\n          parentSubdir.submitSubDirectoryMessage(op);\n        }\n      }\n    });\n    // Ops with type \"act\" describe actions taken by custom value type handlers of whatever item is\n    // being addressed.  These custom handlers can be retrieved from the ValueTypeLocalValue which has\n    // stashed its valueType (and therefore its handlers).  We also emit a valueChanged for anyone\n    // watching for manipulations of that item.\n    this.messageHandlers.set(\"act\", {\n      process: (op, local, message, localOpMetadata) => {\n        const subdir = this.getWorkingDirectory(op.path);\n        // Subdir might not exist if we deleted it\n        if (!subdir) {\n          return;\n        }\n        const localValue = subdir.getLocalValue(op.key);\n        // Local value might not exist if we deleted it\n        if (!localValue) {\n          return;\n        }\n        const handler = localValue.getOpHandler(op.value.opName);\n        const previousValue = localValue.value;\n        const translatedValue = this.serializer.parse(JSON.stringify(op.value.value));\n        handler.process(previousValue, translatedValue, local, message);\n        const event = {\n          key: op.key,\n          path: op.path,\n          previousValue\n        };\n        this.emit(\"valueChanged\", event, local, message, this);\n      },\n      submit: (op, localOpMetadata) => {\n        this.submitDirectoryMessage(op, localOpMetadata);\n      }\n    });\n  }\n}\n/**\n * Node of the directory tree.\n * @sealed\n */\nclass SubDirectory extends TypedEventEmitter {\n  /**\n   * Constructor.\n   * @param directory - Reference back to the SharedDirectory to perform operations\n   * @param runtime - The data store runtime this directory is associated with\n   * @param serializer - The serializer to serialize / parse handles\n   * @param absolutePath - The absolute path of this IDirectory\n   */\n  constructor(directory, runtime, serializer, absolutePath) {\n    super();\n    this.directory = directory;\n    this.runtime = runtime;\n    this.serializer = serializer;\n    this.absolutePath = absolutePath;\n    /**\n     * String representation for the class.\n     */\n    this[Symbol.toStringTag] = \"SubDirectory\";\n    /**\n     * The in-memory data the directory is storing.\n     */\n    this._storage = new Map();\n    /**\n     * The subdirectories the directory is holding.\n     */\n    this._subdirectories = new Map();\n    /**\n     * Keys that have been modified locally but not yet ack'd from the server.\n     */\n    this.pendingKeys = new Map();\n    /**\n     * Subdirectories that have been modified locally but not yet ack'd from the server.\n     */\n    this.pendingSubDirectories = new Map();\n    /**\n     * This is used to assign a unique id to every outgoing operation and helps in tracking unack'd ops.\n     */\n    this.pendingMessageId = -1;\n    /**\n     * If a clear has been performed locally but not yet ack'd from the server, then this stores the pending id\n     * of that clear operation. Otherwise, is -1.\n     */\n    this.pendingClearMessageId = -1;\n  }\n  /**\n   * Checks whether the given key exists in this IDirectory.\n   * @param key - The key to check\n   * @returns True if the key exists, false otherwise\n   */\n  has(key) {\n    return this._storage.has(key);\n  }\n  /**\n   * {@inheritDoc IDirectory.get}\n   */\n  get(key) {\n    var _a;\n    return (_a = this._storage.get(key)) === null || _a === void 0 ? void 0 : _a.value;\n  }\n  /**\n   * {@inheritDoc IDirectory.wait}\n   */\n  wait(key) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      // Return immediately if the value already exists\n      if (_this3._storage.has(key)) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return _this3._storage.get(key).value;\n      }\n      // Otherwise subscribe to changes\n      return new Promise((resolve, reject) => {\n        const callback = changed => {\n          if (_this3.absolutePath === changed.path && key === changed.key) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            resolve(_this3._storage.get(key).value);\n            _this3.directory.removeListener(\"valueChanged\", callback);\n          }\n        };\n        _this3.directory.on(\"valueChanged\", callback);\n      });\n    })();\n  }\n  /**\n   * {@inheritDoc IDirectory.set}\n   */\n  set(key, value) {\n    // Undefined/null keys can't be serialized to JSON in the manner we currently snapshot.\n    if (key === undefined || key === null) {\n      throw new Error(\"Undefined and null keys are not supported\");\n    }\n    // Create a local value and serialize it.\n    const localValue = this.directory.localValueMaker.fromInMemory(value);\n    const serializableValue = makeSerializable(localValue, this.serializer, this.directory.handle);\n    // Set the value locally.\n    this.setCore(key, localValue, true, null);\n    // If we are not attached, don't submit the op.\n    if (!this.directory.isAttached()) {\n      return this;\n    }\n    const op = {\n      key,\n      path: this.absolutePath,\n      type: \"set\",\n      value: serializableValue\n    };\n    this.submitKeyMessage(op);\n    return this;\n  }\n  /**\n   * {@inheritDoc IDirectory.createSubDirectory}\n   */\n  createSubDirectory(subdirName) {\n    // Undefined/null subdirectory names can't be serialized to JSON in the manner we currently snapshot.\n    if (subdirName === undefined || subdirName === null) {\n      throw new Error(\"SubDirectory name may not be undefined or null\");\n    }\n    if (subdirName.includes(posix.sep)) {\n      throw new Error(`SubDirectory name may not contain ${posix.sep}`);\n    }\n    // Create the sub directory locally first.\n    this.createSubDirectoryCore(subdirName, true, null);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const subDir = this._subdirectories.get(subdirName);\n    // If we are not attached, don't submit the op.\n    if (!this.directory.isAttached()) {\n      return subDir;\n    }\n    const op = {\n      path: this.absolutePath,\n      subdirName,\n      type: \"createSubDirectory\"\n    };\n    this.submitSubDirectoryMessage(op);\n    return subDir;\n  }\n  /**\n   * {@inheritDoc IDirectory.getSubDirectory}\n   */\n  getSubDirectory(subdirName) {\n    return this._subdirectories.get(subdirName);\n  }\n  /**\n   * {@inheritDoc IDirectory.hasSubDirectory}\n   */\n  hasSubDirectory(subdirName) {\n    return this._subdirectories.has(subdirName);\n  }\n  /**\n   * {@inheritDoc IDirectory.deleteSubDirectory}\n   */\n  deleteSubDirectory(subdirName) {\n    // Delete the sub directory locally first.\n    const successfullyRemoved = this.deleteSubDirectoryCore(subdirName, true, null);\n    // If we are not attached, don't submit the op.\n    if (!this.directory.isAttached()) {\n      return successfullyRemoved;\n    }\n    const op = {\n      path: this.absolutePath,\n      subdirName,\n      type: \"deleteSubDirectory\"\n    };\n    this.submitSubDirectoryMessage(op);\n    return successfullyRemoved;\n  }\n  /**\n   * {@inheritDoc IDirectory.subdirectories}\n   */\n  subdirectories() {\n    return this._subdirectories.entries();\n  }\n  /**\n   * {@inheritDoc IDirectory.getWorkingDirectory}\n   */\n  getWorkingDirectory(relativePath) {\n    return this.directory.getWorkingDirectory(this.makeAbsolute(relativePath));\n  }\n  /**\n   * Deletes the given key from within this IDirectory.\n   * @param key - The key to delete\n   * @returns True if the key existed and was deleted, false if it did not exist\n   */\n  delete(key) {\n    // Delete the key locally first.\n    const successfullyRemoved = this.deleteCore(key, true, null);\n    // If we are not attached, don't submit the op.\n    if (!this.directory.isAttached()) {\n      return successfullyRemoved;\n    }\n    const op = {\n      key,\n      path: this.absolutePath,\n      type: \"delete\"\n    };\n    this.submitKeyMessage(op);\n    return successfullyRemoved;\n  }\n  /**\n   * Deletes all keys from within this IDirectory.\n   */\n  clear() {\n    // Clear the data locally first.\n    this.clearCore(true, null);\n    // If we are not attached, don't submit the op.\n    if (!this.directory.isAttached()) {\n      return;\n    }\n    const op = {\n      path: this.absolutePath,\n      type: \"clear\"\n    };\n    this.submitClearMessage(op);\n  }\n  /**\n   * Issue a callback on each entry under this IDirectory.\n   * @param callback - Callback to issue\n   */\n  forEach(callback) {\n    this._storage.forEach((localValue, key, map) => {\n      callback(localValue.value, key, map);\n    });\n  }\n  /**\n   * The number of entries under this IDirectory.\n   */\n  get size() {\n    return this._storage.size;\n  }\n  /**\n   * Get an iterator over the entries under this IDirectory.\n   * @returns The iterator\n   */\n  entries() {\n    const localEntriesIterator = this._storage.entries();\n    const iterator = {\n      next() {\n        const nextVal = localEntriesIterator.next();\n        if (nextVal.done) {\n          return {\n            value: undefined,\n            done: true\n          };\n        } else {\n          // Unpack the stored value\n          return {\n            value: [nextVal.value[0], nextVal.value[1].value],\n            done: false\n          };\n        }\n      },\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n    return iterator;\n  }\n  /**\n   * Get an iterator over the keys under this IDirectory.\n   * @returns The iterator\n   */\n  keys() {\n    return this._storage.keys();\n  }\n  /**\n   * Get an iterator over the values under this IDirectory.\n   * @returns The iterator\n   */\n  values() {\n    const localValuesIterator = this._storage.values();\n    const iterator = {\n      next() {\n        const nextVal = localValuesIterator.next();\n        if (nextVal.done) {\n          return {\n            value: undefined,\n            done: true\n          };\n        } else {\n          // Unpack the stored value\n          return {\n            value: nextVal.value.value,\n            done: false\n          };\n        }\n      },\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n    return iterator;\n  }\n  /**\n   * Get an iterator over the entries under this IDirectory.\n   * @returns The iterator\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Process a clear operation.\n   * @param op - The op to process\n   * @param local - Whether the message originated from the local client\n   * @param message - The message\n   * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n   * For messages from a remote client, this will be undefined.\n   * @internal\n   */\n  processClearMessage(op, local, message, localOpMetadata) {\n    if (local) {\n      assert(localOpMetadata !== undefined, `pendingMessageId is missing from the local client's ${op.type} operation`);\n      const pendingMessageId = localOpMetadata;\n      if (this.pendingClearMessageId === pendingMessageId) {\n        this.pendingClearMessageId = -1;\n      }\n      return;\n    }\n    this.clearExceptPendingKeys();\n    this.directory.emit(\"clear\", local, op, this.directory);\n  }\n  /**\n   * Process a delete operation.\n   * @param op - The op to process\n   * @param local - Whether the message originated from the local client\n   * @param message - The message\n   * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n   * For messages from a remote client, this will be undefined.\n   * @internal\n   */\n  processDeleteMessage(op, local, message, localOpMetadata) {\n    if (!this.needProcessStorageOperation(op, local, message, localOpMetadata)) {\n      return;\n    }\n    this.deleteCore(op.key, local, message);\n  }\n  /**\n   * Process a set operation.\n   * @param op - The op to process\n   * @param local - Whether the message originated from the local client\n   * @param message - The message\n   * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n   * For messages from a remote client, this will be undefined.\n   * @internal\n   */\n  processSetMessage(op, context, local, message, localOpMetadata) {\n    if (!this.needProcessStorageOperation(op, local, message, localOpMetadata)) {\n      return;\n    }\n    // needProcessStorageOperation should have returned false if local is true\n    // so we can assume context is not undefined\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.setCore(op.key, context, local, message);\n  }\n  /**\n   * Process a create subdirectory operation.\n   * @param op - The op to process\n   * @param local - Whether the message originated from the local client\n   * @param message - The message\n   * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n   * For messages from a remote client, this will be undefined.\n   * @internal\n   */\n  processCreateSubDirectoryMessage(op, local, message, localOpMetadata) {\n    if (!this.needProcessSubDirectoryOperations(op, local, message, localOpMetadata)) {\n      return;\n    }\n    this.createSubDirectoryCore(op.subdirName, local, message);\n  }\n  /**\n   * Process a delete subdirectory operation.\n   * @param op - The op to process\n   * @param local - Whether the message originated from the local client\n   * @param message - The message\n   * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n   * For messages from a remote client, this will be undefined.\n   * @internal\n   */\n  processDeleteSubDirectoryMessage(op, local, message, localOpMetadata) {\n    if (!this.needProcessSubDirectoryOperations(op, local, message, localOpMetadata)) {\n      return;\n    }\n    this.deleteSubDirectoryCore(op.subdirName, local, message);\n  }\n  /**\n   * Submit a clear operation.\n   * @param op - The operation\n   * @internal\n   */\n  submitClearMessage(op) {\n    const pendingMessageId = ++this.pendingMessageId;\n    this.directory.submitDirectoryMessage(op, pendingMessageId);\n    this.pendingClearMessageId = pendingMessageId;\n  }\n  /**\n   * Submit a key operation.\n   * @param op - The operation\n   * @internal\n   */\n  submitKeyMessage(op) {\n    const pendingMessageId = ++this.pendingMessageId;\n    this.directory.submitDirectoryMessage(op, pendingMessageId);\n    this.pendingKeys.set(op.key, pendingMessageId);\n  }\n  /**\n   * Submit a subdirectory operation.\n   * @param op - The operation\n   * @internal\n   */\n  submitSubDirectoryMessage(op) {\n    const pendingMessageId = ++this.pendingMessageId;\n    this.directory.submitDirectoryMessage(op, pendingMessageId);\n    this.pendingSubDirectories.set(op.subdirName, pendingMessageId);\n  }\n  /**\n   * Get the storage of this subdirectory in a serializable format, to be used in snapshotting.\n   * @param serializer - The serializer to use to serialize handles in its values.\n   * @returns The JSONable string representing the storage of this subdirectory\n   * @internal\n   */\n  *getSerializedStorage(serializer) {\n    for (const [key, localValue] of this._storage) {\n      const value = localValue.makeSerialized(serializer, this.directory.handle);\n      const res = [key, value];\n      yield res;\n    }\n  }\n  /**\n   * Populate a key value in this subdirectory's storage, to be used when loading from snapshot.\n   * @param key - The key to populate\n   * @param localValue - The local value to populate into it\n   * @internal\n   */\n  populateStorage(key, localValue) {\n    this._storage.set(key, localValue);\n  }\n  /**\n   * Populate a subdirectory into this subdirectory, to be used when loading from snapshot.\n   * @param subdirName - The name of the subdirectory to add\n   * @param newSubDir - The new subdirectory to add\n   * @internal\n   */\n  populateSubDirectory(subdirName, newSubDir) {\n    this._subdirectories.set(subdirName, newSubDir);\n  }\n  /**\n   * Retrieve the local value at the given key.  This is used to get value type information stashed on the local\n   * value so op handlers can be retrieved\n   * @param key - The key to retrieve from\n   * @returns The local value\n   * @internal\n   */\n  getLocalValue(key) {\n    return this._storage.get(key);\n  }\n  /**\n   * Converts the given relative path into an absolute path.\n   * @param path - Relative path to convert\n   * @returns The equivalent absolute path\n   */\n  makeAbsolute(relativePath) {\n    return posix.resolve(this.absolutePath, relativePath);\n  }\n  /**\n   * If our local operations that have not yet been ack'd will eventually overwrite an incoming operation, we should\n   * not process the incoming operation.\n   * @param op - Operation to check\n   * @param local - Whether the message originated from the local client\n   * @param message - The message\n   * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n   * For messages from a remote client, this will be undefined.\n   * @returns True if the operation should be processed, false otherwise\n   */\n  needProcessStorageOperation(op, local, message, localOpMetadata) {\n    if (this.pendingClearMessageId !== -1) {\n      if (local) {\n        assert(localOpMetadata !== undefined && localOpMetadata < this.pendingClearMessageId, \"Received out of order storage op when there is an unackd clear message\");\n      }\n      // If I have a NACK clear, we can ignore all ops.\n      return false;\n    }\n    if (this.pendingKeys.has(op.key)) {\n      // Found an NACK op, clear it from the directory if the latest sequence number in the directory\n      // match the message's and don't process the op.\n      if (local) {\n        assert(localOpMetadata !== undefined, `pendingMessageId is missing from the local client's ${op.type} operation`);\n        const pendingMessageId = localOpMetadata;\n        const pendingKeyMessageId = this.pendingKeys.get(op.key);\n        if (pendingKeyMessageId === pendingMessageId) {\n          this.pendingKeys.delete(op.key);\n        }\n      }\n      return false;\n    }\n    // If we don't have a NACK op on the key, we need to process the remote ops.\n    return !local;\n  }\n  /**\n   * If our local operations that have not yet been ack'd will eventually overwrite an incoming operation, we should\n   * not process the incoming operation.\n   * @param op - Operation to check\n   * @param local - Whether the message originated from the local client\n   * @param message - The message\n   * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n   * For messages from a remote client, this will be undefined.\n   * @returns True if the operation should be processed, false otherwise\n   */\n  needProcessSubDirectoryOperations(op, local, message, localOpMetadata) {\n    if (this.pendingSubDirectories.has(op.subdirName)) {\n      if (local) {\n        assert(localOpMetadata !== undefined, `pendingMessageId is missing from the local client's ${op.type} operation`);\n        const pendingMessageId = localOpMetadata;\n        const pendingSubDirectoryMessageId = this.pendingSubDirectories.get(op.subdirName);\n        if (pendingSubDirectoryMessageId === pendingMessageId) {\n          this.pendingSubDirectories.delete(op.subdirName);\n        }\n      }\n      return false;\n    }\n    return !local;\n  }\n  /**\n   * Clear all keys in memory in response to a remote clear, but retain keys we have modified but not yet been ack'd.\n   */\n  clearExceptPendingKeys() {\n    // Assuming the pendingKeys is small and the map is large\n    // we will get the value for the pendingKeys and clear the map\n    const temp = new Map();\n    this.pendingKeys.forEach((value, key, map) => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      temp.set(key, this._storage.get(key));\n    });\n    this._storage.clear();\n    temp.forEach((value, key, map) => {\n      this._storage.set(key, value);\n    });\n  }\n  /**\n   * Clear implementation used for both locally sourced clears as well as incoming remote clears.\n   * @param local - Whether the message originated from the local client\n   * @param op - The message if from a remote clear, or null if from a local clear\n   */\n  clearCore(local, op) {\n    this._storage.clear();\n    this.directory.emit(\"clear\", local, op, this.directory);\n  }\n  /**\n   * Delete implementation used for both locally sourced deletes as well as incoming remote deletes.\n   * @param key - The key being deleted\n   * @param local - Whether the message originated from the local client\n   * @param op - The message if from a remote delete, or null if from a local delete\n   * @returns True if the key existed and was deleted, false if it did not exist\n   */\n  deleteCore(key, local, op) {\n    const previousValue = this.get(key);\n    const successfullyRemoved = this._storage.delete(key);\n    if (successfullyRemoved) {\n      const event = {\n        key,\n        path: this.absolutePath,\n        previousValue\n      };\n      this.directory.emit(\"valueChanged\", event, local, op, this.directory);\n      const containedEvent = {\n        key,\n        previousValue\n      };\n      this.emit(\"containedValueChanged\", containedEvent, local, this);\n    }\n    return successfullyRemoved;\n  }\n  /**\n   * Set implementation used for both locally sourced sets as well as incoming remote sets.\n   * @param key - The key being set\n   * @param value - The value being set\n   * @param local - Whether the message originated from the local client\n   * @param op - The message if from a remote set, or null if from a local set\n   */\n  setCore(key, value, local, op) {\n    const previousValue = this.get(key);\n    this._storage.set(key, value);\n    const event = {\n      key,\n      path: this.absolutePath,\n      previousValue\n    };\n    this.directory.emit(\"valueChanged\", event, local, op, this.directory);\n    const containedEvent = {\n      key,\n      previousValue\n    };\n    this.emit(\"containedValueChanged\", containedEvent, local, this);\n  }\n  /**\n   * Create subdirectory implementation used for both locally sourced creation as well as incoming remote creation.\n   * @param subdirName - The name of the subdirectory being created\n   * @param local - Whether the message originated from the local client\n   * @param op - The message if from a remote create, or null if from a local create\n   */\n  createSubDirectoryCore(subdirName, local, op) {\n    if (!this._subdirectories.has(subdirName)) {\n      this._subdirectories.set(subdirName, new SubDirectory(this.directory, this.runtime, this.serializer, posix.join(this.absolutePath, subdirName)));\n    }\n  }\n  /**\n   * Delete subdirectory implementation used for both locally sourced creation as well as incoming remote creation.\n   * @param subdirName - The name of the subdirectory being deleted\n   * @param local - Whether the message originated from the local client\n   * @param op - The message if from a remote delete, or null if from a local delete\n   */\n  deleteSubDirectoryCore(subdirName, local, op) {\n    // This should make the subdirectory structure unreachable so it can be GC'd and won't appear in snapshots\n    // Might want to consider cleaning out the structure more exhaustively though?\n    return this._subdirectories.delete(subdirName);\n  }\n}\n//# sourceMappingURL=directory.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}