{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { performance } from \"@fluidframework/common-utils\";\nimport { debug as registerDebug } from \"debug\";\nimport { TelemetryLogger, MultiSinkLogger, ChildLogger } from \"./logger\";\n/**\n * Implementation of debug logger\n */\nexport class DebugLogger extends TelemetryLogger {\n  constructor(debug, debugErr, properties, propertyGetters) {\n    super(undefined, properties, propertyGetters);\n    this.debug = debug;\n    this.debugErr = debugErr;\n  }\n  /**\n   * Create debug logger - all events are output to debug npm library\n   * @param namespace - Telemetry event name prefix to add to all events\n   * @param properties - Base properties to add to all events\n   * @param propertyGetters - Getters to add additional properties to all events\n   */\n  static create(namespace, properties, propertyGetters) {\n    // Setup base logger upfront, such that host can disable it (if needed)\n    const debug = registerDebug(namespace);\n    const debugErr = registerDebug(namespace);\n    debugErr.log = console.error.bind(console);\n    debugErr.enabled = true;\n    return new DebugLogger(debug, debugErr, properties, propertyGetters);\n  }\n  /**\n   * Mix in debug logger with another logger.\n   * Returned logger will output events to both newly created debug logger, as well as base logger\n   * @param namespace - Telemetry event name prefix to add to all events\n   * @param properties - Base properties to add to all events\n   * @param propertyGetters - Getters to add additional properties to all events\n   * @param baseLogger - Base logger to output events (in addition to debug logger being created). Can be undefined.\n   */\n  static mixinDebugLogger(namespace, baseLogger, properties, propertyGetters) {\n    if (!baseLogger) {\n      return DebugLogger.create(namespace, properties, propertyGetters);\n    }\n    const multiSinkLogger = new MultiSinkLogger(undefined, properties, propertyGetters);\n    multiSinkLogger.addLogger(DebugLogger.create(namespace));\n    multiSinkLogger.addLogger(ChildLogger.create(baseLogger, namespace));\n    return multiSinkLogger;\n  }\n  /**\n   * Send an event to debug loggers\n   *\n   * @param event - the event to send\n   */\n  send(event) {\n    const newEvent = this.prepareEvent(event);\n    const isError = newEvent.category === \"error\";\n    let logger = isError ? this.debugErr : this.debug;\n    // Use debug's coloring schema for base of the event\n    const index = event.eventName.lastIndexOf(TelemetryLogger.eventNamespaceSeparator);\n    const name = event.eventName.substring(index + 1);\n    if (index > 0) {\n      logger = logger.extend(event.eventName.substring(0, index));\n    }\n    newEvent.eventName = undefined;\n    let tick = \"\";\n    tick = `tick=${TelemetryLogger.formatTick(performance.now())}`;\n    // Extract stack to put it last, but also to avoid escaping '\\n' in it by JSON.stringify below\n    const stack = newEvent.stack ? newEvent.stack : \"\";\n    newEvent.stack = undefined;\n    // Watch out for circular references - they can come from two sources\n    // 1) error object - we do not control it and should remove it and retry\n    // 2) properties supplied by telemetry caller - that's a bug that should be addressed!\n    let payload;\n    try {\n      payload = JSON.stringify(newEvent);\n    } catch (error) {\n      newEvent.error = undefined;\n      payload = JSON.stringify(newEvent);\n    }\n    if (payload === \"{}\") {\n      payload = \"\";\n    }\n    // Force errors out, to help with diagnostics\n    if (isError) {\n      logger.enabled = true;\n    }\n    // Print multi-line.\n    logger(`${name} ${payload} ${tick} ${stack}`);\n  }\n}\n//# sourceMappingURL=debugLogger.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}