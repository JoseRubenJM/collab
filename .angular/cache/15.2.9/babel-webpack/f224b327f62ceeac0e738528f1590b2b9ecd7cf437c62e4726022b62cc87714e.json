{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { ChildLogger, TelemetryLogger } from \"@fluidframework/telemetry-utils\";\nimport { assert, performance } from \"@fluidframework/common-utils\";\nclass OpPerfTelemetry {\n  constructor(clientId, deltaManager, logger) {\n    this.clientId = clientId;\n    this.deltaManager = deltaManager;\n    this.pongCount = 0;\n    this.socketLatency = 0;\n    this.firstConnection = true;\n    this.bootTime = performance.now();\n    this.connectionStartTime = 0;\n    this.gap = 0;\n    this.logger = ChildLogger.create(logger, \"OpPerf\");\n    this.deltaManager.on(\"pong\", latency => this.recordPingTime(latency));\n    this.deltaManager.on(\"submitOp\", message => this.beforeOpSubmit(message));\n    // Back-compat: <= 0.28: Replace to \"op\" and remove \"beforeOpProcessing\" in the future.\n    this.deltaManager.on(\"beforeOpProcessing\", message => this.beforeProcessingOp(message));\n    this.deltaManager.on(\"connect\", (details, opsBehind) => {\n      this.clientId = details.clientId;\n      if (opsBehind !== undefined) {\n        this.connectionOpSeqNumber = this.deltaManager.lastKnownSeqNumber;\n        this.gap = opsBehind;\n        this.connectionStartTime = performance.now();\n        // We might be already up-today. If so, report it right away.\n        if (this.gap <= 0) {\n          this.reportGettingUpToDate();\n        }\n      }\n    });\n    this.deltaManager.on(\"disconnect\", () => {\n      this.clientSequenceNumberForLatencyStatistics = undefined;\n      this.connectionOpSeqNumber = undefined;\n      this.firstConnection = false;\n    });\n  }\n  reportGettingUpToDate() {\n    this.connectionOpSeqNumber = undefined;\n    this.logger.sendPerformanceEvent({\n      eventName: \"ConnectionSpeed\",\n      duration: performance.now() - this.connectionStartTime,\n      ops: this.gap,\n      // track time to connect only for first connection.\n      timeToConnect: this.firstConnection ? TelemetryLogger.formatTick(this.connectionStartTime - this.bootTime) : undefined,\n      firstConnection: this.firstConnection\n    });\n  }\n  recordPingTime(latency) {\n    this.pongCount++;\n    this.socketLatency += latency;\n    const aggregateCount = 100;\n    if (this.pongCount === aggregateCount) {\n      this.logger.sendTelemetryEvent({\n        eventName: \"DeltaLatency\",\n        value: this.socketLatency / aggregateCount\n      });\n      this.pongCount = 0;\n      this.socketLatency = 0;\n    }\n  }\n  beforeOpSubmit(message) {\n    // start with first client op and measure latency every 500 client ops\n    if (this.clientSequenceNumberForLatencyStatistics === undefined && message.clientSequenceNumber % 500 === 1) {\n      this.opSendTimeForLatencyStatistics = Date.now();\n      this.clientSequenceNumberForLatencyStatistics = message.clientSequenceNumber;\n    }\n  }\n  beforeProcessingOp(message) {\n    const sequenceNumber = message.sequenceNumber;\n    if (sequenceNumber === this.connectionOpSeqNumber) {\n      this.reportGettingUpToDate();\n    }\n    // Record collab window max size after every 1000th op.\n    if (sequenceNumber % 1000 === 0) {\n      if (this.opSendTimeForLatencyStatisticsForMsnStatistics !== undefined) {\n        this.logger.sendPerformanceEvent({\n          eventName: \"MsnStatistics\",\n          sequenceNumber,\n          msnDistance: this.deltaManager.lastSequenceNumber - this.deltaManager.minimumSequenceNumber,\n          duration: message.timestamp - this.opSendTimeForLatencyStatisticsForMsnStatistics\n        });\n      }\n      this.opSendTimeForLatencyStatisticsForMsnStatistics = message.timestamp;\n    }\n    if (this.clientId === message.clientId && this.clientSequenceNumberForLatencyStatistics === message.clientSequenceNumber) {\n      assert(this.opSendTimeForLatencyStatistics !== undefined);\n      this.logger.sendPerformanceEvent({\n        eventName: \"OpRoundtripTime\",\n        sequenceNumber,\n        duration: Date.now() - this.opSendTimeForLatencyStatistics\n      });\n      this.clientSequenceNumberForLatencyStatistics = undefined;\n    }\n  }\n}\nexport function ReportOpPerfTelemetry(clientId, deltaManager, logger) {\n  new OpPerfTelemetry(clientId, deltaManager, logger);\n}\n//# sourceMappingURL=connectionTelemetry.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}