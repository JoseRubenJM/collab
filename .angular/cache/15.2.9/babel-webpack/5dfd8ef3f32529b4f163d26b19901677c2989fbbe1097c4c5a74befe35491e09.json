{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * DependencyContainer is similar to a IoC Container. It takes providers and will\n * synthesize an object based on them when requested.\n */\nexport class DependencyContainer {\n  constructor(parent = undefined) {\n    this.parent = parent;\n    this.providers = new Map();\n  }\n  get IFluidDependencySynthesizer() {\n    return this;\n  }\n  /**\n   * {@inheritDoc (IFluidDependencySynthesizer:interface).registeredTypes}\n   */\n  get registeredTypes() {\n    return this.providers.keys();\n  }\n  /**\n   * {@inheritDoc (IFluidDependencySynthesizer:interface).register}\n   */\n  register(type, provider) {\n    if (this.has(type)) {\n      throw new Error(`Attempting to register a provider of type ${type} that already exists`);\n    }\n    this.providers.set(type, provider);\n  }\n  /**\n   * {@inheritDoc (IFluidDependencySynthesizer:interface).unregister}\n   */\n  unregister(type) {\n    if (this.providers.has(type)) {\n      this.providers.delete(type);\n    }\n  }\n  /**\n   * {@inheritDoc (IFluidDependencySynthesizer:interface).synthesize}\n   */\n  synthesize(optionalTypes, requiredTypes) {\n    const optionalValues = Object.values(optionalTypes);\n    const requiredValues = Object.values(requiredTypes);\n    // There was nothing passed in so we can return\n    if (optionalValues === [] && requiredValues === []) {\n      return {};\n    }\n    const required = this.generateRequired(requiredTypes);\n    const optional = this.generateOptional(optionalTypes);\n    return Object.assign(Object.assign({}, required), optional);\n  }\n  /**\n   * {@inheritDoc (IFluidDependencySynthesizer:interface).has}\n   */\n  has(...types) {\n    return types.every(type => {\n      return this.providers.has(type);\n    });\n  }\n  /**\n   * {@inheritDoc (IFluidDependencySynthesizer:interface).getProvider}\n   */\n  getProvider(type) {\n    // If we have the provider return it\n    const provider = this.providers.get(type);\n    if (provider) {\n      return provider;\n    }\n    if (this.parent) {\n      return this.parent.getProvider(type);\n    }\n    return undefined;\n  }\n  generateRequired(types) {\n    const values = Object.values(types);\n    return Object.assign({}, ...Array.from(values, t => {\n      const provider = this.getProvider(t);\n      if (!provider) {\n        throw new Error(`Object attempted to be created without registered required provider ${t}`);\n      }\n      return this.resolveProvider(provider, t);\n    }));\n  }\n  generateOptional(types) {\n    const values = Object.values(types);\n    return Object.assign({}, ...Array.from(values, t => {\n      const provider = this.getProvider(t);\n      if (!provider) {\n        return {\n          get [t]() {\n            return Promise.resolve(undefined);\n          }\n        };\n      }\n      return this.resolveProvider(provider, t);\n    }));\n  }\n  resolveProvider(provider, t) {\n    // The double nested gets are required for lazy loading the provider resolution\n    if (typeof provider === \"function\") {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const self = this;\n      return {\n        get [t]() {\n          if (provider && typeof provider === \"function\") {\n            return Promise.resolve(provider(self)).then(p => {\n              if (p) {\n                return p[t];\n              }\n            });\n          }\n        }\n      };\n    }\n    return {\n      get [t]() {\n        if (provider) {\n          return Promise.resolve(provider).then(p => {\n            if (p) {\n              return p[t];\n            }\n          });\n        }\n      }\n    };\n  }\n}\n//# sourceMappingURL=dependencyContainer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}