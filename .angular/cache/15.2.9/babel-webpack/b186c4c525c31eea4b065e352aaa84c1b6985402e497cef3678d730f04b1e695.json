{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { TypedEventEmitter } from \"./typedEventEmitter\";\n/**\n * Base class used for forwarding events from a source EventEmitter.\n * This can be useful when all arbitrary listeners need to be removed,\n * but the primary source needs to stay intact.\n */\nexport let EventForwarder = /*#__PURE__*/(() => {\n  class EventForwarder extends TypedEventEmitter {\n    constructor(source) {\n      super();\n      this.isDisposed = false;\n      this.forwardingEvents = new Map();\n      if (source !== undefined) {\n        // NewListener event is raised whenever someone starts listening to this events, so\n        // we keep track of events being listened to, and start forwarding from the source\n        // event emitter per event listened to on this\n        const removeListenerHandler = event => this.unforwardEvent(source, event);\n        const newListenerHandler = event => this.forwardEvent(source, event);\n        this.on(EventForwarder.removeListenerEvent, removeListenerHandler);\n        this.on(EventForwarder.newListenerEvent, newListenerHandler);\n      }\n    }\n    static isEmitterEvent(event) {\n      return event === EventForwarder.newListenerEvent || event === EventForwarder.removeListenerEvent;\n    }\n    /**\n     * {@inheritDoc @fluidframework/common-definitions#IDisposable.disposed}\n     */\n    get disposed() {\n      return this.isDisposed;\n    }\n    /**\n     * {@inheritDoc @fluidframework/common-definitions#IDisposable.dispose}\n     */\n    dispose() {\n      this.isDisposed = true;\n      for (const listenerRemovers of this.forwardingEvents.values()) {\n        for (const listenerRemover of listenerRemovers.values()) {\n          try {\n            listenerRemover();\n          } catch (_a) {\n            // Should be fine because of removeAllListeners below\n          }\n        }\n      }\n      this.removeAllListeners();\n      this.forwardingEvents.clear();\n    }\n    forwardEvent(source, ...events) {\n      for (const event of events) {\n        if (source !== undefined && event !== undefined && !EventForwarder.isEmitterEvent(event)) {\n          let sources = this.forwardingEvents.get(event);\n          if (sources === undefined) {\n            sources = new Map();\n            this.forwardingEvents.set(event, sources);\n          }\n          if (!sources.has(source)) {\n            const listener = (...args) => this.emit(event, ...args);\n            sources.set(source, () => source.off(event, listener));\n            source.on(event, listener);\n          }\n        }\n      }\n    }\n    unforwardEvent(source, ...events) {\n      for (const event of events) {\n        if (event !== undefined && !EventForwarder.isEmitterEvent(event)) {\n          const sources = this.forwardingEvents.get(event);\n          if ((sources === null || sources === void 0 ? void 0 : sources.has(source)) === true && this.listenerCount(event) === 0) {\n            const listenerRemover = sources.get(source);\n            if (listenerRemover !== undefined) {\n              listenerRemover();\n            }\n            sources.delete(source);\n            if (sources.size === 0) {\n              this.forwardingEvents.delete(event);\n            }\n          }\n        }\n      }\n    }\n  }\n  EventForwarder.newListenerEvent = \"newListener\";\n  EventForwarder.removeListenerEvent = \"removeListener\";\n  //# sourceMappingURL=eventForwarder.js.map\n  return EventForwarder;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}