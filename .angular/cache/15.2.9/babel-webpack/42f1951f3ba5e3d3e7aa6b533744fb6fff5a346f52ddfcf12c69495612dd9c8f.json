{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, Deferred, TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport Deque from \"double-ended-queue\";\nexport class DeltaQueue extends TypedEventEmitter {\n  /**\n   * @param worker - A callback to process a delta.\n   * @param logger - For logging telemetry.\n   */\n  constructor(worker) {\n    super();\n    this.worker = worker;\n    this.isDisposed = false;\n    this.q = new Deque();\n    /**\n     * Tracks whether the system has requested the queue be paused.\n     */\n    this.sysPause = 1;\n    /**\n     * Tracks whether the user of the container has requested the queue be paused.\n     */\n    this.userPause = 0;\n  }\n  get disposed() {\n    return this.isDisposed;\n  }\n  /**\n   * @returns True if the queue is paused, false if not.\n   */\n  get paused() {\n    // The queue can be paused by either the user or by the system (e.g. during snapshotting).  If either requests\n    // a pause, then the queue will pause.\n    return this.sysPause !== 0 || this.userPause !== 0;\n  }\n  get length() {\n    return this.q.length;\n  }\n  get idle() {\n    return this.processingDeferred === undefined && this.q.length === 0;\n  }\n  dispose() {\n    throw new Error(\"Not implemented.\");\n    this.isDisposed = true;\n  }\n  clear() {\n    this.q.clear();\n  }\n  peek() {\n    return this.q.peekFront();\n  }\n  toArray() {\n    return this.q.toArray();\n  }\n  push(task) {\n    this.q.push(task);\n    this.emit(\"push\", task);\n    this.ensureProcessing();\n  }\n  pause() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.userPause++;\n      // If called from within the processing loop, we are in the middle of processing an op. Return a promise\n      // that will resolve when processing has actually stopped.\n      if (_this.processingDeferred !== undefined) {\n        return _this.processingDeferred.promise;\n      }\n    })();\n  }\n  resume() {\n    assert(this.userPause > 0);\n    this.userPause--;\n    if (!this.paused) {\n      this.ensureProcessing();\n    }\n  }\n  systemPause() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.sysPause++;\n      // If called from within the processing loop, we are in the middle of processing an op. Return a promise\n      // that will resolve when processing has actually stopped.\n      if (_this2.processingDeferred !== undefined) {\n        return _this2.processingDeferred.promise;\n      }\n    })();\n  }\n  systemResume() {\n    assert(this.sysPause > 0);\n    this.sysPause--;\n    if (!this.paused) {\n      this.ensureProcessing();\n    }\n  }\n  /**\n   * There are several actions that may need to kick off delta processing, so we want to guard against\n   * accidental reentrancy. ensureProcessing can be called safely to start the processing loop if it is\n   * not already started.\n   */\n  ensureProcessing() {\n    if (this.processingDeferred === undefined) {\n      this.processingDeferred = new Deferred();\n      // Use a resolved promise to start the processing on a separate stack.\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      Promise.resolve().then(() => {\n        this.processDeltas();\n        if (this.processingDeferred !== undefined) {\n          this.processingDeferred.resolve();\n          this.processingDeferred = undefined;\n        }\n      });\n    }\n  }\n  /**\n   * Executes the delta processing loop until a stop condition is reached.\n   */\n  processDeltas() {\n    // For grouping to work we must process all local messages immediately and in the single turn.\n    // So loop over them until no messages to process, we have become paused, or hit an error.\n    while (!(this.q.length === 0 || this.paused || this.error !== undefined)) {\n      // Get the next message in the queue\n      const next = this.q.shift();\n      // Process the message.\n      try {\n        // We know next is defined since we did a length check just prior to shifting.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.worker(next);\n        this.emit(\"op\", next);\n      } catch (error) {\n        this.error = error;\n        this.emit(\"error\", error);\n      }\n    }\n    if (this.q.length === 0) {\n      this.emit(\"idle\");\n    }\n  }\n}\n//# sourceMappingURL=deltaQueue.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}