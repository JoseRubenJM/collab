{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { RemoteFluidObjectHandle } from \"./remoteFluidObjectHandle\";\nimport { isSerializedHandle } from \"./utils\";\n/**\n * Data Store serializer implementation\n */\nexport class FluidSerializer {\n  constructor(context) {\n    this.context = context;\n    this.root = this.context;\n    while (this.root.routeContext !== undefined) {\n      this.root = this.root.routeContext;\n    }\n  }\n  get IFluidSerializer() {\n    return this;\n  }\n  replaceHandles(input, bind) {\n    // If the given 'input' cannot contain handles, return it immediately.  Otherwise,\n    // return the result of 'recursivelyReplaceHandles()'.\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions,@typescript-eslint/no-unsafe-return\n    return !!input && typeof input === \"object\" ? this.recursivelyReplaceHandles(input, bind) : input;\n  }\n  stringify(input, bind) {\n    return JSON.stringify(input, (key, value) => {\n      // If the current 'value' is not a handle, return it unmodified.  Otherwise,\n      // return the result of 'serializeHandle'.\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      const handle = !!value && value.IFluidHandle;\n      // TODO - understand why handle === false in some of our tests\n      // eslint-disable-next-line max-len\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions,@typescript-eslint/no-unsafe-return\n      return handle ? this.serializeHandle(handle, bind) : value;\n    });\n  }\n  // Parses the serialized data - context must match the context with which the JSON was stringified\n  parse(input) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return JSON.parse(input, (key, value) => {\n      if (!isSerializedHandle(value)) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return value;\n      }\n      // 0.21 back-compat\n      // 0.22 onwards, we always use the routeContext of the root to create the RemoteFluidObjectHandle.\n      // We won't need to check for the if condition below once we remove the back-compat code.\n      const absoluteUrl = value.url.startsWith(\"/\");\n      const handle = new RemoteFluidObjectHandle(value.url, absoluteUrl ? this.root : this.context);\n      return handle;\n    });\n  }\n  // Invoked by `replaceHandles()` for non-null objects to recursively replace IFluidHandle references\n  // with serialized handles (cloning as-needed to avoid mutating the original `input` object.)\n  recursivelyReplaceHandles(input, bind) {\n    // If the current input is an IFluidHandle instance, replace this leaf in the object graph with\n    // the handle's serialized from.\n    // Note: Caller is responsible for ensuring that `input` is a non-null object.\n    const handle = input.IFluidHandle;\n    if (handle !== undefined) {\n      return this.serializeHandle(handle, bind);\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    let clone;\n    for (const key of Object.keys(input)) {\n      const value = input[key];\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      if (!!value && typeof value === \"object\") {\n        // Note: Except for IFluidHandle, `input` must not contain circular references (as object must\n        //       be JSON serializable.)  Therefore, guarding against infinite recursion here would only\n        //       lead to a later error when attempting to stringify().\n        const replaced = this.recursivelyReplaceHandles(value, bind);\n        // If the `replaced` object is different than the original `value` then the subgraph contained one\n        // or more handles.  If this happens, we need to return a clone of the `input` object where the\n        // current property is replaced by the `replaced` value.\n        if (replaced !== value) {\n          // Lazily create a shallow clone of the `input` object if we haven't done so already.\n          clone = clone !== null && clone !== void 0 ? clone : Array.isArray(input) ? [...input] : Object.assign({}, input);\n          // Overwrite the current property `key` in the clone with the `replaced` value.\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          clone[key] = replaced;\n        }\n      }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return clone !== null && clone !== void 0 ? clone : input;\n  }\n  serializeHandle(handle, bind) {\n    bind.bind(handle);\n    return {\n      type: \"__fluid_handle__\",\n      url: handle.absolutePath\n    };\n  }\n}\n//# sourceMappingURL=serializer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}