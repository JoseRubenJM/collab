{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { CreateSummarizerNodeSource } from \"@fluidframework/runtime-definitions\";\nimport { assert, unreachableCase } from \"@fluidframework/common-utils\";\nimport { mergeStats, convertToSummaryTree, calculateStats } from \"../summaryUtils\";\nimport { decodeSummary, encodeSummary, EscapedPath, parseSummaryForSubtrees, seqFromTree, SummaryNode } from \"./summarizerNodeUtils\";\n/**\n * Encapsulates the summarizing work and state of an individual tree node in the\n * summary tree. It tracks changes and allows for optimizations when unchanged, or\n * can allow for fallback summaries to be generated when an error is encountered.\n * Usage is for the root node to call startSummary first to begin tracking a WIP\n * (work in progress) summary. Then all nodes will call summarize to summaries their\n * individual parts. Once completed and uploaded to storage, the root node will call\n * completeSummary or clearSummary to clear the WIP summary tracking state if something\n * went wrong. The SummarizerNodes will track all pending summaries that have been\n * recorded by the completeSummary call. When one of them is acked, the root node should\n * call refreshLatestSummary to inform the tree of SummarizerNodes of the new baseline\n * latest successful summary.\n */\nexport class SummarizerNode {\n  /**\n   * Do not call constructor directly.\n   * Use createRootSummarizerNode to create root node, or createChild to create child nodes.\n   */\n  constructor(defaultLogger, summarizeInternalFn, config, _changeSequenceNumber, /** Undefined means created without summary */\n  latestSummary, initialSummary, wipSummaryLogger) {\n    var _a;\n    this.defaultLogger = defaultLogger;\n    this.summarizeInternalFn = summarizeInternalFn;\n    this._changeSequenceNumber = _changeSequenceNumber;\n    this.latestSummary = latestSummary;\n    this.initialSummary = initialSummary;\n    this.wipSummaryLogger = wipSummaryLogger;\n    this.children = new Map();\n    this.pendingSummaries = new Map();\n    this.outstandingOps = [];\n    this.wipSkipRecursion = false;\n    this.canReuseHandle = (_a = config.canReuseHandle, _a !== null && _a !== void 0 ? _a : true);\n    // BUGBUG: Seeing issues with differential summaries.\n    // this will disable them, and throw instead\n    // while we continue to investigate\n    this.throwOnError = true; // config.throwOnFailure ?? false;\n    this.trackingSequenceNumber = this._changeSequenceNumber;\n  }\n  /**\n   * The reference sequence number of the most recent acked summary.\n   * Returns 0 if there is not yet an acked summary.\n   */\n  get referenceSequenceNumber() {\n    var _a, _b;\n    return _b = (_a = this.latestSummary) === null || _a === void 0 ? void 0 : _a.referenceSequenceNumber, _b !== null && _b !== void 0 ? _b : 0;\n  }\n  startSummary(referenceSequenceNumber, summaryLogger) {\n    assert(this.wipSummaryLogger === undefined, \"wipSummaryLogger should not be set yet in startSummary\");\n    assert(this.wipReferenceSequenceNumber === undefined, \"Already tracking a summary\");\n    this.wipSummaryLogger = summaryLogger;\n    for (const child of this.children.values()) {\n      child.startSummary(referenceSequenceNumber, this.wipSummaryLogger);\n    }\n    this.wipReferenceSequenceNumber = referenceSequenceNumber;\n  }\n  summarize(fullTree) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      assert(_this.wipSummaryLogger !== undefined, \"wipSummaryLogger should have been set in startSummary or ctor\");\n      // Try to reuse the tree if unchanged\n      if (_this.canReuseHandle && !fullTree && !_this.hasChanged()) {\n        const latestSummary = _this.latestSummary;\n        if (latestSummary !== undefined) {\n          _this.wipLocalPaths = {\n            localPath: latestSummary.localPath,\n            additionalPath: latestSummary.additionalPath\n          };\n          _this.wipSkipRecursion = true;\n          const stats = mergeStats();\n          stats.handleNodeCount++;\n          return {\n            summary: {\n              type: 3 /* Handle */,\n              handle: latestSummary.fullPath.path,\n              handleType: 1 /* Tree */\n            },\n\n            stats\n          };\n        }\n      }\n      try {\n        const result = yield _this.summarizeInternalFn(fullTree);\n        _this.wipLocalPaths = {\n          localPath: EscapedPath.create(result.id)\n        };\n        return {\n          summary: result.summary,\n          stats: result.stats\n        };\n      } catch (error) {\n        if (_this.throwOnError || _this.trackingSequenceNumber < _this._changeSequenceNumber) {\n          throw error;\n        }\n        const latestSummary = _this.latestSummary;\n        const initialSummary = _this.initialSummary;\n        let encodeParam;\n        let localPath;\n        if (latestSummary !== undefined) {\n          // Create using handle of latest acked summary\n          encodeParam = {\n            fromSummary: true,\n            summaryNode: latestSummary\n          };\n          localPath = latestSummary.localPath;\n        } else if (((_a = initialSummary) === null || _a === void 0 ? void 0 : _a.summary) !== undefined) {\n          // Create using initial summary from attach op\n          encodeParam = {\n            fromSummary: false,\n            initialSummary: initialSummary.summary\n          };\n          localPath = EscapedPath.create(initialSummary.id);\n        } else {\n          // No base summary to reference\n          throw error;\n        }\n        _this.wipSummaryLogger.logException({\n          eventName: \"SummarizingWithBasePlusOps\",\n          category: \"error\"\n        }, error);\n        const summary = encodeSummary(encodeParam, _this.outstandingOps);\n        _this.wipLocalPaths = {\n          localPath,\n          additionalPath: summary.additionalPath\n        };\n        _this.wipSkipRecursion = true;\n        return {\n          summary: summary.summary,\n          stats: summary.stats\n        };\n      }\n    })();\n  }\n  /**\n   * Complete the WIP summary for the given proposalHandle\n   */\n  completeSummary(proposalHandle) {\n    this.completeSummaryCore(proposalHandle, undefined, false);\n  }\n  /**\n   * Recursive implementation for completeSummary, with additional internal-only parameters\n   */\n  completeSummaryCore(proposalHandle, parentPath, parentSkipRecursion) {\n    assert(this.wipSummaryLogger !== undefined, \"wipSummaryLogger should have been set in startSummary or ctor\");\n    assert(this.wipReferenceSequenceNumber !== undefined, \"Not tracking a summary\");\n    let localPathsToUse = this.wipLocalPaths;\n    if (parentSkipRecursion) {\n      const latestSummary = this.latestSummary;\n      if (latestSummary !== undefined) {\n        // This case the parent node created a failure summary or was reused.\n        // This node and all children should only try to reference their path\n        // by its last known good state in the actual summary tree.\n        // If parent fails or is reused, the child summarize is not called so\n        // it did not get a chance to change its paths.\n        // In this case, essentially only propagate the new summary ref seq num.\n        localPathsToUse = {\n          localPath: latestSummary.localPath,\n          additionalPath: latestSummary.additionalPath\n        };\n      } else {\n        // This case the child is added after the latest non-failure summary.\n        // This node and all children should consider themselves as still not\n        // having a successful summary yet.\n        // We cannot \"reuse\" this node if unchanged since that summary, because\n        // handles will be unable to point to that node. It never made it to the\n        // tree itself, and only exists as an attach op in the _outstandingOps.\n        this.clearSummary();\n        return;\n      }\n    }\n    // This should come from wipLocalPaths in normal cases, or from the latestSummary\n    // if parentIsFailure or parentIsReused is true.\n    // If there is no latestSummary, clearSummary and return before reaching this code.\n    assert(!!localPathsToUse, \"Tracked summary local paths not set\");\n    const summary = new SummaryNode(Object.assign(Object.assign({}, localPathsToUse), {\n      referenceSequenceNumber: this.wipReferenceSequenceNumber,\n      basePath: parentPath\n    }));\n    const fullPathForChildren = summary.fullPathForChildren;\n    for (const child of this.children.values()) {\n      child.completeSummaryCore(proposalHandle, fullPathForChildren, this.wipSkipRecursion || parentSkipRecursion);\n    }\n    // Note that this overwrites existing pending summary with\n    // the same proposalHandle. If proposalHandle is something like\n    // a hash or unique identifier, this should be fine. If storage\n    // can return the same proposalHandle for a different summary,\n    // this should still be okay, because we should be proposing the\n    // newer one later which would have to overwrite the previous one.\n    this.pendingSummaries.set(proposalHandle, summary);\n    this.clearSummary();\n  }\n  clearSummary() {\n    this.wipReferenceSequenceNumber = undefined;\n    this.wipLocalPaths = undefined;\n    this.wipSkipRecursion = false;\n    this.wipSummaryLogger = undefined;\n    for (const child of this.children.values()) {\n      child.clearSummary();\n    }\n  }\n  refreshLatestSummary(proposalHandle, getSnapshot, readAndParseBlob, correlatedSummaryLogger) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (proposalHandle !== undefined) {\n        const maybeSummaryNode = _this2.pendingSummaries.get(proposalHandle);\n        if (maybeSummaryNode !== undefined) {\n          _this2.refreshLatestSummaryFromPending(proposalHandle, maybeSummaryNode.referenceSequenceNumber);\n          return;\n        }\n      }\n      const snapshotTree = yield getSnapshot();\n      const referenceSequenceNumber = yield seqFromTree(snapshotTree, readAndParseBlob);\n      return _this2.refreshLatestSummaryFromSnapshot(referenceSequenceNumber, snapshotTree, undefined, EscapedPath.create(\"\"), correlatedSummaryLogger, readAndParseBlob);\n    })();\n  }\n  refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber) {\n    const summaryNode = this.pendingSummaries.get(proposalHandle);\n    if (summaryNode === undefined) {\n      // This should only happen if parent skipped recursion AND no prior summary existed.\n      assert(this.latestSummary === undefined, \"Not found pending summary, but this node has previously completed a summary\");\n      return;\n    } else {\n      assert(referenceSequenceNumber === summaryNode.referenceSequenceNumber,\n      // eslint-disable-next-line max-len\n      `Pending summary reference sequence number should be consistent: ${summaryNode.referenceSequenceNumber} != ${referenceSequenceNumber}`);\n      // Clear earlier pending summaries\n      this.pendingSummaries.delete(proposalHandle);\n    }\n    this.refreshLatestSummaryCore(referenceSequenceNumber);\n    this.latestSummary = summaryNode;\n    // Propagate update to all child nodes\n    for (const child of this.children.values()) {\n      child.refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber);\n    }\n  }\n  refreshLatestSummaryFromSnapshot(referenceSequenceNumber, snapshotTree, basePath, localPath, correlatedSummaryLogger, readAndParseBlob) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      // Possible re-entrancy. If we have already seen a summary later than this one, ignore it.\n      if (_this3.referenceSequenceNumber >= referenceSequenceNumber) {\n        return;\n      }\n      _this3.refreshLatestSummaryCore(referenceSequenceNumber);\n      const {\n        baseSummary,\n        pathParts\n      } = decodeSummary(snapshotTree, correlatedSummaryLogger);\n      _this3.latestSummary = new SummaryNode({\n        referenceSequenceNumber,\n        basePath,\n        localPath\n      });\n      const {\n        childrenTree,\n        childrenPathPart\n      } = parseSummaryForSubtrees(baseSummary);\n      if (childrenPathPart !== undefined) {\n        pathParts.push(childrenPathPart);\n      }\n      if (pathParts.length > 0) {\n        _this3.latestSummary.additionalPath = EscapedPath.createAndConcat(pathParts);\n      }\n      // Propagate update to all child nodes\n      const pathForChildren = _this3.latestSummary.fullPathForChildren;\n      yield Promise.all(Array.from(_this3.children).filter(([id]) => {\n        // Assuming subtrees missing from snapshot are newer than the snapshot,\n        // but might be nice to assert this using earliest seq for node.\n        return childrenTree.trees[id] !== undefined;\n      }).map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* ([id, child]) {\n          return child.refreshLatestSummaryFromSnapshot(referenceSequenceNumber, childrenTree.trees[id], pathForChildren, EscapedPath.create(id), correlatedSummaryLogger, readAndParseBlob);\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  refreshLatestSummaryCore(referenceSequenceNumber) {\n    for (const [key, value] of this.pendingSummaries) {\n      if (value.referenceSequenceNumber < referenceSequenceNumber) {\n        this.pendingSummaries.delete(key);\n      }\n    }\n    // Clear earlier outstanding ops\n    while (this.outstandingOps.length > 0 && this.outstandingOps[0].sequenceNumber <= referenceSequenceNumber) {\n      this.outstandingOps.shift();\n    }\n  }\n  loadBaseSummary(snapshot, readAndParseBlob) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const decodedSummary = decodeSummary(snapshot, _this4.defaultLogger);\n      const outstandingOps = yield decodedSummary.getOutstandingOps(readAndParseBlob);\n      const {\n        childrenPathPart\n      } = parseSummaryForSubtrees(decodedSummary.baseSummary);\n      if (childrenPathPart !== undefined) {\n        decodedSummary.pathParts.push(childrenPathPart);\n      }\n      if (decodedSummary.pathParts.length > 0) {\n        assert(!!_this4.latestSummary, \"Should have latest summary defined during loadBaseSummary\");\n        _this4.latestSummary.additionalPath = EscapedPath.createAndConcat(decodedSummary.pathParts);\n      }\n      // Defensive assertion: tracking number should already exceed this number.\n      // This is probably a little excessive; can remove when stable.\n      if (outstandingOps.length > 0) {\n        const newOpsLatestSeq = outstandingOps[outstandingOps.length - 1].sequenceNumber;\n        assert(newOpsLatestSeq <= _this4.trackingSequenceNumber, \"When loading base summary, expected outstanding ops <= tracking sequence number\");\n      }\n      return {\n        baseSummary: decodedSummary.baseSummary,\n        outstandingOps\n      };\n    })();\n  }\n  recordChange(op) {\n    const lastOp = this.outstandingOps[this.outstandingOps.length - 1];\n    if (lastOp !== undefined) {\n      assert(lastOp.sequenceNumber < op.sequenceNumber, `Out of order change recorded: ${lastOp.sequenceNumber} > ${op.sequenceNumber}`);\n    }\n    this.invalidate(op.sequenceNumber);\n    this.trackingSequenceNumber = op.sequenceNumber;\n    this.outstandingOps.push(op);\n  }\n  invalidate(sequenceNumber) {\n    if (sequenceNumber > this._changeSequenceNumber) {\n      this._changeSequenceNumber = sequenceNumber;\n    }\n  }\n  /**\n   * True if a change has been recorded with sequence number exceeding\n   * the latest successfully acked summary reference sequence number.\n   * False implies that the previous summary can be reused.\n   */\n  hasChanged() {\n    return this._changeSequenceNumber > this.referenceSequenceNumber;\n  }\n  createChild( /** Summarize function */\n  summarizeInternalFn, /** Initial id or path part of this node */\n  id,\n  /**\n   * Information needed to create the node.\n   * If it is from a base summary, it will assert that a summary has been seen.\n   * Attach information if it is created from an attach op.\n   */\n  createParam, config = {}) {\n    assert(!this.children.has(id), \"Create SummarizerNode child already exists\");\n    const createDetails = this.getCreateDetailsForChild(id, createParam);\n    const child = new SummarizerNode(this.defaultLogger, summarizeInternalFn, config, createDetails.changeSequenceNumber, createDetails.latestSummary, createDetails.initialSummary, this.wipSummaryLogger);\n    // If a summary is in progress, update the child's work-in-progress state.\n    if (this.isSummaryInProgress()) {\n      this.updateChildWipState(child);\n    }\n    this.children.set(id, child);\n    return child;\n  }\n  getChild(id) {\n    return this.children.get(id);\n  }\n  /**\n   * Returns the details needed to create a child node.\n   * @param id - Initial id or path part of the child node.\n   * @param createParam - Information needed to create the node.\n   * @returns the details needed to create the child node.\n   */\n  getCreateDetailsForChild(id, createParam) {\n    var _a, _b, _c, _d;\n    let initialSummary;\n    let latestSummary;\n    let changeSequenceNumber;\n    const parentLatestSummary = this.latestSummary;\n    switch (createParam.type) {\n      case CreateSummarizerNodeSource.FromAttach:\n        {\n          if (parentLatestSummary !== undefined && createParam.sequenceNumber <= parentLatestSummary.referenceSequenceNumber) {\n            // Prioritize latest summary if it was after this node was attached.\n            latestSummary = parentLatestSummary.createForChild(id);\n          } else {\n            const summary = convertToSummaryTree(createParam.snapshot);\n            initialSummary = {\n              sequenceNumber: createParam.sequenceNumber,\n              id,\n              summary\n            };\n          }\n          changeSequenceNumber = createParam.sequenceNumber;\n          break;\n        }\n      case CreateSummarizerNodeSource.FromSummary:\n        {\n          if (this.initialSummary === undefined) {\n            assert(!!parentLatestSummary, \"Cannot create child from summary if parent does not have latest summary\");\n          }\n          // fallthrough to local\n        }\n\n      case CreateSummarizerNodeSource.Local:\n        {\n          const parentInitialSummary = this.initialSummary;\n          if (parentInitialSummary !== undefined) {\n            const childSummary = (_a = parentInitialSummary.summary) === null || _a === void 0 ? void 0 : _a.summary.tree[id];\n            if (createParam.type === CreateSummarizerNodeSource.FromSummary) {\n              // Locally created would not have subtree.\n              assert(!!childSummary, \"Missing child summary tree\");\n            }\n            let childSummaryWithStats;\n            if (childSummary !== undefined) {\n              assert(childSummary.type === 1 /* Tree */, \"Child summary object is not a tree\");\n              childSummaryWithStats = {\n                summary: childSummary,\n                stats: calculateStats(childSummary)\n              };\n            }\n            initialSummary = {\n              sequenceNumber: parentInitialSummary.sequenceNumber,\n              id,\n              summary: childSummaryWithStats\n            };\n          }\n          latestSummary = (_b = parentLatestSummary) === null || _b === void 0 ? void 0 : _b.createForChild(id);\n          changeSequenceNumber = (_d = (_c = parentLatestSummary) === null || _c === void 0 ? void 0 : _c.referenceSequenceNumber, _d !== null && _d !== void 0 ? _d : -1);\n          break;\n        }\n      default:\n        {\n          const type = createParam.type;\n          unreachableCase(createParam, `Unexpected CreateSummarizerNodeSource: ${type}`);\n        }\n    }\n    return {\n      initialSummary,\n      latestSummary,\n      changeSequenceNumber\n    };\n  }\n  /**\n   * Updates the work-in-progress state of the child if summary is in progress.\n   * @param child - The child node to be updated.\n   */\n  updateChildWipState(child) {\n    child.wipReferenceSequenceNumber = this.wipReferenceSequenceNumber;\n  }\n  isSummaryInProgress() {\n    return this.wipReferenceSequenceNumber !== undefined;\n  }\n}\n/**\n * Creates a root summarizer node.\n * @param logger - Logger to use within SummarizerNode\n * @param summarizeInternalFn - Function to generate summary\n * @param changeSequenceNumber - Sequence number of latest change to new node/subtree\n * @param referenceSequenceNumber - Reference sequence number of last acked summary,\n * or undefined if not loaded from summary\n * @param config - Configure behavior of summarizer node\n */\nexport const createRootSummarizerNode = (logger, summarizeInternalFn, changeSequenceNumber, referenceSequenceNumber, config = {}) => new SummarizerNode(logger, summarizeInternalFn, config, changeSequenceNumber, referenceSequenceNumber === undefined ? undefined : SummaryNode.createForRoot(referenceSequenceNumber));\n//# sourceMappingURL=summarizerNode.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}