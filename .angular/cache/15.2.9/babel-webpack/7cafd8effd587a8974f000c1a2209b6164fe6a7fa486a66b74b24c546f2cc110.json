{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { EventEmitter } from \"events\";\nimport { v4 as uuid } from \"uuid\";\nimport { LoaderHeader } from \"@fluidframework/container-definitions\";\nimport { Deferred, performance } from \"@fluidframework/common-utils\";\nimport { ChildLogger, DebugLogger, PerformanceEvent } from \"@fluidframework/telemetry-utils\";\nimport { ensureFluidResolvedUrl, MultiUrlResolver, MultiDocumentServiceFactory } from \"@fluidframework/driver-utils\";\nimport { Container } from \"./container\";\nimport { debug } from \"./debug\";\nimport { parseUrl } from \"./utils\";\nfunction canUseCache(request) {\n  if (request.headers === undefined) {\n    return true;\n  }\n  const noCache = request.headers[LoaderHeader.cache] === false || request.headers[LoaderHeader.reconnect] === false;\n  return !noCache;\n}\nexport class RelativeLoader extends EventEmitter {\n  /**\n   * BaseRequest is the original request that triggered the load. This URL is used in case credentials need\n   * to be fetched again.\n   */\n  constructor(loader, baseRequest) {\n    super();\n    this.loader = loader;\n    this.baseRequest = baseRequest;\n    // Because the loader is passed to the container during construction we need to resolve the target container\n    // after construction.\n    this.containerDeferred = new Deferred();\n  }\n  get IFluidRouter() {\n    return this;\n  }\n  resolve(request) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (request.url.startsWith(\"/\")) {\n        // If no headers are set that require a reload make use of the same object\n        const container = yield _this.containerDeferred.promise;\n        return container;\n      }\n      return _this.loader.resolve(request);\n    })();\n  }\n  request(request) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const baseRequest = _this2.baseRequest();\n      if (request.url.startsWith(\"/\")) {\n        if (_this2.needExecutionContext(request)) {\n          if (baseRequest === undefined) {\n            throw new Error(\"Base Request is not provided\");\n          }\n          return _this2.loader.requestWorker(baseRequest.url, request);\n        } else {\n          let container;\n          if (canUseCache(request)) {\n            container = yield _this2.containerDeferred.promise;\n          } else if (baseRequest === undefined) {\n            throw new Error(\"Base Request is not provided\");\n          } else {\n            container = yield _this2.loader.resolve({\n              url: baseRequest.url,\n              headers: request.headers\n            });\n          }\n          return container.request(request);\n        }\n      }\n      return _this2.loader.request(request);\n    })();\n  }\n  createDetachedContainer(source) {\n    return _asyncToGenerator(function* () {\n      throw new Error(\"Relative loader should not create a detached container\");\n    })();\n  }\n  rehydrateDetachedContainerFromSnapshot(source) {\n    return _asyncToGenerator(function* () {\n      throw new Error(\"Relative loader should not create a detached container from snapshot\");\n    })();\n  }\n  resolveContainer(container) {\n    this.containerDeferred.resolve(container);\n  }\n  needExecutionContext(request) {\n    return request.headers !== undefined && request.headers[LoaderHeader.executionContext] !== undefined;\n  }\n}\nfunction createCachedResolver(resolver) {\n  const cacheResolver = Object.create(resolver);\n  const resolveCache = new Map();\n  cacheResolver.resolve = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (request) {\n      if (!canUseCache(request)) {\n        return resolver.resolve(request);\n      }\n      if (!resolveCache.has(request.url)) {\n        resolveCache.set(request.url, resolver.resolve(request));\n      }\n      return resolveCache.get(request.url);\n    });\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  return cacheResolver;\n}\n/**\n * Manages Fluid resource loading\n */\nexport class Loader extends EventEmitter {\n  constructor(loaderProps) {\n    var _a, _b, _c;\n    super();\n    this.containers = new Map();\n    this.services = {\n      urlResolver: createCachedResolver(MultiUrlResolver.create(loaderProps.urlResolver)),\n      documentServiceFactory: MultiDocumentServiceFactory.create(loaderProps.documentServiceFactory),\n      codeLoader: loaderProps.codeLoader,\n      options: (_a = loaderProps.options, _a !== null && _a !== void 0 ? _a : {}),\n      scope: (_b = loaderProps.scope, _b !== null && _b !== void 0 ? _b : {}),\n      subLogger: DebugLogger.mixinDebugLogger(\"fluid:telemetry\", loaderProps.logger, {\n        loaderId: uuid()\n      }),\n      proxyLoaderFactories: (_c = loaderProps.proxyLoaderFactories, _c !== null && _c !== void 0 ? _c : new Map())\n    };\n    this.logger = ChildLogger.create(this.services.subLogger, \"Loader\");\n  }\n  /**\n   * @deprecated use constructor with loader props\n   */\n  static _create(resolver, documentServiceFactory, codeLoader, options, scope, proxyLoaderFactories, logger) {\n    return new Loader({\n      urlResolver: MultiUrlResolver.create(resolver),\n      documentServiceFactory: MultiDocumentServiceFactory.create(documentServiceFactory),\n      codeLoader,\n      options,\n      scope,\n      proxyLoaderFactories,\n      logger\n    });\n  }\n  get IFluidRouter() {\n    return this;\n  }\n  createDetachedContainer(codeDetails) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      debug(`Container creating in detached state: ${performance.now()} `);\n      return Container.createDetached(_this3, codeDetails);\n    })();\n  }\n  rehydrateDetachedContainerFromSnapshot(snapshot) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      debug(`Container creating in detached state: ${performance.now()} `);\n      return Container.rehydrateDetachedFromSnapshot(_this4, JSON.parse(snapshot));\n    })();\n  }\n  resolve(request) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      return PerformanceEvent.timedExecAsync(_this5.logger, {\n        eventName: \"Resolve\"\n      }, /*#__PURE__*/_asyncToGenerator(function* () {\n        const resolved = yield _this5.resolveCore(request);\n        return resolved.container;\n      }));\n    })();\n  }\n  request(request) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      return PerformanceEvent.timedExecAsync(_this6.logger, {\n        eventName: \"Request\"\n      }, /*#__PURE__*/_asyncToGenerator(function* () {\n        const resolved = yield _this6.resolveCore(request);\n        return resolved.container.request({\n          url: resolved.parsed.path\n        });\n      }));\n    })();\n  }\n  cacheContainer(container, request, parsedUrl) {\n    const {\n      canCache\n    } = this.parseHeader(parsedUrl, request);\n    if (canCache) {\n      const key = this.getKeyForContainerCache(request, parsedUrl);\n      this.containers.set(key, Promise.resolve(container));\n    }\n  }\n  requestWorker(baseUrl, request) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      // Currently the loader only supports web worker environment. Eventually we will\n      // detect environment and bring appropriate loader (e.g., worker_thread for node).\n      const supportedEnvironment = \"webworker\";\n      const proxyLoaderFactory = _this7.services.proxyLoaderFactories.get(supportedEnvironment);\n      // If the loader does not support any other environment, request falls back to current loader.\n      if (proxyLoaderFactory === undefined) {\n        const container = yield _this7.resolve({\n          url: baseUrl,\n          headers: request.headers\n        });\n        return container.request(request);\n      } else {\n        const resolved = yield _this7.services.urlResolver.resolve({\n          url: baseUrl,\n          headers: request.headers\n        });\n        const resolvedAsFluid = resolved;\n        const parsed = parseUrl(resolvedAsFluid.url);\n        if (parsed === undefined) {\n          return Promise.reject(new Error(`Invalid URL ${resolvedAsFluid.url}`));\n        }\n        const {\n          fromSequenceNumber\n        } = _this7.parseHeader(parsed, {\n          url: baseUrl,\n          headers: request.headers\n        });\n        const proxyLoader = yield proxyLoaderFactory.createProxyLoader(parsed.id, _this7.services.options, resolvedAsFluid, fromSequenceNumber);\n        return proxyLoader.request(request);\n      }\n    })();\n  }\n  getKeyForContainerCache(request, parsedUrl) {\n    var _a;\n    const key = ((_a = request.headers) === null || _a === void 0 ? void 0 : _a[LoaderHeader.version]) !== undefined ? `${parsedUrl.id}@${request.headers[LoaderHeader.version]}` : parsedUrl.id;\n    return key;\n  }\n  resolveCore(request) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      const resolvedAsFluid = yield _this8.services.urlResolver.resolve(request);\n      ensureFluidResolvedUrl(resolvedAsFluid);\n      // Parse URL into data stores\n      const parsed = parseUrl(resolvedAsFluid.url);\n      if (parsed === undefined) {\n        return Promise.reject(new Error(`Invalid URL ${resolvedAsFluid.url}`));\n      }\n      request.headers = (_a = request.headers, _a !== null && _a !== void 0 ? _a : {});\n      const {\n        canCache,\n        fromSequenceNumber\n      } = _this8.parseHeader(parsed, request);\n      debug(`${canCache} ${request.headers[LoaderHeader.pause]} ${request.headers[LoaderHeader.version]}`);\n      let container;\n      if (canCache) {\n        const key = _this8.getKeyForContainerCache(request, parsed);\n        const maybeContainer = yield _this8.containers.get(key);\n        if (maybeContainer !== undefined) {\n          container = maybeContainer;\n        } else {\n          const containerP = _this8.loadContainer(parsed.id, request, resolvedAsFluid);\n          _this8.containers.set(key, containerP);\n          container = yield containerP;\n        }\n      } else {\n        container = yield _this8.loadContainer(parsed.id, request, resolvedAsFluid);\n      }\n      if (container.deltaManager.lastSequenceNumber <= fromSequenceNumber) {\n        yield new Promise((resolve, reject) => {\n          function opHandler(message) {\n            if (message.sequenceNumber > fromSequenceNumber) {\n              resolve();\n              container.removeListener(\"op\", opHandler);\n            }\n          }\n          container.on(\"op\", opHandler);\n        });\n      }\n      return {\n        container,\n        parsed\n      };\n    })();\n  }\n  canUseCache(request) {\n    if (request.headers === undefined) {\n      return true;\n    }\n    const noCache = request.headers[LoaderHeader.cache] === false || request.headers[LoaderHeader.reconnect] === false || request.headers[LoaderHeader.pause] === true;\n    return !noCache;\n  }\n  parseHeader(parsed, request) {\n    var _a, _b;\n    let fromSequenceNumber = -1;\n    request.headers = (_a = request.headers, _a !== null && _a !== void 0 ? _a : {});\n    const headerSeqNum = request.headers[LoaderHeader.sequenceNumber];\n    if (headerSeqNum !== undefined) {\n      fromSequenceNumber = headerSeqNum;\n    }\n    // If set in both query string and headers, use query string\n    request.headers[LoaderHeader.version] = (_b = parsed.version, _b !== null && _b !== void 0 ? _b : request.headers[LoaderHeader.version]);\n    // Version === null means not use any snapshot.\n    if (request.headers[LoaderHeader.version] === \"null\") {\n      request.headers[LoaderHeader.version] = null;\n    }\n    return {\n      canCache: this.canUseCache(request),\n      fromSequenceNumber\n    };\n  }\n  loadContainer(id, request, resolved) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      return Container.load(id, _this9, request, resolved);\n    })();\n  }\n}\n//# sourceMappingURL=loader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}