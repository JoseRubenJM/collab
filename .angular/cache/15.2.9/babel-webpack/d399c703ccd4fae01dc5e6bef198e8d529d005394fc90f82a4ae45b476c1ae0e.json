{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, BatchManager, TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport { createGenericNetworkError } from \"@fluidframework/driver-utils\";\nimport { debug } from \"./debug\";\nconst protocolVersions = [\"^0.4.0\", \"^0.3.0\", \"^0.2.0\", \"^0.1.0\"];\n/**\n * Error raising for socket.io issues\n */\nfunction createErrorObject(handler, error, canRetry = true) {\n  // Note: we suspect the incoming error object is either:\n  // - a string: log it in the message (if not a string, it may contain PII but will print as [object Object])\n  // - a socketError: add it to the OdspError object for driver to be able to parse it and reason\n  //   over it.\n  let message = `socket.io: ${handler}`;\n  if (error !== undefined) {\n    message = `${message}: ${error}`;\n  }\n  const errorObj = createGenericNetworkError(message, canRetry);\n  errorObj.socketError = error;\n  return errorObj;\n}\n/**\n * Represents a connection to a stream of delta updates\n */\nexport let DocumentDeltaConnection = /*#__PURE__*/(() => {\n  class DocumentDeltaConnection extends TypedEventEmitter {\n    /**\n     * @param socket - websocket to be used\n     * @param documentId - ID of the document\n     */\n    constructor(socket, documentId, logger) {\n      super();\n      this.socket = socket;\n      this.documentId = documentId;\n      this.logger = logger;\n      // Listen for ops sent before we receive a response to connect_document\n      this.queuedMessages = [];\n      this.queuedSignals = [];\n      /**\n       * A flag to indicate whether we have our handler attached.  If it's attached, we're queueing incoming ops\n       * to later be retrieved via initialMessages.\n       */\n      this.earlyOpHandlerAttached = false;\n      // Listeners only needed while the connection is in progress\n      this.connectionListeners = [];\n      // Listeners used throughout the lifetime of the DocumentDeltaConnection\n      this.trackedListeners = [];\n      /**\n       * Flag to indicate whether the DocumentDeltaConnection is expected to still be capable of sending messages.\n       * After disconnection, we flip this to prevent any stale messages from being emitted.\n       */\n      this.closed = false;\n      this.earlyOpHandler = (documentId, msgs) => {\n        debug(\"Queued early ops\", msgs.length);\n        this.queuedMessages.push(...msgs);\n      };\n      this.earlySignalHandler = msg => {\n        debug(\"Queued early signals\");\n        this.queuedSignals.push(msg);\n      };\n      this.submitManager = new BatchManager((submitType, work) => {\n        // Although the implementation here disconnects the socket and does not reuse it, other subclasses\n        // (e.g. OdspDocumentDeltaConnection) may reuse the socket.  In these cases, we need to avoid emitting\n        // on the still-live socket.\n        if (!this.closed) {\n          this.socket.emit(submitType, this.clientId, work);\n        }\n      });\n      this.on(\"newListener\", (event, listener) => {\n        if (!DocumentDeltaConnection.eventsToForward.includes(event)) {\n          throw new Error(`DocumentDeltaConnection: Registering for unknown event: ${event}`);\n        }\n        // Register for the event on socket.io\n        // \"error\" is special - we already subscribed to it to modify error object on the fly.\n        if (!this.closed && event !== \"error\" && this.listeners(event).length === 0) {\n          this.addTrackedListener(event, (...args) => {\n            this.emit(event, ...args);\n          });\n        }\n      });\n    }\n    /**\n     * Create a DocumentDeltaConnection\n     *\n     * @param tenantId - the ID of the tenant\n     * @param id - document ID\n     * @param token - authorization token for storage service\n     * @param io - websocket library\n     * @param client - information about the client\n     * @param mode - connection mode\n     * @param url - websocket URL\n     * @param timeoutMs - timeout for socket connection attempt in milliseconds (default: 20000)\n     */\n    static create(tenantId, id, token, io, client, url, logger, timeoutMs = 20000) {\n      return _asyncToGenerator(function* () {\n        const socket = io(url, {\n          query: {\n            documentId: id,\n            tenantId\n          },\n          reconnection: false,\n          transports: [\"websocket\"],\n          timeout: timeoutMs\n        });\n        const connectMessage = {\n          client,\n          id,\n          mode: client.mode,\n          tenantId,\n          token,\n          versions: protocolVersions\n        };\n        const deltaConnection = new DocumentDeltaConnection(socket, id, logger);\n        yield deltaConnection.initialize(connectMessage, timeoutMs);\n        return deltaConnection;\n      })();\n    }\n    get hasDetails() {\n      return !!this._details;\n    }\n    get details() {\n      if (!this._details) {\n        throw new Error(\"Internal error: calling method before _details is initialized!\");\n      }\n      return this._details;\n    }\n    /**\n     * Get the ID of the client who is sending the message\n     *\n     * @returns the client ID\n     */\n    get clientId() {\n      return this.details.clientId;\n    }\n    /**\n     * Get the mode of the client\n     *\n     * @returns the client mode\n     */\n    get mode() {\n      return this.details.mode;\n    }\n    /**\n     * Get the claims of the client who is sending the message\n     *\n     * @returns client claims\n     */\n    get claims() {\n      return this.details.claims;\n    }\n    /**\n     * Get whether or not this is an existing document\n     *\n     * @returns true if the document exists\n     */\n    get existing() {\n      return this.details.existing;\n    }\n    /**\n     * Get the maximum size of a message before chunking is required\n     *\n     * @returns the maximum size of a message before chunking is required\n     */\n    get maxMessageSize() {\n      return this.details.maxMessageSize;\n    }\n    /**\n     * Semver of protocol being used with the service\n     */\n    get version() {\n      return this.details.version;\n    }\n    /**\n     * Configuration details provided by the service\n     */\n    get serviceConfiguration() {\n      return this.details.serviceConfiguration;\n    }\n    /**\n     * Get messages sent during the connection\n     *\n     * @returns messages sent during the connection\n     */\n    get initialMessages() {\n      // If we call this when the earlyOpHandler is not attached, then the queuedMessages may not include the\n      // latest ops.  This could possibly indicate that initialMessages was called twice.\n      assert(this.earlyOpHandlerAttached, \"Potentially missed initial messages\");\n      // We will lose ops and perf will tank as we need to go to storage to become current!\n      assert(this.listeners(\"op\").length !== 0, \"No op handler is setup!\");\n      this.removeEarlyOpHandler();\n      if (this.queuedMessages.length > 0) {\n        // Some messages were queued.\n        // add them to the list of initialMessages to be processed\n        this.details.initialMessages.push(...this.queuedMessages);\n        this.details.initialMessages.sort((a, b) => a.sequenceNumber - b.sequenceNumber);\n        this.queuedMessages.length = 0;\n      }\n      return this.details.initialMessages;\n    }\n    /**\n     * Get signals sent during the connection\n     *\n     * @returns signals sent during the connection\n     */\n    get initialSignals() {\n      assert(this.listeners(\"signal\").length !== 0, \"No signal handler is setup!\");\n      this.removeEarlySignalHandler();\n      if (this.queuedSignals.length > 0) {\n        // Some signals were queued.\n        // add them to the list of initialSignals to be processed\n        this.details.initialSignals.push(...this.queuedSignals);\n        this.queuedSignals.length = 0;\n      }\n      return this.details.initialSignals;\n    }\n    /**\n     * Get initial client list\n     *\n     * @returns initial client list sent during the connection\n     */\n    get initialClients() {\n      return this.details.initialClients;\n    }\n    /**\n     * Submits a new delta operation to the server\n     *\n     * @param message - delta operation to submit\n     */\n    submit(messages) {\n      this.submitManager.add(\"submitOp\", messages);\n    }\n    /**\n     * Submits a new signal to the server\n     *\n     * @param message - signal to submit\n     */\n    submitSignal(message) {\n      this.submitManager.add(\"submitSignal\", [message]);\n    }\n    /**\n     * Disconnect from the websocket, and permanently disable this DocumentDeltaConnection.\n     */\n    close() {\n      this.closeCore(false,\n      // socketProtocolError\n      createGenericNetworkError(\"client closing connection\", true /* canRetry */));\n    }\n\n    closeCore(socketProtocolError, err) {\n      if (this.closed) {\n        // We see cases where socket is closed while we have two \"disconnect\" listeners - one from DeltaManager,\n        // one - early handler that should have been removed on establishing connection. This causes asserts in\n        // OdspDocumentDeltaConnection.disconnect() due to not expectting two calls.\n        this.logger.sendErrorEvent({\n          eventName: \"DoubleClose\",\n          connectionEvents: this.connectionListeners.length,\n          trackedEvents: this.trackedListeners.length,\n          socketProtocolError\n        }, err);\n        return;\n      }\n      // We set the closed flag as a part of the contract for overriding the disconnect method. This is used by\n      // DocumentDeltaConnection to determine if emitting messages (ops) on the socket is allowed, which is\n      // important since OdspDocumentDeltaConnection reuses the socket rather than truly disconnecting it. Note that\n      // OdspDocumentDeltaConnection may still send disconnect_document which is allowed; this is only intended\n      // to prevent normal messages from being emitted.\n      this.closed = true;\n      this.removeTrackedListeners();\n      this.disconnect(socketProtocolError, err);\n    }\n    /**\n     * Disconnect from the websocket.\n     * @param socketProtocolError - true if error happened on socket / socket.io protocol level\n     *  (not on Fluid protocol level)\n     * @param reason - reason for disconnect\n     */\n    disconnect(socketProtocolError, reason) {\n      this.socket.disconnect();\n    }\n    initialize(connectMessage, timeout) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        _this.socket.on(\"op\", _this.earlyOpHandler);\n        _this.socket.on(\"signal\", _this.earlySignalHandler);\n        _this.earlyOpHandlerAttached = true;\n        let success = false;\n        _this._details = yield new Promise((resolve, reject) => {\n          const fail = (socketProtocolError, err) => {\n            // timeout & \"error\" can happen after successful connection\n            if (!success) {\n              _this.closeCore(socketProtocolError, err);\n            }\n            reject(err);\n          };\n          // Listen for connection issues\n          _this.addConnectionListener(\"connect_error\", error => {\n            fail(true, createErrorObject(\"connect_error\", error));\n          });\n          // Listen for timeouts\n          _this.addConnectionListener(\"connect_timeout\", () => {\n            fail(true, createErrorObject(\"connect_timeout\"));\n          });\n          // Socket can be disconnected while waiting for Fluid protocol messages\n          // (connect_document_error / connect_document_success)\n          _this.addConnectionListener(\"disconnect\", reason => {\n            fail(true, createErrorObject(\"disconnect\", reason));\n          });\n          _this.addConnectionListener(\"connect_document_success\", response => {\n            // If we sent a nonce and the server supports nonces, check that the nonces match\n            if (connectMessage.nonce !== undefined && response.nonce !== undefined && response.nonce !== connectMessage.nonce) {\n              return;\n            }\n            _this.checkpointSequenceNumber = response.checkpointSequenceNumber;\n            _this.removeConnectionListeners();\n            resolve(response);\n            success = true;\n          });\n          // WARNING: this has to stay as addTrackedListener listener and not be removed after successful connection.\n          // Reason: this.on() implementation does not subscribe to \"error\" socket events to propagate it to consumers\n          // of this class - it relies on this code to do so.\n          _this.addTrackedListener(\"error\", error => {\n            // First, raise an error event, to give clients a chance to observe error contents\n            // This includes \"Invalid namespace\" error, which we consider critical (reconnecting will not help)\n            const err = createErrorObject(\"error\", error, error !== \"Invalid namespace\");\n            _this.emit(\"error\", err);\n            // Disconnect socket - required if happened before initial handshake\n            fail(true, err);\n          });\n          _this.addConnectionListener(\"connect_document_error\", error => {\n            // If we sent a nonce and the server supports nonces, check that the nonces match\n            if (connectMessage.nonce !== undefined && error.nonce !== undefined && error.nonce !== connectMessage.nonce) {\n              return;\n            }\n            // This is not an socket.io error - it's Fluid protocol error.\n            // In this case fail connection and indicate that we were unable to create connection\n            fail(false, createErrorObject(\"connect_document_error\", error));\n          });\n          _this.socket.emit(\"connect_document\", connectMessage);\n          // Give extra 2 seconds for handshake on top of socket connection timeout\n          _this.socketConnectionTimeout = setTimeout(() => {\n            fail(false, createErrorObject(\"Timeout waiting for handshake from ordering service\"));\n          }, timeout + 2000);\n        });\n      })();\n    }\n    removeEarlyOpHandler() {\n      this.socket.removeListener(\"op\", this.earlyOpHandler);\n      this.earlyOpHandlerAttached = false;\n    }\n    removeEarlySignalHandler() {\n      this.socket.removeListener(\"signal\", this.earlySignalHandler);\n    }\n    addConnectionListener(event, listener) {\n      this.socket.on(event, listener);\n      this.connectionListeners.push({\n        event,\n        listener\n      });\n    }\n    addTrackedListener(event, listener) {\n      this.socket.on(event, listener);\n      this.trackedListeners.push({\n        event,\n        listener\n      });\n    }\n    removeTrackedListeners() {\n      for (const {\n        event,\n        listener\n      } of this.trackedListeners) {\n        this.socket.off(event, listener);\n      }\n      // removeTrackedListeners removes all listeners, including connection listeners\n      this.removeConnectionListeners();\n      this.removeEarlyOpHandler();\n      this.removeEarlySignalHandler();\n      this.trackedListeners = [];\n    }\n    removeConnectionListeners() {\n      clearTimeout(this.socketConnectionTimeout);\n      for (const {\n        event,\n        listener\n      } of this.connectionListeners) {\n        this.socket.off(event, listener);\n      }\n      this.connectionListeners = [];\n    }\n  }\n  DocumentDeltaConnection.eventsToForward = [\"nack\", \"disconnect\", \"op\", \"signal\", \"pong\", \"error\"];\n  //# sourceMappingURL=documentDeltaConnection.js.map\n  return DocumentDeltaConnection;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}