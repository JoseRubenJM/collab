{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { Deferred, assert } from \"@fluidframework/common-utils\";\nimport { MessageType } from \"@fluidframework/protocol-definitions\";\nvar SummaryState = /*#__PURE__*/(() => {\n  (function (SummaryState) {\n    SummaryState[SummaryState[\"Local\"] = 0] = \"Local\";\n    SummaryState[SummaryState[\"Broadcast\"] = 1] = \"Broadcast\";\n    SummaryState[SummaryState[\"Acked\"] = 2] = \"Acked\";\n    SummaryState[SummaryState[\"Nacked\"] = -1] = \"Nacked\";\n  })(SummaryState || (SummaryState = {}));\n  return SummaryState;\n})();\nclass Summary {\n  constructor(clientId, clientSequenceNumber) {\n    this.clientId = clientId;\n    this.clientSequenceNumber = clientSequenceNumber;\n    this.state = SummaryState.Local;\n    this.defSummaryOp = new Deferred();\n    this.defSummaryAck = new Deferred();\n  }\n  static createLocal(clientId, clientSequenceNumber) {\n    return new Summary(clientId, clientSequenceNumber);\n  }\n  static createFromOp(op) {\n    const summary = new Summary(op.clientId, op.clientSequenceNumber);\n    summary.broadcast(op);\n    return summary;\n  }\n  get summaryOp() {\n    return this._summaryOp;\n  }\n  get summaryAckNack() {\n    return this._summaryAckNack;\n  }\n  hasBeenAcked() {\n    return this.state === SummaryState.Acked;\n  }\n  broadcast(op) {\n    assert(this.state === SummaryState.Local);\n    this._summaryOp = op;\n    this.defSummaryOp.resolve();\n    this.state = SummaryState.Broadcast;\n    return true;\n  }\n  ackNack(op) {\n    assert(this.state === SummaryState.Broadcast);\n    this._summaryAckNack = op;\n    this.defSummaryAck.resolve();\n    this.state = op.type === MessageType.SummaryAck ? SummaryState.Acked : SummaryState.Nacked;\n    return true;\n  }\n  waitBroadcast() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      yield _this.defSummaryOp.promise;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return _this._summaryOp;\n    })();\n  }\n  waitAckNack() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      yield _this2.defSummaryAck.promise;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return _this2._summaryAckNack;\n    })();\n  }\n}\n/**\n * This class watches summaries created by a specific client.\n * It should be created and managed from a SummaryCollection.\n */\nclass ClientSummaryWatcher {\n  constructor(clientId, summaryCollection) {\n    this.clientId = clientId;\n    this.summaryCollection = summaryCollection;\n    // key: clientSeqNum\n    this.localSummaries = new Map();\n    this._disposed = false;\n  }\n  get disposed() {\n    return this._disposed;\n  }\n  /**\n   * Watches for a specific sent summary op.\n   * @param clientSequenceNumber - client sequence number of sent summary op\n   */\n  watchSummary(clientSequenceNumber) {\n    let summary = this.localSummaries.get(clientSequenceNumber);\n    if (!summary) {\n      summary = Summary.createLocal(this.clientId, clientSequenceNumber);\n      this.localSummaries.set(summary.clientSequenceNumber, summary);\n    }\n    return summary;\n  }\n  /**\n   * Waits until all of the pending summaries in the underlying SummaryCollection\n   * are acked/nacked.\n   */\n  // eslint-disable-next-line @typescript-eslint/promise-function-async\n  waitFlushed() {\n    return this.summaryCollection.waitFlushed();\n  }\n  /**\n   * Gets a watched summary or returns undefined if not watched.\n   * @param clientSequenceNumber - client sequence number of sent summary op\n   */\n  tryGetSummary(clientSequenceNumber) {\n    return this.localSummaries.get(clientSequenceNumber);\n  }\n  /**\n   * Starts watching a summary made by this client.\n   * @param summary - summary to start watching\n   */\n  setSummary(summary) {\n    this.localSummaries.set(summary.clientSequenceNumber, summary);\n  }\n  dispose() {\n    this.summaryCollection.removeWatcher(this.clientId);\n    this._disposed = true;\n  }\n}\n/**\n * Data structure that looks at the op stream to track summaries as they\n * are broadcast, acked and nacked.\n * It provides functionality for watching specific summaries.\n */\nexport class SummaryCollection {\n  constructor(initialSequenceNumber, logger) {\n    this.initialSequenceNumber = initialSequenceNumber;\n    this.logger = logger;\n    // key: clientId\n    this.summaryWatchers = new Map();\n    // key: summarySeqNum\n    this.pendingSummaries = new Map();\n    this.refreshWaitNextAck = new Deferred();\n  }\n  get latestAck() {\n    return this.lastAck;\n  }\n  /**\n   * Creates and returns a summary watcher for a specific client.\n   * This will allow for local sent summaries to be better tracked.\n   * @param clientId - client id for watcher\n   */\n  createWatcher(clientId) {\n    const watcher = new ClientSummaryWatcher(clientId, this);\n    this.summaryWatchers.set(clientId, watcher);\n    return watcher;\n  }\n  removeWatcher(clientId) {\n    this.summaryWatchers.delete(clientId);\n  }\n  /**\n   * Returns a promise that resolves once all pending summary ops\n   * have been acked or nacked.\n   */\n  waitFlushed() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      while (_this3.pendingSummaries.size > 0) {\n        // eslint-disable-next-line @typescript-eslint/promise-function-async\n        const promises = Array.from(_this3.pendingSummaries, ([, summary]) => summary.waitAckNack());\n        yield Promise.all(promises);\n      }\n      return _this3.lastAck;\n    })();\n  }\n  /**\n   * Returns a promise that resolves once a summary is acked that has a reference\n   * sequence number greater than or equal to the passed in sequence number.\n   * @param referenceSequenceNumber - reference sequence number to wait for\n   * @returns The latest acked summary\n   */\n  waitSummaryAck(referenceSequenceNumber) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      while (!_this4.lastAck || _this4.lastAck.summaryOp.referenceSequenceNumber < referenceSequenceNumber) {\n        yield _this4.refreshWaitNextAck.promise;\n      }\n      return _this4.lastAck;\n    })();\n  }\n  /**\n   * Handler for ops; only handles ops relating to summaries.\n   * @param op - op message to handle\n   */\n  handleOp(op) {\n    switch (op.type) {\n      case MessageType.Summarize:\n        {\n          this.handleSummaryOp(op);\n          return;\n        }\n      case MessageType.SummaryAck:\n        {\n          this.handleSummaryAck(op);\n          return;\n        }\n      case MessageType.SummaryNack:\n        {\n          this.handleSummaryNack(op);\n          return;\n        }\n      default:\n        {\n          return;\n        }\n    }\n  }\n  handleSummaryOp(op) {\n    let summary;\n    // Check if summary already being watched, broadcast if so\n    const watcher = this.summaryWatchers.get(op.clientId);\n    if (watcher) {\n      summary = watcher.tryGetSummary(op.clientSequenceNumber);\n      if (summary) {\n        summary.broadcast(op);\n      }\n    }\n    // If not watched, create from op\n    if (!summary) {\n      summary = Summary.createFromOp(op);\n      if (watcher) {\n        watcher.setSummary(summary);\n      }\n    }\n    this.pendingSummaries.set(op.sequenceNumber, summary);\n  }\n  handleSummaryAck(op) {\n    const seq = op.contents.summaryProposal.summarySequenceNumber;\n    const summary = this.pendingSummaries.get(seq);\n    if (!summary) {\n      // Summary ack without an op should be rare. We could fetch the\n      // reference sequence number from the snapshot, but instead we\n      // will not emit this ack. It should be the case that the summary\n      // op that this ack is for is earlier than this file was loaded\n      // from. i.e. initialSequenceNumber > summarySequenceNumber.\n      // We really don't care about it for now, since it is older than\n      // the one we loaded from.\n      if (seq >= this.initialSequenceNumber) {\n        // Potential causes for it to be later than our initialSequenceNumber\n        // are that the summaryOp was nacked then acked, double-acked, or\n        // the summarySequenceNumber is incorrect.\n        this.logger.sendErrorEvent({\n          eventName: \"SummaryAckWithoutOp\",\n          sequenceNumber: op.sequenceNumber,\n          summarySequenceNumber: seq,\n          initialSequenceNumber: this.initialSequenceNumber\n        });\n      }\n      return;\n    }\n    summary.ackNack(op);\n    this.pendingSummaries.delete(seq);\n    // Track latest ack\n    if (!this.lastAck || seq > this.lastAck.summaryAckNack.contents.summaryProposal.summarySequenceNumber) {\n      this.lastAck = summary;\n      this.refreshWaitNextAck.resolve();\n      this.refreshWaitNextAck = new Deferred();\n    }\n  }\n  handleSummaryNack(op) {\n    const seq = op.contents.summaryProposal.summarySequenceNumber;\n    const summary = this.pendingSummaries.get(seq);\n    if (summary) {\n      summary.ackNack(op);\n      this.pendingSummaries.delete(seq);\n    }\n  }\n}\n//# sourceMappingURL=summaryCollection.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}