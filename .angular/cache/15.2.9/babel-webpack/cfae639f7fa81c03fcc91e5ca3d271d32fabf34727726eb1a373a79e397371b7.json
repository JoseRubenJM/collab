{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\n/**\n * @deprecated - please avoid adding new references to this API!\n * It exposes internal container guts to external world, which is not ideal.\n * It also relies heavily on internal routing schema (formation of handle URIs) which will change in future\n * And last, but not least, it does not allow any policy to be implemented around GC of data stores exposed\n * through internal URIs. I.e. if there are no other references to such objects, they will be GC'd and\n * external links would get broken. Maybe that's what is needed in some cases, but better, more centralized\n * handling of external URI to internal handle is required (in future, we will support weak handle references,\n * that will allow any GC policy to be implemented by container authors.)\n */\nexport const innerRequestHandler = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (request, runtime) {\n    return runtime.IFluidHandleContext.resolveHandle(request);\n  });\n  return function innerRequestHandler(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport const createFluidObjectResponse = fluidObject => {\n  return {\n    status: 200,\n    mimeType: \"fluid/object\",\n    value: fluidObject\n  };\n};\nclass LegacyUriHandle {\n  constructor(absolutePath, runtime) {\n    this.absolutePath = absolutePath;\n    this.runtime = runtime;\n    this.isAttached = true;\n  }\n  get IFluidHandle() {\n    return this;\n  }\n  attachGraph() {\n    assert(false);\n  }\n  get() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const response = yield _this.runtime.IFluidHandleContext.resolveHandle({\n        url: _this.absolutePath\n      });\n      if (response.status === 200 && response.mimeType === \"fluid/object\") {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return response.value;\n      }\n      throw new Error(`Failed to resolve container path ${_this.absolutePath}`);\n    })();\n  }\n  bind(handle) {\n    throw new Error(\"Cannot bind to LegacyUriHandle\");\n  }\n}\n// eslint-disable-next-line prefer-arrow/prefer-arrow-functions\nexport function handleFromLegacyUri(uri, runtime) {\n  return new LegacyUriHandle(uri, runtime);\n}\n//# sourceMappingURL=requestHandlers.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}