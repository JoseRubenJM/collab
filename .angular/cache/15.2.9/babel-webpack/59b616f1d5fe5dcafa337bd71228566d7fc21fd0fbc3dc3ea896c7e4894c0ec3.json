{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { FluidObjectHandle } from \"@fluidframework/datastore\";\nimport { assert, EventForwarder } from \"@fluidframework/common-utils\";\nimport { handleFromLegacyUri } from \"@fluidframework/request-handler\";\nimport { serviceRoutePathRoot } from \"../container-services\";\nimport { defaultFluidObjectRequestHandler } from \"../request-handlers\";\n/**\n * This is a bare-bones base class that does basic setup and enables for factory on an initialize call.\n * You probably don't want to inherit from this data store directly unless\n * you are creating another base data store class\n *\n * Generics:\n * O - represents a type that will define optional providers that will be injected\n * S - the initial state type that the produced data store may take during creation\n * E - represents events that will be available in the EventForwarder\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport class PureDataObject extends EventForwarder {\n  constructor(props) {\n    super();\n    this._disposed = false;\n    this.runtime = props.runtime;\n    this.context = props.context;\n    this.providers = props.providers;\n    this.initProps = props.initProps;\n    assert(this.runtime._dataObject === undefined);\n    this.runtime._dataObject = this;\n    // Create a FluidObjectHandle with empty string as `path`. This is because reaching this PureDataObject is the\n    // same as reaching its routeContext (FluidDataStoreRuntime) so there is so the relative path to it from the\n    // routeContext is empty.\n    this.innerHandle = new FluidObjectHandle(this, \"\", this.runtime.objectsRoutingContext);\n    // Container event handlers\n    this.runtime.once(\"dispose\", () => {\n      this._disposed = true;\n      this.dispose();\n    });\n  }\n  get disposed() {\n    return this._disposed;\n  }\n  get id() {\n    return this.runtime.id;\n  }\n  get IFluidRouter() {\n    return this;\n  }\n  get IFluidLoadable() {\n    return this;\n  }\n  get IFluidHandle() {\n    return this.innerHandle;\n  }\n  /**\n   * Handle to a data store\n   */\n  get handle() {\n    return this.innerHandle;\n  }\n  static getDataObject(runtime) {\n    return _asyncToGenerator(function* () {\n      const obj = runtime._dataObject;\n      assert(obj !== undefined, \"Runtime has no DataObject!\");\n      yield obj.finishInitialization();\n      return obj;\n    })();\n  }\n  // #region IFluidRouter\n  /**\n   * Return this object if someone requests it directly\n   * We will return this object in two scenarios:\n   *  1. the request url is a \"/\"\n   *  2. the request url is empty\n   */\n  request(req) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return defaultFluidObjectRequestHandler(_this, req);\n    })();\n  }\n  // #endregion IFluidRouter\n  // #region IFluidLoadable\n  // Back-compat <= 0.28\n  get url() {\n    return this.context.id;\n  }\n  // #endregion IFluidLoadable\n  /**\n   * Call this API to ensure PureDataObject is fully initialized\n   * initialization happens on demand, only on as-needed bases.\n   * In most cases you should allow factory/object to decide when to finish initialization.\n   * But if you are supplying your own implementation of DataStoreRuntime factory and overriding some methods\n   * and need fully initialized object, then you can call this API to ensure object is fully initialized.\n   */\n  finishInitialization() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.initializeP !== undefined) {\n        return _this2.initializeP;\n      }\n      _this2.initializeP = _this2.initializeInternal();\n      return _this2.initializeP;\n    })();\n  }\n  /**\n   * Internal initialize implementation. Overwriting this will change the flow of the PureDataObject and should\n   * generally not be done.\n   *\n   * Calls initializingFirstTime, initializingFromExisting, and hasInitialized. Caller is\n   * responsible for ensuring this is only invoked once.\n   */\n  initializeInternal() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      yield _this3.preInitialize();\n      if (_this3.runtime.existing) {\n        assert(_this3.initProps === undefined);\n        yield _this3.initializingFromExisting();\n      } else {\n        yield _this3.initializingFirstTime((_a = _this3.context.createProps, _a !== null && _a !== void 0 ? _a : _this3.initProps));\n      }\n      yield _this3.hasInitialized();\n    })();\n  }\n  /**\n   * Retreive Fluid object using the handle get or the older requestFluidObject_UNSAFE call to fetch by ID\n   *\n   * @param key - key that object (handle/id) is stored with in the directory\n   * @param directory - directory containing the object\n   * @param getObjectFromDirectory - optional callback for fetching object from the directory, allows users to\n   * define custom types/getters for object retrieval\n   */\n  getFluidObjectFromDirectory(key, directory, getObjectFromDirectory) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      const handleOrId = getObjectFromDirectory ? getObjectFromDirectory(key, directory) : directory.get(key);\n      if (typeof handleOrId === \"string\") {\n        // For backwards compatibility with older stored IDs\n        // We update the storage with the handle so that this code path is less and less trafficked\n        const fluidObject = yield _this4.requestFluidObject_UNSAFE(handleOrId);\n        if (fluidObject.IFluidLoadable && fluidObject.handle) {\n          directory.set(key, fluidObject.handle);\n        }\n        return fluidObject;\n      } else {\n        const handle = (_a = handleOrId) === null || _a === void 0 ? void 0 : _a.IFluidHandle;\n        return yield handle ? handle.get() : _this4.requestFluidObject_UNSAFE(key);\n      }\n    })();\n  }\n  /**\n   * @deprecated\n   * Gets the data store of a given id. Will follow the pattern of the container for waiting.\n   * @param id - data store id\n   */\n  requestFluidObject_UNSAFE(id) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      return handleFromLegacyUri(`/${id}`, _this5.context.containerRuntime).get();\n    })();\n  }\n  /**\n   * Gets the service at a given id.\n   * @param id - service id\n   */\n  getService(id) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      return handleFromLegacyUri(`/${serviceRoutePathRoot}/${id}`, _this6.context.containerRuntime).get();\n    })();\n  }\n  /**\n   * Called every time the data store is initialized, before initializingFirstTime or\n   * initializingFromExisting is called.\n   */\n  preInitialize() {\n    return _asyncToGenerator(function* () {})();\n  }\n  /**\n   * Called the first time the data store is initialized (new creations with a new\n   * data store runtime)\n   *\n   * @param props - Optional props to be passed in on create\n   */\n  initializingFirstTime(props) {\n    return _asyncToGenerator(function* () {})();\n  }\n  /**\n   * Called every time but the first time the data store is initialized (creations\n   * with an existing data store runtime)\n   */\n  initializingFromExisting() {\n    return _asyncToGenerator(function* () {})();\n  }\n  /**\n   * Called every time the data store is initialized after create or existing.\n   */\n  hasInitialized() {\n    return _asyncToGenerator(function* () {})();\n  }\n  /**\n   * Called when the host container closes and disposes itself\n   */\n  dispose() {\n    super.dispose();\n  }\n}\n//# sourceMappingURL=pureDataObject.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}