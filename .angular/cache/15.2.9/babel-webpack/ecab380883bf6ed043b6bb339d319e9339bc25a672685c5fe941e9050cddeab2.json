{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { MessageType } from \"@fluidframework/protocol-definitions\";\nimport { assert, Trace } from \"@fluidframework/common-utils\";\nimport * as Collections from \"./collections\";\nimport { UnassignedSequenceNumber, UniversalSequenceNumber } from \"./constants\";\nimport { LocalReference } from \"./localReference\";\nimport { compareStrings, elapsedMicroseconds, MergeTree, RegisterCollection } from \"./mergeTree\";\nimport * as OpBuilder from \"./opBuilder\";\nimport { SnapshotLegacy } from \"./snapshotlegacy\";\nimport { SnapshotLoader } from \"./snapshotLoader\";\nimport { MergeTreeTextHelper } from \"./textSegment\";\nimport { SnapshotV1 } from \"./snapshotV1\";\nexport class Client {\n  constructor(\n  // Passing this callback would be unnecessary if Client were merged with SharedSegmentSequence\n  specToSegment, logger, options) {\n    this.specToSegment = specToSegment;\n    this.logger = logger;\n    this.verboseOps = false;\n    this.noVerboseRemoteAnnotate = false;\n    this.measureOps = false;\n    this.registerCollection = new RegisterCollection();\n    this.accumTime = 0;\n    this.localTime = 0;\n    this.localOps = 0;\n    this.accumWindowTime = 0;\n    this.accumWindow = 0;\n    this.accumOps = 0;\n    this.maxWindowTime = 0;\n    this.clientNameToIds = new Collections.RedBlackTree(compareStrings);\n    this.shortClientIdMap = [];\n    this.shortClientBranchIdMap = [];\n    this.pendingConsensus = new Map();\n    this.mergeTree = new MergeTree(options);\n    this.mergeTree.getLongClientId = id => this.getLongClientId(id);\n    this.mergeTree.clientIdToBranchId = this.shortClientBranchIdMap;\n  }\n  get mergeTreeDeltaCallback() {\n    return this.mergeTree.mergeTreeDeltaCallback;\n  }\n  set mergeTreeDeltaCallback(callback) {\n    this.mergeTree.mergeTreeDeltaCallback = callback;\n  }\n  get mergeTreeMaintenanceCallback() {\n    return this.mergeTree.mergeTreeMaintenanceCallback;\n  }\n  set mergeTreeMaintenanceCallback(callback) {\n    this.mergeTree.mergeTreeMaintenanceCallback = callback;\n  }\n  /**\n   * The merge tree maintains a queue of segment groups for each local operation.\n   * These segment groups track segments modified by an operation.\n   * This method peeks the tail of that queue, and returns the segments groups there.\n   * It is used to get the segment group(s) for the previous operations.\n   * @param count - The number segment groups to get peek from the tail of the queue. Default 1.\n   */\n  peekPendingSegmentGroups(count = 1) {\n    var _a, _b;\n    if (count === 1) {\n      return (_a = this.mergeTree.pendingSegments) === null || _a === void 0 ? void 0 : _a.last();\n    }\n    let taken = 0;\n    return (_b = this.mergeTree.pendingSegments) === null || _b === void 0 ? void 0 : _b.some(() => {\n      if (taken < count) {\n        taken++;\n        return true;\n      }\n      return false;\n    }, true);\n  }\n  /**\n   * Annotate a maker and call the callback on concensus.\n   * @param marker - The marker to annotate\n   * @param props - The properties to annotate the marker with\n   * @param consensusCallback - The callback called when consensus is reached\n   * @returns The annotate op if valid, otherwise undefined\n   */\n  annotateMarkerNotifyConsensus(marker, props, consensusCallback) {\n    const combiningOp = {\n      name: \"consensus\"\n    };\n    const annotateOp = this.annotateMarker(marker, props, combiningOp);\n    if (annotateOp) {\n      const consensusInfo = {\n        callback: consensusCallback,\n        marker\n      };\n      this.pendingConsensus.set(marker.getId(), consensusInfo);\n      return annotateOp;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Annotates the markers with the provided properties\n   * @param marker - The marker to annotate\n   * @param props - The properties to annotate the marker with\n   * @param combiningOp - Optional. Specifies how to combine values for the property, such as \"incr\" for increment.\n   * @returns The annotate op if valid, otherwise undefined\n   */\n  annotateMarker(marker, props, combiningOp) {\n    const annotateOp = OpBuilder.createAnnotateMarkerOp(marker, props, combiningOp);\n    if (this.applyAnnotateRangeOp({\n      op: annotateOp\n    })) {\n      return annotateOp;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Annotates the range with the provided properties\n   * @param start - The inclusive start postition of the range to annotate\n   * @param end - The exclusive end position of the range to annotate\n   * @param props - The properties to annotate the range with\n   * @param combiningOp - Specifies how to combine values for the property, such as \"incr\" for increment.\n   * @returns The annotate op if valid, otherwise undefined\n   */\n  annotateRangeLocal(start, end, props, combiningOp) {\n    const annotateOp = OpBuilder.createAnnotateRangeOp(start, end, props, combiningOp);\n    if (this.applyAnnotateRangeOp({\n      op: annotateOp\n    })) {\n      return annotateOp;\n    }\n    return undefined;\n  }\n  /**\n   * Removes the range and puts the content of the removed range in a register\n   * if a register name is provided\n   *\n   * @param start - The inclusive start of the range to remove\n   * @param end - The exclusive end of the range to remove\n   * @param register - Optional. The name of the register to store the removed range in\n   */\n  removeRangeLocal(start, end, register) {\n    const removeOp = OpBuilder.createRemoveRangeOp(start, end, register);\n    if (this.applyRemoveRangeOp({\n      op: removeOp\n    })) {\n      return removeOp;\n    }\n    return undefined;\n  }\n  /**\n   * @param pos - The position to insert the segment at\n   * @param segment - The segment to insert\n   */\n  insertSegmentLocal(pos, segment) {\n    if (segment.cachedLength <= 0) {\n      return undefined;\n    }\n    const insertOp = OpBuilder.createInsertSegmentOp(pos, segment);\n    if (this.applyInsertOp({\n      op: insertOp\n    })) {\n      return insertOp;\n    }\n    return undefined;\n  }\n  /**\n   * @param refPos - The reference position to insert the segment at\n   * @param segment - The segment to insert\n   */\n  insertAtReferencePositionLocal(refPos, segment) {\n    const pos = this.mergeTree.referencePositionToLocalPosition(refPos, this.getCurrentSeq(), this.getClientId());\n    if (pos === LocalReference.DetachedPosition) {\n      return undefined;\n    }\n    const op = OpBuilder.createInsertSegmentOp(pos, segment);\n    const opArgs = {\n      op\n    };\n    let traceStart;\n    if (this.measureOps) {\n      traceStart = Trace.start();\n    }\n    this.mergeTree.insertAtReferencePosition(refPos, segment, opArgs);\n    this.completeAndLogOp(opArgs, this.getClientSequenceArgs(opArgs), {\n      start: op.pos1,\n      end: undefined\n    }, traceStart);\n    return op;\n  }\n  /**\n   * @param pos - The position to insert the register contents at\n   * @param register - The name of the register to insert the value of\n   */\n  pasteLocal(pos, register) {\n    const insertOp = OpBuilder.createInsertFromRegisterOp(pos, register);\n    if (this.applyInsertOp({\n      op: insertOp\n    })) {\n      return insertOp;\n    }\n    return undefined;\n  }\n  /**\n   *\n   * @param start - he inclusive start of the range to copy into the register\n   * @param end - The exclusive end of the range to copy into the register\n   * @param register - The name of the register to insert the range contents into\n   */\n  copyLocal(start, end, register) {\n    const insertOp = OpBuilder.createInsertToRegisterOp(start, end, register);\n    if (this.applyInsertOp({\n      op: insertOp\n    })) {\n      return insertOp;\n    }\n    return undefined;\n  }\n  walkSegments(handler, start, end, accum, splitRange = false) {\n    this.mergeTree.mapRange({\n      leaf: handler\n    }, this.getCurrentSeq(), this.getClientId(), accum, start, end, splitRange);\n  }\n  getCollabWindow() {\n    return this.mergeTree.getCollabWindow();\n  }\n  /**\n   * Returns the current position of a segment, and -1 if the segment\n   * does not exist in this merge tree\n   * @param segment - The segment to get the position of\n   */\n  getPosition(segment) {\n    var _a;\n    if (((_a = segment) === null || _a === void 0 ? void 0 : _a.parent) === undefined) {\n      return -1;\n    }\n    return this.mergeTree.getPosition(segment, this.getCurrentSeq(), this.getClientId());\n  }\n  addLocalReference(lref) {\n    return this.mergeTree.addLocalReference(lref);\n  }\n  removeLocalReference(lref) {\n    return this.mergeTree.removeLocalReference(lref.segment, lref);\n  }\n  /**\n   * Given a position specified relative to a marker id, lookup the marker\n   * and convert the position to a character position.\n   * @param relativePos - Id of marker (may be indirect) and whether position is before or after marker.\n   */\n  posFromRelativePos(relativePos) {\n    return this.mergeTree.posFromRelativePos(relativePos);\n  }\n  getMarkerFromId(id) {\n    return this.mergeTree.getMarkerFromId(id);\n  }\n  /**\n   * Performs the annotate based on the provided op\n   * @param opArgs - The ops args for the op\n   * @returns True if the annotate was applied. False if it could not be.\n   */\n  applyRemoveRangeOp(opArgs) {\n    assert(opArgs.op.type === 1 /* REMOVE */);\n    const op = opArgs.op;\n    const clientArgs = this.getClientSequenceArgs(opArgs);\n    const range = this.getValidOpRange(op, clientArgs);\n    if (!range) {\n      return false;\n    }\n    if (op.register) {\n      // Cut\n      this.copy(range, op.register, clientArgs);\n    }\n    let traceStart;\n    if (this.measureOps) {\n      traceStart = Trace.start();\n    }\n    this.mergeTree.markRangeRemoved(range.start, range.end, clientArgs.referenceSequenceNumber, clientArgs.clientId, clientArgs.sequenceNumber, false, opArgs);\n    this.completeAndLogOp(opArgs, clientArgs, range, traceStart);\n    return true;\n  }\n  /**\n   * Performs the annotate based on the provided op\n   * @param opArgs - The ops args for the op\n   * @returns True if the annotate was applied. False if it could not be.\n   */\n  applyAnnotateRangeOp(opArgs) {\n    assert(opArgs.op.type === 2 /* ANNOTATE */);\n    const op = opArgs.op;\n    const clientArgs = this.getClientSequenceArgs(opArgs);\n    const range = this.getValidOpRange(op, clientArgs);\n    if (!range) {\n      return false;\n    }\n    let traceStart;\n    if (this.measureOps) {\n      traceStart = Trace.start();\n    }\n    this.mergeTree.annotateRange(range.start, range.end, op.props, op.combiningOp, clientArgs.referenceSequenceNumber, clientArgs.clientId, clientArgs.sequenceNumber, opArgs);\n    this.completeAndLogOp(opArgs, clientArgs, range, traceStart);\n    return true;\n  }\n  /**\n   * Performs the insert based on the provided op\n   * @param opArgs - The ops args for the op\n   * @returns True if the insert was applied. False if it could not be.\n   */\n  applyInsertOp(opArgs) {\n    assert(opArgs.op.type === 0 /* INSERT */);\n    const op = opArgs.op;\n    const clientArgs = this.getClientSequenceArgs(opArgs);\n    const range = this.getValidOpRange(op, clientArgs);\n    if (!range) {\n      return false;\n    }\n    let segments;\n    if (op.seg) {\n      segments = [this.specToSegment(op.seg)];\n    } else if (op.register) {\n      if (range.end) {\n        this.copy(range, op.register, clientArgs);\n        // Enqueue an empty segment group to be dequeued on ack\n        //\n        if (clientArgs.sequenceNumber === UnassignedSequenceNumber) {\n          this.mergeTree.pendingSegments.enqueue({\n            segments: [],\n            localSeq: this.getCollabWindow().localSeq\n          });\n        }\n        return true;\n      }\n      segments = this.registerCollection.get(this.getLongClientId(clientArgs.clientId), op.register);\n    }\n    if (!segments || segments.length === 0) {\n      return false;\n    }\n    let traceStart;\n    if (this.measureOps) {\n      traceStart = Trace.start();\n    }\n    this.mergeTree.insertSegments(range.start, segments, clientArgs.referenceSequenceNumber, clientArgs.clientId, clientArgs.sequenceNumber, opArgs);\n    this.completeAndLogOp(opArgs, clientArgs, range, traceStart);\n    return true;\n  }\n  /**\n   *\n   * @param opArgs - The op args of the op to complete\n   * @param clientArgs - The client args for the op\n   * @param range - The range the op applied to\n   * @param clockStart - Optional. The clock start if timing data should be updated.\n   */\n  completeAndLogOp(opArgs, clientArgs, range, traceStart) {\n    if (!opArgs.sequencedMessage) {\n      if (traceStart) {\n        this.localTime += elapsedMicroseconds(traceStart);\n        this.localOps++;\n      }\n    } else {\n      assert(this.mergeTree.getCollabWindow().currentSeq < clientArgs.sequenceNumber, \"Incoming remote op sequence# <= local collabWindow's currentSequence#\");\n      assert(this.mergeTree.getCollabWindow().minSeq <= opArgs.sequencedMessage.minimumSequenceNumber, \"Incoming remote op minSequence# < local collabWindow's minSequence#\");\n      if (traceStart) {\n        this.accumTime += elapsedMicroseconds(traceStart);\n        this.accumOps++;\n        this.accumWindow += this.getCurrentSeq() - this.getCollabWindow().minSeq;\n      }\n    }\n    if (this.verboseOps && (!opArgs.sequencedMessage || !this.noVerboseRemoteAnnotate)) {\n      console.log(`@cli ${this.getLongClientId(this.getCollabWindow().clientId)} ` + `seq ${clientArgs.sequenceNumber} ${opArgs.op.type} local ${!opArgs.sequencedMessage} ` + `start ${range.start} end ${range.end} refseq ${clientArgs.referenceSequenceNumber} ` + `cli ${clientArgs.clientId}`);\n    }\n  }\n  /**\n   * Returns a valid range for the op, or undefined\n   * @param op - The op to generate the range for\n   * @param clientArgs - The client args for the op\n   */\n  getValidOpRange(op, clientArgs) {\n    let start = op.pos1;\n    if (start === undefined && op.relativePos1) {\n      start = this.mergeTree.posFromRelativePos(op.relativePos1, clientArgs.referenceSequenceNumber, clientArgs.clientId);\n    }\n    let end = op.pos2;\n    if (end === undefined && op.relativePos2) {\n      end = this.mergeTree.posFromRelativePos(op.relativePos2, clientArgs.referenceSequenceNumber, clientArgs.clientId);\n    }\n    // Validate if local op\n    if (clientArgs.clientId === this.getClientId()) {\n      const length = this.getLength();\n      const invalidPositions = [];\n      // Validate start position\n      //\n      if (start === undefined || start < 0 || start > length || start === length && op.type !== 0 /* INSERT */) {\n        invalidPositions.push(\"start\");\n      }\n      // Validate end if not insert, or insert has end\n      //\n      if (op.type !== 0 /* INSERT */ || end !== undefined) {\n        if (end === undefined || end <= start) {\n          invalidPositions.push(\"end\");\n        }\n      }\n      if (invalidPositions.length > 0) {\n        this.logger.sendErrorEvent({\n          currentSeq: this.getCurrentSeq(),\n          end,\n          eventName: \"InvalidOpRange\",\n          invalidPositions: invalidPositions.toString(),\n          length,\n          opPos1: op.pos1,\n          opPos1Relative: op.relativePos1 !== undefined,\n          opPos2: op.pos2,\n          opPos2Relative: op.relativePos2 !== undefined,\n          opRefSeq: clientArgs.referenceSequenceNumber,\n          opSeq: clientArgs.sequenceNumber,\n          opType: op.type,\n          start\n        });\n        return undefined;\n      }\n    }\n    return {\n      start,\n      end\n    };\n  }\n  /**\n   * Gets the client args from the op if remote, otherwise uses the local clients info\n   * @param opArgs - The op arg to get the client sequence args for\n   */\n  getClientSequenceArgs(opArgs) {\n    // If there this no sequenced message, then the op is local\n    // and unacked, so use this clients sequenced args\n    //\n    if (!opArgs.sequencedMessage) {\n      const segWindow = this.getCollabWindow();\n      return {\n        clientId: segWindow.clientId,\n        referenceSequenceNumber: segWindow.currentSeq,\n        sequenceNumber: this.getLocalSequenceNumber()\n      };\n    } else {\n      return {\n        clientId: this.getShortClientId(opArgs.sequencedMessage.clientId),\n        referenceSequenceNumber: opArgs.sequencedMessage.referenceSequenceNumber,\n        sequenceNumber: opArgs.sequencedMessage.sequenceNumber\n      };\n    }\n  }\n  /**\n   * @param range - The range to copy into the register\n   * @param register - The name of the register to copy to range into\n   * @param clientArgs - The client args to use when evaluating the range for copying\n   */\n  copy(range, register, clientArgs) {\n    const segs = this.mergeTree.cloneSegments(clientArgs.referenceSequenceNumber, clientArgs.clientId, range.start, range.end);\n    this.registerCollection.set(this.getLongClientId(clientArgs.clientId), register, segs);\n  }\n  ackPendingSegment(opArgs) {\n    const ackOp = deltaOpArgs => {\n      let trace;\n      if (this.measureOps) {\n        trace = Trace.start();\n      }\n      this.mergeTree.ackPendingSegment(deltaOpArgs, this.verboseOps);\n      if (deltaOpArgs.op.type === 2 /* ANNOTATE */) {\n        if (deltaOpArgs.op.combiningOp && deltaOpArgs.op.combiningOp.name === \"consensus\") {\n          this.updateConsensusProperty(deltaOpArgs.op, deltaOpArgs.sequencedMessage);\n        }\n      }\n      if (this.measureOps) {\n        this.accumTime += elapsedMicroseconds(trace);\n        this.accumOps++;\n        this.accumWindow += this.getCurrentSeq() - this.getCollabWindow().minSeq;\n      }\n      if (this.verboseOps) {\n        console.log(`@cli ${this.getLongClientId(this.getCollabWindow().clientId)} ` + `ack seq # ${deltaOpArgs.sequencedMessage.sequenceNumber}`);\n      }\n    };\n    if (opArgs.op.type === 3 /* GROUP */) {\n      for (const memberOp of opArgs.op.ops) {\n        ackOp({\n          groupOp: opArgs.op,\n          op: memberOp,\n          sequencedMessage: opArgs.sequencedMessage\n        });\n      }\n    } else {\n      ackOp(opArgs);\n    }\n  }\n  // as functions are modified move them above the eslint-disabled waterline and lint them\n  cloneFromSegments() {\n    const clone = new Client(this.specToSegment, this.logger, this.mergeTree.options);\n    const segments = [];\n    const newRoot = this.mergeTree.blockClone(this.mergeTree.root, segments);\n    clone.mergeTree.root = newRoot;\n    return clone;\n  }\n  getOrAddShortClientId(longClientId, branchId = 0) {\n    if (!this.clientNameToIds.get(longClientId)) {\n      this.addLongClientId(longClientId, branchId);\n    }\n    return this.getShortClientId(longClientId);\n  }\n  getShortClientId(longClientId) {\n    return this.clientNameToIds.get(longClientId).data.clientId;\n  }\n  getLongClientId(shortClientId) {\n    if (shortClientId >= 0) {\n      return this.shortClientIdMap[shortClientId];\n    } else {\n      return \"original\";\n    }\n  }\n  addLongClientId(longClientId, branchId = 0) {\n    this.clientNameToIds.put(longClientId, {\n      branchId,\n      clientId: this.shortClientIdMap.length\n    });\n    this.shortClientIdMap.push(longClientId);\n    this.shortClientBranchIdMap.push(branchId);\n  }\n  getBranchId(clientId) {\n    return this.shortClientBranchIdMap[clientId];\n  }\n  /**\n   * During reconnect, we must find the positions to pending segments\n   * relative to other pending segments. This methods computes that\n   * position relative to a localSeq. Pending segments above the localSeq\n   * will be ignored.\n   *\n   * @param segment - The segment to find the position for\n   * @param localSeq - The localSeq to find the position of the segment at\n   */\n  findReconnectionPostition(segment, localSeq) {\n    assert(localSeq <= this.mergeTree.collabWindow.localSeq, \"localSeq greater than collab window\");\n    let segmentPosition = 0;\n    /*\n        Walk the segments up to the current segment, and calculate it's\n        position taking into account local segments that were modified,\n        after the current segment.\n         TODO: Consider embedding this information into the tree for\n        more efficient look up of pending segment positions.\n    */\n    this.mergeTree.walkAllSegments(this.mergeTree.root, seg => {\n      // If we've found the desired segment, terminate the walk and return 'segmentPosition'.\n      if (seg === segment) {\n        return false;\n      }\n      // Otherwise, advance segmentPosition if the segment has been inserted and not removed\n      // with respect to the given 'localSeq'.\n      //\n      // Note that all ACKed / remote ops are applied and we only need concern ourself with\n      // determining if locally pending ops fall before/after the given 'localSeq'.\n      if ((seg.localSeq === undefined || seg.localSeq <= localSeq // Is inserted\n      ) && (seg.removedSeq === undefined || seg.localRemovedSeq > localSeq) // Not removed\n      ) {\n        segmentPosition += seg.cachedLength;\n      }\n      return true;\n    });\n    return segmentPosition;\n  }\n  resetPendingDeltaToOps(resetOp, segmentGroup) {\n    assert(!!segmentGroup, \"Segment group undefined\");\n    const NACKedSegmentGroup = this.mergeTree.pendingSegments.dequeue();\n    assert(segmentGroup === NACKedSegmentGroup, \"Segment group not at head of merge tree pending queue\");\n    const opList = [];\n    // We need to sort the segments by ordinal, as the segments are not sorted in the segment group.\n    // The reason they need them sorted, as they have the same local sequence number and which means\n    // farther segments will  take into account nearer segments when calculating their position.\n    // By sorting we ensure the nearer segment will be applied and sequenced before the father segments\n    // so their recalulated positions will be correct.\n    for (const segment of segmentGroup.segments.sort((a, b) => a.ordinal < b.ordinal ? -1 : 1)) {\n      const segmentSegGroup = segment.segmentGroups.dequeue();\n      assert(segmentGroup === segmentSegGroup, \"Segment group not at head of segment pending queue\");\n      const segmentPosition = this.findReconnectionPostition(segment, segmentGroup.localSeq);\n      let newOp;\n      switch (resetOp.type) {\n        case 2 /* ANNOTATE */:\n          assert(segment.propertyManager.hasPendingProperties(), \"Segment has no pending properties\");\n          newOp = OpBuilder.createAnnotateRangeOp(segmentPosition, segmentPosition + segment.cachedLength, resetOp.props, resetOp.combiningOp);\n          break;\n        case 0 /* INSERT */:\n          assert(segment.seq === UnassignedSequenceNumber);\n          newOp = OpBuilder.createInsertSegmentOp(segmentPosition, segment);\n          break;\n        case 1 /* REMOVE */:\n          if (segment.localRemovedSeq !== undefined) {\n            newOp = OpBuilder.createRemoveRangeOp(segmentPosition, segmentPosition + segment.cachedLength);\n          }\n          break;\n        default:\n          throw new Error(`Invalid op type`);\n      }\n      if (newOp) {\n        const newSegmentGroup = {\n          segments: [],\n          localSeq: segmentGroup.localSeq\n        };\n        segment.segmentGroups.enqueue(newSegmentGroup);\n        this.mergeTree.pendingSegments.enqueue(newSegmentGroup);\n        opList.push(newOp);\n      }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return opList;\n  }\n  applyRemoteOp(opArgs) {\n    const op = opArgs.op;\n    const msg = opArgs.sequencedMessage;\n    this.getOrAddShortClientId(msg.clientId);\n    switch (op.type) {\n      case 0 /* INSERT */:\n        this.applyInsertOp(opArgs);\n        break;\n      case 1 /* REMOVE */:\n        this.applyRemoveRangeOp(opArgs);\n        break;\n      case 2 /* ANNOTATE */:\n        this.applyAnnotateRangeOp(opArgs);\n        break;\n      case 3 /* GROUP */:\n        {\n          for (const memberOp of op.ops) {\n            this.applyRemoteOp({\n              op: memberOp,\n              groupOp: op,\n              sequencedMessage: msg\n            });\n          }\n          break;\n        }\n      default:\n        break;\n    }\n  }\n  applyMsg(msg) {\n    // Ensure client ID is registered\n    // TODO support for more than two branch IDs\n    // The existence of msg.origin means we are a branch message - and so should be marked as 0\n    // The non-existence of msg.origin indicates we are local - and should inherit the collab mode ID\n    const branchId = msg.origin ? 0 : this.mergeTree.localBranchId;\n    this.getOrAddShortClientId(msg.clientId, branchId);\n    // Apply if an operation message\n    if (msg.type === MessageType.Operation) {\n      const opArgs = {\n        op: msg.contents,\n        sequencedMessage: msg\n      };\n      if (opArgs.sequencedMessage.clientId === this.longClientId) {\n        this.ackPendingSegment(opArgs);\n      } else {\n        this.applyRemoteOp(opArgs);\n      }\n    }\n    this.updateSeqNumbers(msg.minimumSequenceNumber, msg.sequenceNumber);\n  }\n  updateSeqNumbers(min, seq) {\n    const collabWindow = this.mergeTree.getCollabWindow();\n    // Equal is fine here due to SharedSegmentSequence<>.snapshotContent() potentially updating with same #\n    assert(collabWindow.currentSeq <= seq, \"Incoming op sequence# < local collabWindow's currentSequence#\");\n    collabWindow.currentSeq = seq;\n    assert(min <= seq, \"Incoming op sequence# < minSequence#\");\n    this.updateMinSeq(min);\n  }\n  /**\n   * Resolves a remote client's position against the local sequence\n   * and returns the remote client's position relative to the local\n   * sequence\n   * @param remoteClientPosition - The remote client's position to resolve\n   * @param remoteClientRefSeq - The reference sequence number of the remote client\n   * @param remoteClientId - The client id of the remote client\n   */\n  resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId) {\n    const shortRemoteClientId = this.getOrAddShortClientId(remoteClientId);\n    return this.mergeTree.resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, shortRemoteClientId);\n  }\n  /**\n   *  Given an pending operation and segment group, regenerate the op, so it\n   *  can be resubmitted\n   * @param resetOp - The op to reset\n   * @param segmentGroup - The segment group associated with the op\n   */\n  regeneratePendingOp(resetOp, segmentGroup) {\n    const trace = Trace.start();\n    try {\n      const opList = [];\n      if (resetOp.type === 3 /* GROUP */) {\n        if (Array.isArray(segmentGroup)) {\n          assert(resetOp.ops.length === segmentGroup.length, \"Number of ops in 'resetOp' must match the number of segment groups provided.\");\n          for (let i = 0; i < resetOp.ops.length; i++) {\n            opList.push(...this.resetPendingDeltaToOps(resetOp.ops[i], segmentGroup[i]));\n          }\n        } else {\n          // A group op containing a single op will pass a direct reference to 'segmentGroup'\n          // rather than an array of segment groups.  (See 'peekPendingSegmentGroups()')\n          assert(resetOp.ops.length === 1, \"Number of ops in 'resetOp' must match the number of segment groups provided.\");\n          opList.push(...this.resetPendingDeltaToOps(resetOp.ops[0], segmentGroup));\n        }\n      } else {\n        assert(resetOp.type !== 3 /* GROUP */);\n        assert(!Array.isArray(segmentGroup));\n        opList.push(...this.resetPendingDeltaToOps(resetOp, segmentGroup));\n      }\n      return opList.length === 1 ? opList[0] : OpBuilder.createGroupOp(...opList);\n    } finally {\n      this.logger.sendPerformanceEvent({\n        eventName: \"MergeTree:RegeneratePendingOp\",\n        category: \"performance\",\n        duration: elapsedMicroseconds(trace)\n      });\n    }\n  }\n  createTextHelper() {\n    return new MergeTreeTextHelper(this.mergeTree);\n  }\n  // TODO: Remove `catchUpMsgs` once new snapshot format is adopted as default.\n  //       (See https://github.com/microsoft/FluidFramework/issues/84)\n  snapshot(runtime, handle, serializer, catchUpMsgs) {\n    var _a;\n    const deltaManager = runtime.deltaManager;\n    const minSeq = deltaManager.minimumSequenceNumber;\n    // Catch up to latest MSN, if we have not had a chance to do it.\n    // Required for case where FluidDataStoreRuntime.attachChannel()\n    // generates snapshot right after loading data store.\n    this.updateSeqNumbers(minSeq, deltaManager.lastSequenceNumber);\n    // One of the snapshots (from SPO) I observed to have chunk.chunkSequenceNumber > minSeq!\n    // Not sure why - need to catch it sooner\n    assert(this.getCollabWindow().minSeq === minSeq);\n    // TODO: Remove options flag once new snapshot format is adopted as default.\n    //       (See https://github.com/microsoft/FluidFramework/issues/84)\n    if (((_a = this.mergeTree.options) === null || _a === void 0 ? void 0 : _a.newMergeTreeSnapshotFormat) === true) {\n      assert(catchUpMsgs === undefined || catchUpMsgs.length === 0, \"New format should not emit catchup ops\");\n      const snap = new SnapshotV1(this.mergeTree, this.logger);\n      snap.extractSync();\n      return snap.emit(serializer, handle);\n    } else {\n      const snap = new SnapshotLegacy(this.mergeTree, this.logger);\n      snap.extractSync();\n      return snap.emit(catchUpMsgs, serializer, handle);\n    }\n  }\n  load(runtime, storage, serializer) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const loader = new SnapshotLoader(runtime, _this, _this.mergeTree, _this.logger, serializer);\n      return loader.initialize(storage);\n    })();\n  }\n  getStackContext(startPos, rangeLabels) {\n    return this.mergeTree.getStackContext(startPos, this.getCollabWindow().clientId, rangeLabels);\n  }\n  getLocalSequenceNumber() {\n    const segWindow = this.getCollabWindow();\n    if (segWindow.collaborating) {\n      return UnassignedSequenceNumber;\n    } else {\n      return UniversalSequenceNumber;\n    }\n  }\n  localTransaction(groupOp) {\n    for (const op of groupOp.ops) {\n      const opArgs = {\n        op,\n        groupOp\n      };\n      switch (op.type) {\n        case 0 /* INSERT */:\n          this.applyInsertOp(opArgs);\n          break;\n        case 2 /* ANNOTATE */:\n          this.applyAnnotateRangeOp(opArgs);\n          break;\n        case 1 /* REMOVE */:\n          this.applyRemoveRangeOp(opArgs);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  updateConsensusProperty(op, msg) {\n    const markerId = op.relativePos1.id;\n    const consensusInfo = this.pendingConsensus.get(markerId);\n    if (consensusInfo) {\n      consensusInfo.marker.addProperties(op.props, op.combiningOp, msg.sequenceNumber);\n    }\n    this.mergeTree.addMinSeqListener(msg.sequenceNumber, () => consensusInfo.callback(consensusInfo.marker));\n  }\n  updateMinSeq(minSeq) {\n    let trace;\n    if (this.measureOps) {\n      trace = Trace.start();\n    }\n    this.mergeTree.setMinSeq(minSeq);\n    if (this.measureOps) {\n      const elapsed = elapsedMicroseconds(trace);\n      this.accumWindowTime += elapsed;\n      if (elapsed > this.maxWindowTime) {\n        this.maxWindowTime = elapsed;\n      }\n    }\n  }\n  getContainingSegment(pos) {\n    const segWindow = this.mergeTree.getCollabWindow();\n    return this.mergeTree.getContainingSegment(pos, segWindow.currentSeq, segWindow.clientId);\n  }\n  getPropertiesAtPosition(pos) {\n    const segWindow = this.getCollabWindow();\n    if (this.verboseOps) {\n      // eslint-disable-next-line max-len\n      console.log(`getPropertiesAtPosition cli ${this.getLongClientId(segWindow.clientId)} ref seq ${segWindow.currentSeq}`);\n    }\n    let propertiesAtPosition;\n    const segoff = this.getContainingSegment(pos);\n    const seg = segoff.segment;\n    if (seg) {\n      propertiesAtPosition = seg.properties;\n    }\n    return propertiesAtPosition;\n  }\n  getRangeExtentsOfPosition(pos) {\n    const segWindow = this.getCollabWindow();\n    if (this.verboseOps) {\n      // eslint-disable-next-line max-len\n      console.log(`getRangeExtentsOfPosition cli ${this.getLongClientId(segWindow.clientId)} ref seq ${segWindow.currentSeq}`);\n    }\n    let posStart;\n    let posAfterEnd;\n    const segoff = this.getContainingSegment(pos);\n    const seg = segoff.segment;\n    if (seg) {\n      posStart = this.getPosition(seg);\n      posAfterEnd = posStart + seg.cachedLength;\n    }\n    return {\n      posStart,\n      posAfterEnd\n    };\n  }\n  getCurrentSeq() {\n    return this.getCollabWindow().currentSeq;\n  }\n  getClientId() {\n    return this.getCollabWindow().clientId;\n  }\n  getLength() {\n    return this.mergeTree.length;\n  }\n  startOrUpdateCollaboration(longClientId, minSeq = 0, currentSeq = 0, branchId = 0) {\n    // we should always have a client id if we are collaborating\n    // if the client id is undefined we are likely bound to a detached\n    // container, so we should keep going in local mode. once\n    // the container attaches this will be called again on connect with the\n    // client id\n    if (longClientId !== undefined) {\n      if (this.longClientId === undefined) {\n        this.longClientId = longClientId;\n        this.addLongClientId(this.longClientId, branchId);\n        this.mergeTree.startCollaboration(this.getShortClientId(this.longClientId), minSeq, currentSeq, branchId);\n      } else {\n        const oldClientId = this.longClientId;\n        const oldData = this.clientNameToIds.get(oldClientId).data;\n        this.longClientId = longClientId;\n        this.clientNameToIds.put(longClientId, oldData);\n        this.shortClientIdMap[oldData.clientId] = longClientId;\n      }\n    }\n  }\n  findTile(startPos, tileLabel, preceding = true) {\n    const clientId = this.getClientId();\n    return this.mergeTree.findTile(startPos, clientId, tileLabel, preceding);\n  }\n}\n//# sourceMappingURL=client.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}