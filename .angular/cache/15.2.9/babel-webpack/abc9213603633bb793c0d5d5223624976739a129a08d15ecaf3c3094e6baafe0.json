{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { isOnline, OnlineStatus } from \"@fluidframework/driver-utils\";\nexport function logNetworkFailure(logger, event, error) {\n  var _a, _b, _c;\n  const newEvent = Object.assign({}, event);\n  newEvent.online = isOnline();\n  if (((_a = error) === null || _a === void 0 ? void 0 : _a.online) !== undefined) {\n    newEvent.online = error.online;\n  }\n  if (typeof navigator === \"object\" && navigator !== null) {\n    const nav = navigator;\n    const connection = (_c = (_b = nav.connection, _b !== null && _b !== void 0 ? _b : nav.mozConnection), _c !== null && _c !== void 0 ? _c : nav.webkitConnection);\n    if (connection !== null && typeof connection === \"object\") {\n      newEvent.connectionType = connection.type;\n    }\n  }\n  // If we are online, log it as an error, such that we look at it ASAP.\n  // But if we  are offline, log non-error event - we will remove\n  // it in the future once confident it's right thing to do.\n  // Note: Unfortunately false positives happen in here (i.e. cable disconnected, but it reports true)!\n  if (newEvent.online === OnlineStatus.Online) {\n    logger.logException(newEvent, error);\n  } else {\n    logger.sendTelemetryEvent(newEvent, error);\n  }\n}\n/**\n * Wait for browser to get to connected state.\n * If connected, waits minimum of minDelay anyway (between network retries)\n * If disconnected, polls every 30 seconds anyway, to make sure we are not getting stuck because of wrong signal\n * Note that browsers will have false positives (like having Hyper-V adapter on machine,\n * or machine connected to router that is not connected to internet)\n * But there should be no false negatives.\n * The only exception - Opera returns false when user enters \"Work Offline\" mode, regardless of actual connectivity.\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async\nexport function waitForConnectedState(minDelay) {\n  // Use this frequency to poll even when we are offline and able to setup online/offline listener\n  // This is mostly safety net\n  const offlinePollFrequency = 30000;\n  return new Promise(resolve => {\n    var _a;\n    let listener = resolve;\n    let delay = minDelay;\n    if (isOnline() === OnlineStatus.Offline) {\n      if (((_a = window) === null || _a === void 0 ? void 0 : _a.addEventListener) !== undefined) {\n        listener = () => {\n          resolve();\n          window.removeEventListener(\"online\", listener);\n        };\n        window.addEventListener(\"online\", listener, false);\n        delay = Math.max(minDelay, offlinePollFrequency);\n      }\n    }\n    setTimeout(listener, delay);\n  });\n}\n//# sourceMappingURL=networkUtils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}