{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { EventEmitter } from \"events\";\nimport { Heap, PromiseTimer } from \"@fluidframework/common-utils\";\nimport { ChildLogger, PerformanceEvent } from \"@fluidframework/telemetry-utils\";\nimport { LoaderHeader } from \"@fluidframework/container-definitions\";\nimport { DriverHeader } from \"@fluidframework/driver-definitions\";\nimport { createSummarizingWarning } from \"./summarizer\";\nexport const summarizerClientType = \"summarizer\";\nclass ClientComparer {\n  constructor() {\n    this.min = {\n      clientId: \"\",\n      sequenceNumber: -1,\n      isSummarizer: false\n    };\n  }\n  compare(a, b) {\n    return a.sequenceNumber - b.sequenceNumber;\n  }\n}\nclass QuorumHeap {\n  constructor() {\n    this.heap = new Heap(new ClientComparer());\n    this.heapMembers = new Map();\n    this.summarizerCount = 0;\n  }\n  addClient(clientId, client) {\n    var _a;\n    // Have to undefined-check client.details for backwards compatibility\n    const isSummarizer = ((_a = client.client.details) === null || _a === void 0 ? void 0 : _a.type) === summarizerClientType;\n    const heapNode = this.heap.add({\n      clientId,\n      sequenceNumber: client.sequenceNumber,\n      isSummarizer\n    });\n    this.heapMembers.set(clientId, heapNode);\n    if (isSummarizer) {\n      this.summarizerCount++;\n    }\n  }\n  removeClient(clientId) {\n    const member = this.heapMembers.get(clientId);\n    if (member) {\n      this.heap.remove(member);\n      this.heapMembers.delete(clientId);\n      if (member.value.isSummarizer) {\n        this.summarizerCount--;\n      }\n    }\n  }\n  getFirstClientId() {\n    return this.heap.count() > 0 ? this.heap.peek().value.clientId : undefined;\n  }\n  getSummarizerCount() {\n    return this.summarizerCount;\n  }\n}\nvar SummaryManagerState = /*#__PURE__*/(() => {\n  (function (SummaryManagerState) {\n    SummaryManagerState[SummaryManagerState[\"Off\"] = 0] = \"Off\";\n    SummaryManagerState[SummaryManagerState[\"Starting\"] = 1] = \"Starting\";\n    SummaryManagerState[SummaryManagerState[\"Running\"] = 2] = \"Running\";\n    SummaryManagerState[SummaryManagerState[\"Stopping\"] = 3] = \"Stopping\";\n    SummaryManagerState[SummaryManagerState[\"Disabled\"] = -1] = \"Disabled\";\n  })(SummaryManagerState || (SummaryManagerState = {}));\n  return SummaryManagerState;\n})();\nconst defaultInitialDelayMs = 5000;\nconst opsToBypassInitialDelay = 4000;\nconst defaultThrottleDelayWindowMs = 60 * 1000;\nconst defaultThrottleMaxDelayMs = 30 * 1000;\n// default throttling function increases exponentially (0ms, 20ms, 60ms, 140ms, etc)\nconst defaultThrottleDelayFunction = n => 20 * (Math.pow(2, n) - 1);\n/**\n * Used to give increasing delay times for throttling a single functionality.\n * Delay is based on previous attempts within specified time window, ignoring actual delay time.\n */\nclass Throttler {\n  constructor(delayWindowMs, maxDelayMs, delayFunction) {\n    this.delayWindowMs = delayWindowMs;\n    this.maxDelayMs = maxDelayMs;\n    this.delayFunction = delayFunction;\n    this.startTimes = [];\n  }\n  get attempts() {\n    return this.startTimes.length;\n  }\n  getDelay() {\n    const now = Date.now();\n    this.startTimes = this.startTimes.filter(t => now - t < this.delayWindowMs);\n    const delayMs = Math.min(this.delayFunction(this.startTimes.length), this.maxDelayMs);\n    this.startTimes.push(now);\n    this.startTimes = this.startTimes.map(t => t + delayMs); // account for delay time\n    if (delayMs === this.maxDelayMs) {\n      // we hit max delay so adding more won't affect anything\n      // shift off oldest time to stop this array from growing forever\n      this.startTimes.shift();\n    }\n    return delayMs;\n  }\n}\nexport class SummaryManager extends EventEmitter {\n  constructor(context, summariesEnabled, enableWorker, parentLogger, setNextSummarizer, nextSummarizerP, immediateSummary = false, initialDelayMs = defaultInitialDelayMs) {\n    var _a, _b;\n    super();\n    this.context = context;\n    this.summariesEnabled = summariesEnabled;\n    this.enableWorker = enableWorker;\n    this.setNextSummarizer = setNextSummarizer;\n    this.nextSummarizerP = nextSummarizerP;\n    this.quorumHeap = new QuorumHeap();\n    this.connected = false;\n    this.state = SummaryManagerState.Off;\n    this._disposed = false;\n    this.startThrottler = new Throttler(defaultThrottleDelayWindowMs, defaultThrottleMaxDelayMs, defaultThrottleDelayFunction);\n    this.opsUntilFirstConnect = -1;\n    this.logger = ChildLogger.create(parentLogger, \"SummaryManager\", undefined, {\n      clientId: () => this.latestClientId\n    });\n    this.connected = context.connected;\n    if (this.connected) {\n      this.setClientId(context.clientId);\n    }\n    const members = context.quorum.getMembers();\n    for (const [clientId, client] of members) {\n      this.quorumHeap.addClient(clientId, client);\n    }\n    context.quorum.on(\"addMember\", (clientId, details) => {\n      if (this.opsUntilFirstConnect === -1 && clientId === this.clientId) {\n        this.opsUntilFirstConnect = details.sequenceNumber - this.context.deltaManager.initialSequenceNumber;\n      }\n      this.quorumHeap.addClient(clientId, details);\n      this.refreshSummarizer();\n    });\n    context.quorum.on(\"removeMember\", clientId => {\n      this.quorumHeap.removeClient(clientId);\n      this.refreshSummarizer();\n    });\n    this.initialDelayTimer = immediateSummary ? undefined : new PromiseTimer(initialDelayMs, () => {});\n    this.initialDelayP = (_b = (_a = this.initialDelayTimer) === null || _a === void 0 ? void 0 : _a.start(), _b !== null && _b !== void 0 ? _b : Promise.resolve());\n    this.refreshSummarizer();\n  }\n  get summarizer() {\n    return this.summarizerClientId;\n  }\n  get disposed() {\n    return this._disposed;\n  }\n  setConnected(clientId) {\n    this.updateConnected(true, clientId);\n  }\n  setDisconnected() {\n    this.updateConnected(false);\n  }\n  setClientId(clientId) {\n    this.clientId = clientId;\n    if (clientId !== undefined) {\n      this.latestClientId = clientId;\n      if (this.runningSummarizer !== undefined) {\n        this.runningSummarizer.updateOnBehalfOf(clientId);\n      }\n    }\n  }\n  on(event, listener) {\n    return super.on(event, listener);\n  }\n  updateConnected(connected, clientId) {\n    if (this.connected === connected) {\n      return;\n    }\n    this.connected = connected;\n    this.setClientId(clientId);\n    this.refreshSummarizer();\n  }\n  getShouldSummarizeState() {\n    if (!this.connected) {\n      return {\n        shouldSummarize: false,\n        stopReason: \"parentNotConnected\"\n      };\n    } else if (this.clientId !== this.summarizer) {\n      return {\n        shouldSummarize: false,\n        stopReason: \"parentShouldNotSummarize\"\n      };\n    } else if (this.disposed) {\n      return {\n        shouldSummarize: false,\n        stopReason: \"disposed\"\n      };\n    } else if (this.nextSummarizerP !== undefined) {\n      // This client has just come from a context reload, which means its\n      // summarizer client did as well.  We need to call start to rebind them.\n      return {\n        shouldSummarize: true,\n        shouldStart: true\n      };\n    } else if (this.quorumHeap.getSummarizerCount() > 0) {\n      // Need to wait for any other existing summarizer clients to close,\n      // because they can live longer than their parent container.\n      return {\n        shouldSummarize: true,\n        shouldStart: false\n      };\n    } else {\n      return {\n        shouldSummarize: true,\n        shouldStart: true\n      };\n    }\n  }\n  refreshSummarizer() {\n    // Compute summarizer\n    const newSummarizerClientId = this.quorumHeap.getFirstClientId();\n    if (newSummarizerClientId !== this.summarizerClientId) {\n      this.summarizerClientId = newSummarizerClientId;\n      this.emit(\"summarizer\", newSummarizerClientId);\n    }\n    // Transition states depending on shouldSummarize, which is a calculated\n    // property that is only true if this client is connected and has the\n    // computed summarizer client id\n    const shouldSummarizeState = this.getShouldSummarizeState();\n    switch (this.state) {\n      case SummaryManagerState.Off:\n        {\n          if (shouldSummarizeState.shouldSummarize && shouldSummarizeState.shouldStart) {\n            this.start();\n          }\n          return;\n        }\n      case SummaryManagerState.Starting:\n        {\n          // Cannot take any action until summarizer is created\n          // state transition will occur after creation\n          return;\n        }\n      case SummaryManagerState.Running:\n        {\n          if (shouldSummarizeState.shouldSummarize === false) {\n            this.stop(shouldSummarizeState.stopReason);\n          }\n          return;\n        }\n      case SummaryManagerState.Stopping:\n        {\n          // Cannot take any action until running summarizer finishes\n          // state transition will occur after it stops\n          return;\n        }\n      case SummaryManagerState.Disabled:\n        {\n          // Never switch away from disabled state\n          return;\n        }\n      default:\n        {\n          return;\n        }\n    }\n  }\n  raiseContainerWarning(warning) {\n    this.context.raiseContainerWarning(warning);\n  }\n  start() {\n    if (!this.summariesEnabled) {\n      // If we should never summarize, lock in disabled state\n      this.logger.sendTelemetryEvent({\n        eventName: \"SummariesDisabled\"\n      });\n      this.state = SummaryManagerState.Disabled;\n      return;\n    }\n    if (this.context.clientDetails.type === summarizerClientType) {\n      // Make sure that the summarizer client does not load another summarizer.\n      this.state = SummaryManagerState.Disabled;\n      return;\n    }\n    this.state = SummaryManagerState.Starting;\n    // throttle creation of new summarizer containers to prevent spamming the server with websocket connections\n    const delayMs = this.startThrottler.getDelay();\n    if (delayMs >= defaultThrottleMaxDelayMs) {\n      // we can't create a summarizer for some reason; raise error on container\n      this.raiseContainerWarning(createSummarizingWarning(\"SummaryManager: CreateSummarizer Max Throttle Delay\", false));\n    }\n    this.createSummarizer(delayMs).then(summarizer => {\n      this.setNextSummarizer(summarizer.setSummarizer());\n      summarizer.on(\"summarizingError\", warning => this.raiseContainerWarning(warning));\n      this.run(summarizer);\n    }, error => {\n      this.logger.sendErrorEvent({\n        eventName: \"CreateSummarizerError\",\n        attempt: this.startThrottler.attempts\n      }, error);\n      this.tryRestart();\n    });\n  }\n  run(summarizer) {\n    this.state = SummaryManagerState.Running;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const clientId = this.latestClientId;\n    this.runningSummarizer = summarizer;\n    PerformanceEvent.timedExecAsync(this.logger, {\n      eventName: \"RunningSummarizer\",\n      attempt: this.startThrottler.attempts\n    }, /*#__PURE__*/_asyncToGenerator(function* () {\n      return summarizer.run(clientId);\n    })).finally(() => {\n      this.runningSummarizer = undefined;\n      this.nextSummarizerP = undefined;\n      this.tryRestart();\n    });\n    const shouldSummarizeState = this.getShouldSummarizeState();\n    if (shouldSummarizeState.shouldSummarize === false) {\n      this.stop(shouldSummarizeState.stopReason);\n    }\n  }\n  tryRestart() {\n    const shouldSummarizeState = this.getShouldSummarizeState();\n    if (shouldSummarizeState.shouldSummarize && shouldSummarizeState.shouldStart) {\n      this.start();\n    } else {\n      this.state = SummaryManagerState.Off;\n    }\n  }\n  stop(reason) {\n    this.state = SummaryManagerState.Stopping;\n    if (this.runningSummarizer) {\n      // Stopping the running summarizer client should trigger a change\n      // in states when the running summarizer closes\n      this.runningSummarizer.stop(reason);\n    } else {\n      // Should not be possible to hit this case\n      this.logger.sendErrorEvent({\n        eventName: \"StopCalledWithoutRunningSummarizer\",\n        reason\n      });\n      this.state = SummaryManagerState.Off;\n    }\n  }\n  createSummarizer(delayMs) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // We have been elected the summarizer. Some day we may be able to summarize with a live document but for\n      // now we play it safe and launch a second copy.\n      _this.logger.sendTelemetryEvent({\n        eventName: \"CreatingSummarizer\",\n        delayMs,\n        opsUntilFirstConnect: _this.opsUntilFirstConnect\n      });\n      const shouldDelay = delayMs > 0;\n      const shouldInitialDelay = _this.opsUntilFirstConnect < opsToBypassInitialDelay;\n      if (shouldDelay || shouldInitialDelay) {\n        yield Promise.all([shouldInitialDelay ? _this.initialDelayP : Promise.resolve(), shouldDelay ? new Promise(resolve => setTimeout(resolve, delayMs)) : Promise.resolve()]);\n      }\n      if (_this.nextSummarizerP) {\n        return _this.nextSummarizerP;\n      }\n      const loader = _this.context.loader;\n      // TODO eventually we may wish to spawn an execution context from which to run this\n      const request = {\n        headers: {\n          [LoaderHeader.cache]: false,\n          [LoaderHeader.clientDetails]: {\n            capabilities: {\n              interactive: false\n            },\n            type: summarizerClientType\n          },\n          [DriverHeader.summarizingClient]: true,\n          [LoaderHeader.reconnect]: false,\n          [LoaderHeader.sequenceNumber]: _this.context.deltaManager.lastSequenceNumber,\n          [LoaderHeader.executionContext]: _this.enableWorker ? \"worker\" : undefined\n        },\n        url: \"/_summarizer\"\n      };\n      const response = yield loader.request(request);\n      if (response.status !== 200 || response.mimeType !== \"fluid/object\" && response.mimeType !== \"fluid/component\") {\n        return Promise.reject(new Error(\"Invalid summarizer route\"));\n      }\n      const rawFluidObject = response.value;\n      const summarizer = rawFluidObject.ISummarizer;\n      if (!summarizer) {\n        return Promise.reject(new Error(\"Fluid object does not implement ISummarizer\"));\n      }\n      return summarizer;\n    })();\n  }\n  dispose() {\n    var _a;\n    (_a = this.initialDelayTimer) === null || _a === void 0 ? void 0 : _a.clear();\n    this._disposed = true;\n  }\n}\n//# sourceMappingURL=summaryManager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}