{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\n/**\n * Trims the leading and trailing slashes from the given string.\n * @param str - A string that may contain leading and / or trailing slashes.\n * @returns A new string without leading and trailing slashes.\n */\nexport function trimLeadingAndTrailingSlashes(str) {\n  return str.replace(/^\\/+|\\/+$/g, \"\");\n}\n/**\n * Trims the leading slashes from the given string.\n * @param str - A string that may contain leading slashes.\n * @returns A new string without leading slashes.\n */\nexport function trimLeadingSlashes(str) {\n  return str.replace(/^\\/+/g, \"\");\n}\n/**\n * Trims the trailing slashes from the given string.\n * @param str - A string that may contain trailing slashes.\n * @returns A new string without trailing slashes.\n */\nexport function trimTrailingSlashes(str) {\n  return str.replace(/\\/+$/g, \"\");\n}\n/**\n * Helper function that clones the GC data.\n * @param gcData - The GC data to clone.\n * @returns a clone of the given GC data.\n */\nexport function cloneGCData(gcData) {\n  const clonedGCNodes = {};\n  for (const [id, outboundRoutes] of Object.entries(gcData.gcNodes)) {\n    clonedGCNodes[id] = Array.from(outboundRoutes);\n  }\n  return {\n    gcNodes: clonedGCNodes\n  };\n}\n/**\n * Helper function that unpacks the GC details of the children from a given node's GC details.\n * @param gcDetails - The GC details of a node.\n * @returns A map of GC details of each children of the the given node.\n */\nexport function unpackChildNodesGCDetails(gcDetails) {\n  const childGCDetailsMap = new Map();\n  // If GC data is not available, bail out.\n  if (gcDetails.gcData === undefined) {\n    return childGCDetailsMap;\n  }\n  // Remove the node's self GC nodes, if any, and generate the children GC nodes.\n  const gcNodes = gcDetails.gcData.gcNodes;\n  delete gcNodes[\"/\"];\n  for (const [id, outboundRoutes] of Object.entries(gcNodes)) {\n    assert(id.startsWith(\"/\"), 0x2ae /* \"node id should always be an absolute route\" */);\n    const childId = id.split(\"/\")[1];\n    let childGCNodeId = id.slice(childId.length + 1);\n    // GC node id always begins with \"/\". Handle the special case where a child's id in the parent's GC nodes is\n    // of format `/root`. In this case, the childId is root and childGCNodeId is \"\". Make childGCNodeId = \"/\".\n    if (childGCNodeId === \"\") {\n      childGCNodeId = \"/\";\n    }\n    let childGCDetails = childGCDetailsMap.get(childId);\n    if (childGCDetails === undefined) {\n      childGCDetails = {\n        gcData: {\n          gcNodes: {}\n        },\n        usedRoutes: []\n      };\n    }\n    // gcData should not undefined as its always at least initialized as  empty above.\n    assert(childGCDetails.gcData !== undefined, 0x2af /* \"Child GC data should have been initialized\" */);\n    childGCDetails.gcData.gcNodes[childGCNodeId] = [...new Set(outboundRoutes)];\n    childGCDetailsMap.set(childId, childGCDetails);\n  }\n  if (gcDetails.usedRoutes === undefined) {\n    return childGCDetailsMap;\n  }\n  // Remove the node's self used route, if any, and generate the children used routes.\n  const usedRoutes = gcDetails.usedRoutes.filter(route => route !== \"\" && route !== \"/\");\n  for (const route of usedRoutes) {\n    assert(route.startsWith(\"/\"), 0x2b0 /* \"Used route should always be an absolute route\" */);\n    const childId = route.split(\"/\")[1];\n    const childUsedRoute = route.slice(childId.length + 1);\n    const childGCDetails = childGCDetailsMap.get(childId);\n    assert((childGCDetails === null || childGCDetails === void 0 ? void 0 : childGCDetails.usedRoutes) !== undefined, 0x2b1 /* \"This should have be initiallized when generate GC nodes above\" */);\n    childGCDetails.usedRoutes.push(childUsedRoute);\n    childGCDetailsMap.set(childId, childGCDetails);\n  }\n  return childGCDetailsMap;\n}\n/**\n * Helper function that unpacks the used routes of children from a given node's used routes.\n * @param usedRoutes - The used routes of a node.\n * @returns A map of used routes of each children of the the given node.\n */\nexport function unpackChildNodesUsedRoutes(usedRoutes) {\n  // Remove the node's self used route, if any, and generate the children used routes.\n  const filteredUsedRoutes = usedRoutes.filter(route => route !== \"\" && route !== \"/\");\n  const childUsedRoutesMap = new Map();\n  for (const route of filteredUsedRoutes) {\n    assert(route.startsWith(\"/\"), 0x198 /* \"Used route should always be an absolute route\" */);\n    const childId = route.split(\"/\")[1];\n    const childUsedRoute = route.slice(childId.length + 1);\n    const childUsedRoutes = childUsedRoutesMap.get(childId);\n    if (childUsedRoutes !== undefined) {\n      childUsedRoutes.push(childUsedRoute);\n    } else {\n      childUsedRoutesMap.set(childId, [childUsedRoute]);\n    }\n  }\n  return childUsedRoutesMap;\n}\n/**\n * Removes the given route from the outbound routes of all the given GC nodes, and any duplicates\n * @param gcNodes - The nodes from which the route is to be removed.\n * @param outboundRoute - The route to be removed.\n */\nexport function removeRouteFromAllNodes(gcNodes, outboundRoute) {\n  const channels = Object.entries(gcNodes);\n  for (const [nodeId, outboundRoutes] of channels) {\n    // Remove route from channel to parent for each channel\n    const outboundRoutesSet = new Set(outboundRoutes);\n    outboundRoutesSet.delete(outboundRoute);\n    gcNodes[nodeId] = [...outboundRoutesSet];\n  }\n}\n/**\n * Concatenates the given GC states and returns the concatenated GC state.\n */\nexport function concatGarbageCollectionStates(gcState1, gcState2) {\n  var _a;\n  const combinedGCNodes = {};\n  for (const [nodeId, nodeData] of Object.entries(gcState1.gcNodes)) {\n    combinedGCNodes[nodeId] = {\n      outboundRoutes: Array.from(nodeData.outboundRoutes),\n      unreferencedTimestampMs: nodeData.unreferencedTimestampMs\n    };\n  }\n  for (const [nodeId, nodeData] of Object.entries(gcState2.gcNodes)) {\n    let combinedNodedata = combinedGCNodes[nodeId];\n    if (combinedNodedata === undefined) {\n      combinedNodedata = {\n        outboundRoutes: Array.from(nodeData.outboundRoutes),\n        unreferencedTimestampMs: nodeData.unreferencedTimestampMs\n      };\n    } else {\n      // Validate that same node doesn't have different unreferenced timestamp.\n      if (nodeData.unreferencedTimestampMs !== undefined && combinedNodedata.unreferencedTimestampMs !== undefined) {\n        assert(nodeData.unreferencedTimestampMs === combinedNodedata.unreferencedTimestampMs, 0x2b2 /* \"Two entries for the same GC node with different unreferenced timestamp\" */);\n      }\n\n      combinedNodedata = {\n        outboundRoutes: [...new Set([...nodeData.outboundRoutes, ...combinedNodedata.outboundRoutes])],\n        unreferencedTimestampMs: (_a = nodeData.unreferencedTimestampMs) !== null && _a !== void 0 ? _a : combinedNodedata.unreferencedTimestampMs\n      };\n    }\n    combinedGCNodes[nodeId] = combinedNodedata;\n  }\n  return {\n    gcNodes: combinedGCNodes\n  };\n}\n/**\n * Concatenates the given GC datas and returns the concatenated GC data.\n */\nexport function concatGarbageCollectionData(gcData1, gcData2) {\n  const combinedGCData = cloneGCData(gcData1);\n  for (const [id, routes] of Object.entries(gcData2.gcNodes)) {\n    if (combinedGCData.gcNodes[id] === undefined) {\n      combinedGCData.gcNodes[id] = Array.from(routes);\n    } else {\n      const combinedRoutes = [...routes, ...combinedGCData.gcNodes[id]];\n      combinedGCData.gcNodes[id] = [...new Set(combinedRoutes)];\n    }\n  }\n  return combinedGCData;\n}\nexport class GCDataBuilder {\n  constructor() {\n    this.gcNodesSet = {};\n  }\n  get gcNodes() {\n    const gcNodes = {};\n    for (const [nodeId, outboundRoutes] of Object.entries(this.gcNodesSet)) {\n      gcNodes[nodeId] = [...outboundRoutes];\n    }\n    return gcNodes;\n  }\n  addNode(id, outboundRoutes) {\n    this.gcNodesSet[id] = new Set(outboundRoutes);\n  }\n  /**\n   * Adds the given GC nodes. It does the following:\n   * - Normalizes the ids of the given nodes.\n   * - Prefixes the given `prefixId` to the given nodes' ids.\n   * - Adds the outbound routes of the nodes against the normalized and prefixed id.\n   */\n  prefixAndAddNodes(prefixId, gcNodes) {\n    for (const [id, outboundRoutes] of Object.entries(gcNodes)) {\n      // Remove any leading slashes from the id.\n      let normalizedId = trimLeadingSlashes(id);\n      // Prefix the given id to the normalized id.\n      normalizedId = `/${prefixId}/${normalizedId}`;\n      // Remove any trailing slashes from the normalized id. Note that the trailing slashes are removed after\n      // adding the prefix for handling the special case where id is \"/\".\n      normalizedId = trimTrailingSlashes(normalizedId);\n      // Add the outbound routes against the normalized and prefixed id without duplicates.\n      this.gcNodesSet[normalizedId] = new Set(outboundRoutes);\n    }\n  }\n  addNodes(gcNodes) {\n    for (const [id, outboundRoutes] of Object.entries(gcNodes)) {\n      this.gcNodesSet[id] = new Set(outboundRoutes);\n    }\n  }\n  /**\n   * Adds the given outbound route to the outbound routes of all GC nodes.\n   */\n  addRouteToAllNodes(outboundRoute) {\n    for (const outboundRoutes of Object.values(this.gcNodesSet)) {\n      outboundRoutes.add(outboundRoute);\n    }\n  }\n  getGCData() {\n    return {\n      gcNodes: this.gcNodes\n    };\n  }\n}\n//# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}