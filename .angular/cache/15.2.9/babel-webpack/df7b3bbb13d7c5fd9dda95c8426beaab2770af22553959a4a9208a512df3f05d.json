{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { DriverErrorType } from \"@fluidframework/driver-definitions\";\nimport { LoggingError } from \"@fluidframework/telemetry-utils\";\nexport var OnlineStatus = /*#__PURE__*/(() => {\n  (function (OnlineStatus) {\n    OnlineStatus[OnlineStatus[\"Offline\"] = 0] = \"Offline\";\n    OnlineStatus[OnlineStatus[\"Online\"] = 1] = \"Online\";\n    OnlineStatus[OnlineStatus[\"Unknown\"] = 2] = \"Unknown\";\n  })(OnlineStatus || (OnlineStatus = {}));\n  return OnlineStatus;\n})();\n// It tells if we have local connection only - we might not have connection to web.\n// No solution for node.js (other than resolve dns names / ping specific sites)\n// Can also use window.addEventListener(\"online\" / \"offline\")\nexport function isOnline() {\n  // eslint-disable-next-line no-null/no-null\n  if (typeof navigator === \"object\" && navigator !== null && typeof navigator.onLine === \"boolean\") {\n    return navigator.onLine ? OnlineStatus.Online : OnlineStatus.Offline;\n  }\n  return OnlineStatus.Unknown;\n}\n/**\n * Generic network error class.\n */\nexport class GenericNetworkError extends LoggingError {\n  constructor(errorMessage, canRetry, statusCode) {\n    super(errorMessage, {\n      statusCode\n    });\n    this.canRetry = canRetry;\n    this.errorType = DriverErrorType.genericNetworkError;\n  }\n}\nexport class AuthorizationError extends LoggingError {\n  constructor(errorMessage, claims, statusCode) {\n    super(errorMessage, {\n      statusCode\n    });\n    this.claims = claims;\n    this.errorType = DriverErrorType.authorizationError;\n    this.canRetry = false;\n  }\n}\nexport class NetworkErrorBasic extends LoggingError {\n  constructor(errorMessage, errorType, canRetry, statusCode) {\n    super(errorMessage, {\n      statusCode\n    });\n    this.errorType = errorType;\n    this.canRetry = canRetry;\n  }\n}\nexport class NonRetryableError extends NetworkErrorBasic {\n  constructor(errorMessage, errorType, statusCode) {\n    super(errorMessage, errorType, false, statusCode);\n    this.errorType = errorType;\n  }\n}\n/**\n * Throttling error class - used to communicate all throttling errors\n */\nexport class ThrottlingError extends LoggingError {\n  constructor(errorMessage, retryAfterSeconds, statusCode) {\n    super(errorMessage, {\n      statusCode\n    });\n    this.retryAfterSeconds = retryAfterSeconds;\n    this.errorType = DriverErrorType.throttlingError;\n    this.canRetry = true;\n  }\n}\nexport const createWriteError = errorMessage => new NonRetryableError(errorMessage, DriverErrorType.writeError, undefined /* statusCodes */);\nexport function createGenericNetworkError(errorMessage, canRetry, retryAfterSeconds, statusCode) {\n  if (retryAfterSeconds !== undefined && canRetry) {\n    return new ThrottlingError(errorMessage, retryAfterSeconds, statusCode);\n  }\n  return new GenericNetworkError(errorMessage, canRetry, statusCode);\n}\n/**\n * Check if a connection error can be retried.  Unless explicitly disallowed, retry is allowed.\n * @param error - The error to inspect for ability to retry\n */\nexport const canRetryOnError = error => {\n  var _a;\n  return ((_a = error) === null || _a === void 0 ? void 0 : _a.canRetry) !== false;\n};\n//# sourceMappingURL=network.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}