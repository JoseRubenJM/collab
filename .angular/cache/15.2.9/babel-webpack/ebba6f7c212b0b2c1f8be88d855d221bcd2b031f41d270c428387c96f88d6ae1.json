{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, fromBase64ToUtf8, gitHashFile, IsoBuffer, Uint8ArrayToString } from \"@fluidframework/common-utils\";\nimport { buildHierarchy } from \"@fluidframework/protocol-base\";\nimport { FileMode } from \"@fluidframework/protocol-definitions\";\n/**\n * Document access to underlying storage for routerlicious driver.\n */\nexport class DocumentStorageService {\n  constructor(id, manager) {\n    this.id = id;\n    this.manager = manager;\n    // The values of this cache is useless. We only need the keys. So we are always putting\n    // empty strings as values.\n    this.blobsShaCache = new Map();\n    this._logTailSha = undefined;\n  }\n  get repositoryUrl() {\n    return \"\";\n  }\n  get logTailSha() {\n    return this._logTailSha;\n  }\n  getSnapshotTree(version) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      let requestVersion = version;\n      if (!requestVersion) {\n        const versions = yield _this.getVersions(_this.id, 1);\n        if (versions.length === 0) {\n          return null;\n        }\n        requestVersion = versions[0];\n      }\n      const rawTree = yield _this.manager.getTree(requestVersion.treeId);\n      const tree = buildHierarchy(rawTree, _this.blobsShaCache);\n      _this._logTailSha = \".logTail\" in tree.trees ? tree.trees[\".logTail\"].blobs.logTail : undefined;\n      return tree;\n    })();\n  }\n  getVersions(versionId, count) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const commits = yield _this2.manager.getCommits(versionId ? versionId : _this2.id, count);\n      return commits.map(commit => ({\n        date: commit.commit.author.date,\n        id: commit.sha,\n        treeId: commit.commit.tree.sha\n      }));\n    })();\n  }\n  read(blobId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const value = yield _this3.manager.getBlob(blobId);\n      _this3.blobsShaCache.set(value.sha, \"\");\n      return value.content;\n    })();\n  }\n  /**\n   * {@inheritDoc @fluidframework/driver-definitions#IDocumentStorageService.readString}\n   */\n  readString(blobId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const base64Result = yield _this4.read(blobId);\n      return fromBase64ToUtf8(base64Result);\n    })();\n  }\n  write(tree, parents, message, ref) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const branch = ref ? `datastores/${_this5.id}/${ref}` : _this5.id;\n      const commit = yield _this5.manager.write(branch, tree, parents, message);\n      return {\n        date: commit.committer.date,\n        id: commit.sha,\n        treeId: commit.tree.sha\n      };\n    })();\n  }\n  uploadSummaryWithContext(summary, context) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const snapshot = context.ackHandle ? yield _this6.getVersions(context.ackHandle, 1).then( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (versions) {\n          // Clear the cache as the getSnapshotTree call will fill the cache.\n          _this6.blobsShaCache.clear();\n          return _this6.getSnapshotTree(versions[0]);\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()) : undefined;\n      return _this6.writeSummaryTree(summary, snapshot !== null && snapshot !== void 0 ? snapshot : undefined);\n    })();\n  }\n  downloadSummary(handle) {\n    return _asyncToGenerator(function* () {\n      throw new Error(\"NOT IMPLEMENTED!\");\n    })();\n  }\n  createBlob(file) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const response = _this7.manager.createBlob(Uint8ArrayToString(new Uint8Array(file), \"base64\"), \"base64\");\n      return response.then(r => ({\n        id: r.sha,\n        url: r.url\n      }));\n    })();\n  }\n  readBlob(blobId) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const iso = IsoBuffer.from(yield _this8.read(blobId), \"base64\");\n      // In a Node environment, IsoBuffer may be a Node.js Buffer.  Node.js will\n      // pool multiple small Buffer instances into a single ArrayBuffer, in which\n      // case we need to slice the appropriate span of bytes.\n      return iso.byteLength === iso.buffer.byteLength ? iso.buffer : iso.buffer.slice(iso.byteOffset, iso.byteOffset + iso.byteLength);\n    })();\n  }\n  writeSummaryTree(summaryTree, /** Entire previous snapshot, not subtree */\n  previousFullSnapshot) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const entries = yield Promise.all(Object.keys(summaryTree.tree).map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (key) {\n          const entry = summaryTree.tree[key];\n          const pathHandle = yield _this9.writeSummaryTreeObject(key, entry, previousFullSnapshot);\n          const treeEntry = {\n            mode: _this9.getGitMode(entry),\n            path: encodeURIComponent(key),\n            sha: pathHandle,\n            type: _this9.getGitType(entry)\n          };\n          return treeEntry;\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }()));\n      const treeHandle = yield _this9.manager.createGitTree({\n        tree: entries\n      });\n      return treeHandle.sha;\n    })();\n  }\n  writeSummaryTreeObject(key, object, previousFullSnapshot, currentPath = \"\") {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      switch (object.type) {\n        case 2 /* Blob */:\n          {\n            return _this10.writeSummaryBlob(object.content);\n          }\n        case 3 /* Handle */:\n          {\n            if (previousFullSnapshot === undefined) {\n              throw Error(\"Parent summary does not exist to reference by handle.\");\n            }\n            return _this10.getIdFromPath(object.handleType, object.handle, previousFullSnapshot);\n          }\n        case 1 /* Tree */:\n          {\n            return _this10.writeSummaryTree(object, previousFullSnapshot);\n          }\n        case 4 /* Attachment */:\n          {\n            return object.id;\n          }\n        default:\n          throw Error(`Unexpected summary object type: \"${object.type}\".`);\n      }\n    })();\n  }\n  getIdFromPath(handleType, handlePath, previousFullSnapshot) {\n    const path = handlePath.split(\"/\").map(part => decodeURIComponent(part));\n    if (path[0] === \"\") {\n      // root of tree should be unnamed\n      path.shift();\n    }\n    if (path.length === 0) {\n      const tryId = previousFullSnapshot.id;\n      assert(!!tryId, \"Parent summary does not have handle for specified path.\");\n      return tryId;\n    }\n    return this.getIdFromPathCore(handleType, path, previousFullSnapshot);\n  }\n  getIdFromPathCore(handleType, path, /** Previous snapshot, subtree relative to this path part */\n  previousSnapshot) {\n    var _a;\n    assert(path.length > 0, \"Expected at least 1 path part\");\n    const key = path[0];\n    if (path.length === 1) {\n      switch (handleType) {\n        case 2 /* Blob */:\n          {\n            const tryId = previousSnapshot.blobs[key];\n            assert(!!tryId, \"Parent summary does not have blob handle for specified path.\");\n            return tryId;\n          }\n        case 1 /* Tree */:\n          {\n            const tryId = (_a = previousSnapshot.trees[key]) === null || _a === void 0 ? void 0 : _a.id;\n            assert(!!tryId, \"Parent summary does not have tree handle for specified path.\");\n            return tryId;\n          }\n        default:\n          throw Error(`Unexpected handle summary object type: \"${handleType}\".`);\n      }\n    }\n    return this.getIdFromPathCore(handleType, path.slice(1), previousSnapshot.trees[key]);\n  }\n  writeSummaryBlob(content) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        parsedContent,\n        encoding\n      } = typeof content === \"string\" ? {\n        parsedContent: content,\n        encoding: \"utf-8\"\n      } : {\n        parsedContent: Uint8ArrayToString(content, \"base64\"),\n        encoding: \"base64\"\n      };\n      // The gitHashFile would return the same hash as returned by the server as blob.sha\n      const hash = yield gitHashFile(IsoBuffer.from(parsedContent, encoding));\n      if (!_this11.blobsShaCache.has(hash)) {\n        _this11.blobsShaCache.set(hash, \"\");\n        const blob = yield _this11.manager.createBlob(parsedContent, encoding);\n        assert(hash === blob.sha, \"Blob.sha and hash do not match!!\");\n      }\n      return hash;\n    })();\n  }\n  getGitMode(value) {\n    const type = value.type === 3 /* Handle */ ? value.handleType : value.type;\n    switch (type) {\n      case 2 /* Blob */:\n      case 4 /* Attachment */:\n        return FileMode.File;\n      case 0 /* Commit */:\n        return FileMode.Commit;\n      case 1 /* Tree */:\n        return FileMode.Directory;\n      default:\n        throw new Error();\n    }\n  }\n  getGitType(value) {\n    const type = value.type === 3 /* Handle */ ? value.handleType : value.type;\n    switch (type) {\n      case 2 /* Blob */:\n      case 4 /* Attachment */:\n        return \"blob\";\n      case 0 /* Commit */:\n        return \"commit\";\n      case 1 /* Tree */:\n        return \"tree\";\n      default:\n        throw new Error();\n    }\n  }\n}\n//# sourceMappingURL=documentStorageService.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}