{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { SortedSegmentSet } from \"@fluidframework/merge-tree\";\n/**\n * Base class for SequenceDeltaEvent and SequenceMaintenanceEvent.\n *\n * The properties of this object and its sub-objects represent a point in time state\n * at the time the operation was applied. They will not take into any future modifications\n * performed to the underlying sequence and merge tree.\n */\nexport class SequenceEvent {\n  constructor(deltaArgs, mergeTreeClient) {\n    this.deltaArgs = deltaArgs;\n    this.mergeTreeClient = mergeTreeClient;\n    this.isEmpty = deltaArgs.deltaSegments.length === 0;\n    this.deltaOperation = deltaArgs.operation;\n    this.sortedRanges = new Lazy(() => {\n      const set = new SortedSegmentSet();\n      this.deltaArgs.deltaSegments.forEach(delta => {\n        const newRange = {\n          operation: this.deltaArgs.operation,\n          position: this.mergeTreeClient.getPosition(delta.segment),\n          propertyDeltas: delta.propertyDeltas,\n          segment: delta.segment\n        };\n        set.addOrUpdate(newRange);\n      });\n      return set;\n    });\n    this.pFirst = new Lazy(() => {\n      if (this.isEmpty) {\n        return undefined;\n      }\n      return this.sortedRanges.value.items[0];\n    });\n    this.pLast = new Lazy(() => {\n      if (this.isEmpty) {\n        return undefined;\n      }\n      return this.sortedRanges.value.items[this.sortedRanges.value.size - 1];\n    });\n  }\n  /**\n   * The in-order ranges affected by this delta.\n   * These may not be continous.\n   */\n  get ranges() {\n    return this.sortedRanges.value.items;\n  }\n  /**\n   * The client id of the client that made the change which caused the delta event\n   */\n  get clientId() {\n    return this.mergeTreeClient.longClientId;\n  }\n  get first() {\n    return this.pFirst.value;\n  }\n  get last() {\n    return this.pLast.value;\n  }\n}\n/**\n * The event object returned on sequenceDelta events.\n *\n * The properties of this object and its sub-objects represent a point in time state\n * at the time the operation was applied. They will not take into any future modifications\n * performed to the underlying sequence and merge tree.\n *\n * For group ops, each op will get it's own event, and the group op property will be set on the op args.\n *\n * Ops may get multiple events. For instance, an insert-replace will get a remove then an insert event.\n */\nexport class SequenceDeltaEvent extends SequenceEvent {\n  constructor(opArgs, deltaArgs, mergeTreeClient) {\n    super(deltaArgs, mergeTreeClient);\n    this.opArgs = opArgs;\n    this.isLocal = opArgs.sequencedMessage === undefined;\n  }\n}\n/**\n * The event object returned on maintenance events.\n *\n * The properties of this object and its sub-objects represent a point in time state\n * at the time the operation was applied. They will not take into any future modifications\n * performed to the underlying sequence and merge tree.\n */\nexport class SequenceMaintenanceEvent extends SequenceEvent {\n  constructor(deltaArgs, mergeTreeClient) {\n    super(deltaArgs, mergeTreeClient);\n  }\n}\nclass Lazy {\n  constructor(valueGenerator) {\n    this.valueGenerator = valueGenerator;\n    this.pEvaluated = false;\n  }\n  get evaluated() {\n    return this.pEvaluated;\n  }\n  get value() {\n    if (!this.pEvaluated) {\n      this.pEvaluated = true;\n      this.pValue = this.valueGenerator();\n    }\n    return this.pValue;\n  }\n}\n//# sourceMappingURL=sequenceDeltaEvent.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}