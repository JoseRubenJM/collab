{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport * as MergeTree from \"./mergeTree\";\nimport * as ops from \"./ops\";\nimport { TextSegment } from \"./textSegment\";\nexport function loadSegments(content, segLimit, markers = false, withProps = true) {\n  // eslint-disable-next-line no-param-reassign\n  content = content.replace(/^\\uFEFF/, \"\");\n  const paragraphs = content.split(/\\r?\\n/);\n  for (let i = 0, len = paragraphs.length; i < len; i++) {\n    paragraphs[i] = paragraphs[i].replace(/\\r?\\n/g, \" \").replace(/\\u201c|\\u201d/g, '\"').replace(/\\u2019/g, \"'\");\n    if (!markers && i !== paragraphs.length - 1) {\n      paragraphs[i] += \"\\n\";\n    }\n  }\n  const segments = [];\n  for (const paragraph of paragraphs) {\n    let pgMarker;\n    if (markers) {\n      pgMarker = MergeTree.Marker.make(ops.ReferenceType.Tile, {\n        [MergeTree.reservedTileLabelsKey]: [\"pg\"]\n      });\n    }\n    if (withProps) {\n      if (paragraph.includes(\"Chapter\") || paragraph.includes(\"PRIDE AND PREJ\")) {\n        if (markers) {\n          pgMarker.addProperties({\n            header: 2\n          });\n          segments.push(new TextSegment(paragraph));\n        } else {\n          segments.push(TextSegment.make(paragraph, {\n            fontSize: \"140%\",\n            lineHeight: \"150%\"\n          }));\n        }\n      } else {\n        const emphStrings = paragraph.split(\"_\");\n        for (let i = 0, len = emphStrings.length; i < len; i++) {\n          // eslint-disable-next-line no-bitwise\n          if (i & 1) {\n            if (emphStrings[i].length > 0) {\n              segments.push(TextSegment.make(emphStrings[i], {\n                fontStyle: \"italic\"\n              }));\n            }\n          } else {\n            if (emphStrings[i].length > 0) {\n              segments.push(new TextSegment(emphStrings[i]));\n            }\n          }\n        }\n      }\n    } else {\n      segments.push(new TextSegment(paragraph));\n    }\n    if (markers) {\n      segments.push(pgMarker);\n    }\n  }\n  if (segLimit > 0) {\n    segments.length = segLimit;\n  }\n  return segments;\n}\nexport function loadText(content, mergeTree, segLimit, markers = false) {\n  const segments = loadSegments(content, segLimit, markers);\n  mergeTree.reloadFromSegments(segments);\n  // console.log(`Number of Segments: ${segments.length}`);\n  // console.log(`Height: ${mergeTree.getStats().maxHeight}`);\n  // console.log(segTree.toString());\n  return mergeTree;\n}\n//# sourceMappingURL=text.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}