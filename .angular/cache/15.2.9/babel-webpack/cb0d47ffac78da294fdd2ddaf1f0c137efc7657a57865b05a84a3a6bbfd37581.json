{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { Deferred, fromBase64ToUtf8, assert } from \"@fluidframework/common-utils\";\nimport { ChildLogger } from \"@fluidframework/telemetry-utils\";\nimport { MapKernel } from \"@fluidframework/map\";\nimport * as MergeTree from \"@fluidframework/merge-tree\";\nimport { FileMode, MessageType, TreeEntry } from \"@fluidframework/protocol-definitions\";\nimport { ObjectStoragePartition } from \"@fluidframework/runtime-utils\";\nimport { makeHandlesSerializable, parseHandles, SharedObject } from \"@fluidframework/shared-object-base\";\nimport { debug } from \"./debug\";\nimport { SequenceIntervalCollectionValueType } from \"./intervalCollection\";\nimport { SequenceDeltaEvent, SequenceMaintenanceEvent } from \"./sequenceDeltaEvent\";\nconst snapshotFileName = \"header\";\nconst contentPath = \"content\";\nexport class SharedSegmentSequence extends SharedObject {\n  constructor(dataStoreRuntime, id, attributes, segmentFromSpec) {\n    super(id, dataStoreRuntime, attributes);\n    this.dataStoreRuntime = dataStoreRuntime;\n    this.id = id;\n    this.segmentFromSpec = segmentFromSpec;\n    // Deferred that triggers once the object is loaded\n    this.loadedDeferred = new Deferred();\n    // cache out going ops created when parital loading\n    this.loadedDeferredOutgoingOps = [];\n    // cache incoming ops that arrive when partial loading\n    this.deferIncomingOps = true;\n    this.loadedDeferredIncomingOps = [];\n    this.messagesSinceMSNChange = [];\n    this.loadedDeferred.promise.catch(error => {\n      this.logger.sendErrorEvent({\n        eventName: \"SequenceLoadFailed\"\n      }, error);\n    });\n    this.client = new MergeTree.Client(segmentFromSpec, ChildLogger.create(this.logger, \"SharedSegmentSequence.MergeTreeClient\"), dataStoreRuntime.options);\n    super.on(\"newListener\", event => {\n      switch (event) {\n        case \"sequenceDelta\":\n          if (!this.client.mergeTreeDeltaCallback) {\n            this.client.mergeTreeDeltaCallback = (opArgs, deltaArgs) => {\n              this.emit(\"sequenceDelta\", new SequenceDeltaEvent(opArgs, deltaArgs, this.client), this);\n            };\n          }\n          break;\n        case \"maintenance\":\n          if (!this.client.mergeTreeMaintenanceCallback) {\n            this.client.mergeTreeMaintenanceCallback = args => {\n              this.emit(\"maintenance\", new SequenceMaintenanceEvent(args, this.client), this);\n            };\n          }\n          break;\n        default:\n      }\n    });\n    super.on(\"removeListener\", event => {\n      switch (event) {\n        case \"sequenceDelta\":\n          if (super.listenerCount(event) === 0) {\n            this.client.mergeTreeDeltaCallback = undefined;\n          }\n          break;\n        case \"maintenance\":\n          if (super.listenerCount(event) === 0) {\n            this.client.mergeTreeMaintenanceCallback = undefined;\n          }\n          break;\n        default:\n          break;\n      }\n    });\n    this.intervalMapKernel = new MapKernel(this.serializer, this.handle, (op, localOpMetadata) => this.submitLocalMessage(op, localOpMetadata), () => this.isAttached(), [new SequenceIntervalCollectionValueType()]);\n  }\n  get loaded() {\n    return this.loadedDeferred.promise;\n  }\n  static createOpsFromDelta(event) {\n    var _a;\n    const ops = [];\n    for (const r of event.ranges) {\n      switch (event.deltaOperation) {\n        case 2 /* ANNOTATE */:\n          {\n            const lastAnnotate = ops[ops.length - 1];\n            const props = {};\n            for (const key of Object.keys(r.propertyDeltas)) {\n              props[key] =\n              // eslint-disable-next-line no-null/no-null\n              r.segment.properties[key] === undefined ? null : r.segment.properties[key];\n            }\n            if (lastAnnotate && lastAnnotate.pos2 === r.position && MergeTree.matchProperties(lastAnnotate.props, props)) {\n              lastAnnotate.pos2 += r.segment.cachedLength;\n            } else {\n              ops.push(MergeTree.createAnnotateRangeOp(r.position, r.position + r.segment.cachedLength, props, undefined));\n            }\n            break;\n          }\n        case 0 /* INSERT */:\n          ops.push(MergeTree.createInsertOp(r.position, r.segment.clone().toJSONObject()));\n          break;\n        case 1 /* REMOVE */:\n          {\n            const lastRem = ops[ops.length - 1];\n            if (((_a = lastRem) === null || _a === void 0 ? void 0 : _a.pos1) === r.position) {\n              lastRem.pos2 += r.segment.cachedLength;\n            } else {\n              ops.push(MergeTree.createRemoveRangeOp(r.position, r.position + r.segment.cachedLength));\n            }\n            break;\n          }\n        default:\n      }\n    }\n    return ops;\n  }\n  /**\n   * @param start - The inclusive start of the range to remove\n   * @param end - The exclusive end of the range to remove\n   */\n  removeRange(start, end) {\n    const removeOp = this.client.removeRangeLocal(start, end);\n    if (removeOp) {\n      this.submitSequenceMessage(removeOp);\n    }\n    return removeOp;\n  }\n  /**\n   * Removes the range and puts the content of the removed range in a register\n   *\n   * @param start - The inclusive start of the range to remove\n   * @param end - The exclusive end of the range to remove\n   * @param register - The name of the register to store the removed range in\n   */\n  cut(start, end, register) {\n    const removeOp = this.client.removeRangeLocal(start, end, register);\n    if (removeOp) {\n      this.submitSequenceMessage(removeOp);\n    }\n  }\n  /**\n   * Inserts the content of the register.\n   *\n   * @param pos - The postition to insert the content at.\n   * @param register - The name of the register to get the content from\n   */\n  paste(pos, register) {\n    const insertOp = this.client.pasteLocal(pos, register);\n    if (insertOp) {\n      this.submitSequenceMessage(insertOp);\n    }\n    return pos;\n  }\n  /**\n   * Puts the content of the range in a register\n   *\n   * @param start - The inclusive start of the range\n   * @param end - The exclusive end of the range\n   * @param register - The name of the register to store the range in\n   */\n  copy(start, end, register) {\n    const insertOp = this.client.copyLocal(start, end, register);\n    if (insertOp) {\n      this.submitSequenceMessage(insertOp);\n    }\n  }\n  groupOperation(groupOp) {\n    this.client.localTransaction(groupOp);\n    this.submitSequenceMessage(groupOp);\n  }\n  getContainingSegment(pos) {\n    return this.client.getContainingSegment(pos);\n  }\n  /**\n   * Returns the length of the current sequence for the client\n   */\n  getLength() {\n    return this.client.getLength();\n  }\n  /**\n   * Returns the current position of a segment, and -1 if the segment\n   * does not exist in this sequence\n   * @param segment - The segment to get the position of\n   */\n  getPosition(segment) {\n    return this.client.getPosition(segment);\n  }\n  /**\n   * Annotates the range with the provided properties\n   *\n   * @param start - The inclusive start postition of the range to annotate\n   * @param end - The exclusive end position of the range to annotate\n   * @param props - The properties to annotate the range with\n   * @param combiningOp - Optional. Specifies how to combine values for the property, such as \"incr\" for increment.\n   *\n   */\n  annotateRange(start, end, props, combiningOp) {\n    const annotateOp = this.client.annotateRangeLocal(start, end, props, combiningOp);\n    if (annotateOp) {\n      this.submitSequenceMessage(annotateOp);\n    }\n  }\n  getPropertiesAtPosition(pos) {\n    return this.client.getPropertiesAtPosition(pos);\n  }\n  getRangeExtentsOfPosition(pos) {\n    return this.client.getRangeExtentsOfPosition(pos);\n  }\n  createPositionReference(segment, offset, refType) {\n    const lref = new MergeTree.LocalReference(this.client, segment, offset, refType);\n    if (refType !== MergeTree.ReferenceType.Transient) {\n      this.addLocalReference(lref);\n    }\n    return lref;\n  }\n  localRefToPos(localRef) {\n    if (localRef.segment) {\n      return localRef.offset + this.getPosition(localRef.segment);\n    } else {\n      return -1;\n    }\n  }\n  /**\n   * Resolves a remote client's position against the local sequence\n   * and returns the remote client's position relative to the local\n   * sequence\n   * @param remoteClientPosition - The remote client's position to resolve\n   * @param remoteClientRefSeq - The reference sequence number of the remote client\n   * @param remoteClientId - The client id of the remote client\n   */\n  resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId) {\n    return this.client.resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId);\n  }\n  submitSequenceMessage(message) {\n    if (!this.isAttached()) {\n      return;\n    }\n    const translated = makeHandlesSerializable(message, this.serializer, this.handle);\n    const metadata = this.client.peekPendingSegmentGroups(message.type === 3 /* GROUP */ ? message.ops.length : 1);\n    // if loading isn't complete, we need to cache\n    // local ops until loading is complete, and then\n    // they will be resent\n    if (!this.loadedDeferred.isCompleted) {\n      this.loadedDeferredOutgoingOps.push([translated, metadata]);\n    } else {\n      this.submitLocalMessage(translated, metadata);\n    }\n  }\n  addLocalReference(lref) {\n    return this.client.addLocalReference(lref);\n  }\n  removeLocalReference(lref) {\n    return this.client.removeLocalReference(lref);\n  }\n  /**\n   * Given a position specified relative to a marker id, lookup the marker\n   * and convert the position to a character position.\n   * @param relativePos - Id of marker (may be indirect) and whether position is before or after marker.\n   */\n  posFromRelativePos(relativePos) {\n    return this.client.posFromRelativePos(relativePos);\n  }\n  /**\n   * Walk the underlying segments of the sequence.\n   * The walked segments may extend beyond the range\n   * if the segments cross the ranges start or end boundaries.\n   * Set split range to true to ensure only segments within the\n   * range are walked.\n   *\n   * @param handler - The function to handle each segment\n   * @param start - Optional. The start of range walk.\n   * @param end - Optional. The end of range walk\n   * @param accum - Optional. An object that will be passed to the handler for accumulation\n   * @param splitRange - Optional. Splits boundary segments on the range boundaries\n   */\n  walkSegments(handler, start, end, accum, splitRange = false) {\n    return this.client.walkSegments(handler, start, end, accum, splitRange);\n  }\n  getStackContext(startPos, rangeLabels) {\n    return this.client.getStackContext(startPos, rangeLabels);\n  }\n  getCurrentSeq() {\n    return this.client.getCurrentSeq();\n  }\n  insertAtReferencePosition(pos, segment) {\n    const insertOp = this.client.insertAtReferencePositionLocal(pos, segment);\n    if (insertOp) {\n      this.submitSequenceMessage(insertOp);\n    }\n  }\n  waitIntervalCollection(label) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.intervalMapKernel.wait(_this.getIntervalCollectionPath(label));\n    })();\n  }\n  // TODO: fix race condition on creation by putting type on every operation\n  getIntervalCollection(label) {\n    const labelPath = this.getIntervalCollectionPath(label);\n    if (!this.intervalMapKernel.has(labelPath)) {\n      this.intervalMapKernel.createValueType(labelPath, SequenceIntervalCollectionValueType.Name, undefined);\n    }\n    const sharedCollection = this.intervalMapKernel.get(labelPath);\n    return sharedCollection;\n  }\n  snapshotCore(serializer) {\n    const tree = {\n      entries: [{\n        mode: FileMode.File,\n        path: snapshotFileName,\n        type: TreeEntry.Blob,\n        value: {\n          contents: this.intervalMapKernel.serialize(serializer),\n          encoding: \"utf-8\"\n        }\n      }, {\n        mode: FileMode.Directory,\n        path: contentPath,\n        type: TreeEntry.Tree,\n        value: this.snapshotMergeTree(serializer)\n      }],\n      // eslint-disable-next-line no-null/no-null\n      id: null\n    };\n    return tree;\n  }\n  /**\n   * Replace the range specified from start to end with the provided segment\n   * This is done by inserting the segment at the end of the range, followed\n   * by removing the contents of the range\n   * For a zero range (start == end), insert at end do not remove anything\n   * For a reverse range (start \\> end), insert the segment at the greater of\n   * start/end and allow Client to attempt to remove the range\n   *\n   * @param start - The start of the range to replace\n   * @param end - The end of the range to replace\n   * @param segment - The segment that will replace the range\n   */\n  replaceRange(start, end, segment) {\n    // Insert at the max end of the range when start > end, but still remove the range later\n    const insertIndex = Math.max(start, end);\n    // Insert first, so local references can slide to the inserted seg if any\n    const insert = this.client.insertSegmentLocal(insertIndex, segment);\n    if (insert) {\n      if (start !== end) {\n        const remove = this.client.removeRangeLocal(start, end);\n        this.submitSequenceMessage(MergeTree.createGroupOp(insert, remove));\n      } else {\n        this.submitSequenceMessage(insert);\n      }\n    }\n  }\n  onConnect() {\n    // Update merge tree collaboration information with new client ID and then resend pending ops\n    this.client.startOrUpdateCollaboration(this.runtime.clientId);\n  }\n  onDisconnect() {\n    debug(`${this.id} is now disconnected`);\n  }\n  reSubmitCore(content, localOpMetadata) {\n    if (!this.intervalMapKernel.trySubmitMessage(content, localOpMetadata)) {\n      this.submitSequenceMessage(this.client.regeneratePendingOp(content, localOpMetadata));\n    }\n  }\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}\n   */\n  loadCore(storage) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      const header = yield storage.read(snapshotFileName);\n      const data = header ? fromBase64ToUtf8(header) : undefined;\n      _this2.intervalMapKernel.populate(data);\n      try {\n        // this will load the header, and return a promise\n        // that will resolve when the body is loaded\n        // and the catchup ops are available.\n        const {\n          catchupOpsP\n        } = yield _this2.client.load(_this2.runtime, new ObjectStoragePartition(storage, contentPath), _this2.serializer);\n        // setup a promise to process the\n        // catch up ops, and finishing the loading process\n        const loadCatchUpOps = catchupOpsP.then(msgs => {\n          msgs.forEach(m => {\n            const collabWindow = _this2.client.getCollabWindow();\n            if (m.minimumSequenceNumber < collabWindow.minSeq || m.referenceSequenceNumber < collabWindow.minSeq || m.sequenceNumber <= collabWindow.minSeq || m.sequenceNumber <= collabWindow.currentSeq) {\n              throw new Error(`Invalid catchup operations in snapshot: ${JSON.stringify({\n                op: {\n                  seq: m.sequenceNumber,\n                  minSeq: m.minimumSequenceNumber,\n                  refSeq: m.referenceSequenceNumber\n                },\n                collabWindow: {\n                  seq: collabWindow.currentSeq,\n                  minSeq: collabWindow.minSeq\n                }\n              })}`);\n            }\n            _this2.processMergeTreeMsg(m);\n          });\n          _this2.loadFinished();\n        }).catch(error => {\n          _this2.loadFinished(error);\n        });\n        if (((_a = _this2.dataStoreRuntime.options) === null || _a === void 0 ? void 0 : _a.sequenceInitializeFromHeaderOnly) !== true) {\n          // if we not doing parital load, await the catch up ops,\n          // and the finalization of the load\n          yield loadCatchUpOps;\n        }\n      } catch (error) {\n        _this2.loadFinished(error);\n      }\n    })();\n  }\n  processCore(message, local, localOpMetadata) {\n    // if loading isn't complete, we need to cache all\n    // incoming ops to be applied after loading is complete\n    if (this.deferIncomingOps) {\n      assert(!local, \"Unexpected local op when loading not finished\");\n      this.loadedDeferredIncomingOps.push(message);\n    } else {\n      assert(message.type === MessageType.Operation, \"Sequence message not operation\");\n      const handled = this.intervalMapKernel.tryProcessMessage(message, local, localOpMetadata);\n      if (!handled) {\n        this.processMergeTreeMsg(message);\n      }\n    }\n  }\n  registerCore() {\n    for (const value of this.intervalMapKernel.values()) {\n      if (SharedObject.is(value)) {\n        value.bindToContext();\n      }\n    }\n    this.client.startOrUpdateCollaboration(this.runtime.clientId);\n  }\n  didAttach() {\n    var _a;\n    // If we are not local, and we've attached we need to start generating and sending ops\n    // so start collaboration and provide a default client id incase we are not connected\n    if (this.isAttached()) {\n      this.client.startOrUpdateCollaboration((_a = this.runtime.clientId, _a !== null && _a !== void 0 ? _a : \"attached\"));\n    }\n  }\n  initializeLocalCore() {\n    super.initializeLocalCore();\n    this.loadFinished();\n  }\n  snapshotMergeTree(serializer) {\n    // Are we fully loaded? If not, things will go south\n    assert(this.loadedDeferred.isCompleted, \"Snapshot called when not fully loaded\");\n    const minSeq = this.runtime.deltaManager.minimumSequenceNumber;\n    this.processMinSequenceNumberChanged(minSeq);\n    this.messagesSinceMSNChange.forEach(m => m.minimumSequenceNumber = minSeq);\n    return this.client.snapshot(this.runtime, this.handle, serializer, this.messagesSinceMSNChange);\n  }\n  processMergeTreeMsg(rawMessage) {\n    var _a, _b;\n    const message = parseHandles(rawMessage, this.serializer);\n    const ops = [];\n    function transfromOps(event) {\n      ops.push(...SharedSegmentSequence.createOpsFromDelta(event));\n    }\n    const needsTransformation = message.referenceSequenceNumber !== message.sequenceNumber - 1;\n    let stashMessage = message;\n    if (((_a = this.runtime.options) === null || _a === void 0 ? void 0 : _a.newMergeTreeSnapshotFormat) !== true) {\n      if (needsTransformation) {\n        this.on(\"sequenceDelta\", transfromOps);\n      }\n    }\n    this.client.applyMsg(message);\n    if (((_b = this.runtime.options) === null || _b === void 0 ? void 0 : _b.newMergeTreeSnapshotFormat) !== true) {\n      if (needsTransformation) {\n        this.removeListener(\"sequenceDelta\", transfromOps);\n        // shallow clone the message as we only overwrite top level properties,\n        // like referenceSequenceNumber and content only\n        stashMessage = Object.assign(Object.assign({}, message), {\n          referenceSequenceNumber: stashMessage.sequenceNumber - 1,\n          contents: ops.length !== 1 ? MergeTree.createGroupOp(...ops) : ops[0]\n        });\n      }\n      this.messagesSinceMSNChange.push(stashMessage);\n      // Do GC every once in a while...\n      if (this.messagesSinceMSNChange.length > 20 && this.messagesSinceMSNChange[20].sequenceNumber < message.minimumSequenceNumber) {\n        this.processMinSequenceNumberChanged(message.minimumSequenceNumber);\n      }\n    }\n  }\n  getIntervalCollectionPath(label) {\n    return `intervalCollections/${label}`;\n  }\n  processMinSequenceNumberChanged(minSeq) {\n    let index = 0;\n    for (; index < this.messagesSinceMSNChange.length; index++) {\n      if (this.messagesSinceMSNChange[index].sequenceNumber > minSeq) {\n        break;\n      }\n    }\n    if (index !== 0) {\n      this.messagesSinceMSNChange = this.messagesSinceMSNChange.slice(index);\n    }\n  }\n  loadFinished(error) {\n    if (!this.loadedDeferred.isCompleted) {\n      // Initialize the interval collections\n      this.initializeIntervalCollections();\n      if (error) {\n        this.loadedDeferred.reject(error);\n        throw error;\n      } else {\n        // it is important this series remains synchronous\n        // first we stop defering incoming ops, and apply then all\n        this.deferIncomingOps = false;\n        while (this.loadedDeferredIncomingOps.length > 0) {\n          this.processCore(this.loadedDeferredIncomingOps.shift(), false, undefined);\n        }\n        // then resolve the loaded promise\n        // and resubmit all the outstanding ops, as the snapshot\n        // is fully loaded, and all outstanding ops are applied\n        this.loadedDeferred.resolve();\n        while (this.loadedDeferredOutgoingOps.length > 0) {\n          const opData = this.loadedDeferredOutgoingOps.shift();\n          this.reSubmitCore(opData[0], opData[1]);\n        }\n      }\n    }\n  }\n  initializeIntervalCollections() {\n    // Listen and initialize new SharedIntervalCollections\n    this.intervalMapKernel.eventEmitter.on(\"valueChanged\", ev => {\n      const intervalCollection = this.intervalMapKernel.get(ev.key);\n      if (!intervalCollection.attached) {\n        intervalCollection.attachGraph(this.client, ev.key);\n      }\n    });\n    // Initialize existing SharedIntervalCollections\n    for (const key of this.intervalMapKernel.keys()) {\n      const intervalCollection = this.intervalMapKernel.get(key);\n      intervalCollection.attachGraph(this.client, key);\n    }\n  }\n}\n//# sourceMappingURL=sequence.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}