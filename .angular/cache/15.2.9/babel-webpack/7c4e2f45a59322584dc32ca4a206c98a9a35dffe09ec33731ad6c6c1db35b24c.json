{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A comparer for numbers.\n */\nexport const NumberComparer = {\n  /**\n   * The compare function for numbers.\n   * @returns The difference of the two numbers.\n   */\n  compare: (a, b) => a - b,\n  /**\n   * The minimum value of a JavaScript number, which is `Number.MIN_VALUE`.\n   */\n  min: Number.MIN_VALUE\n};\n/**\n * Ordered {@link https://en.wikipedia.org/wiki/Heap_(data_structure) | Heap} data structure implementation.\n */\nexport class Heap {\n  /**\n   * Creates an instance of `Heap` with comparer.\n   * @param comp - A comparer that specify how elements are ordered.\n   */\n  constructor(comp) {\n    this.comp = comp;\n    this.L = [{\n      value: comp.min,\n      position: 0\n    }];\n  }\n  /**\n   * Return the smallest element in the heap as determined by the order of the comparer\n   *\n   * @returns Heap node containing the smallest element\n   */\n  peek() {\n    return this.L[1];\n  }\n  /**\n   * Get and remove the smallest element in the heap as determined by the order of the comparer\n   *\n   * @returns The smallest value in the heap\n   */\n  get() {\n    this.swap(1, this.count());\n    const x = this.L.pop();\n    this.fixdown(1);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return x.value;\n  }\n  /**\n   * Add a value to the heap\n   *\n   * @param x - value to add\n   * @returns The heap node that contains the value\n   */\n  add(x) {\n    const node = {\n      value: x,\n      position: this.L.length\n    };\n    this.L.push(node);\n    this.fixup(this.count());\n    return node;\n  }\n  /**\n   * Allows for the Heap to be updated after a node's value changes.\n   */\n  update(node) {\n    const k = node.position;\n    if (this.isGreaterThanParent(k)) {\n      this.fixup(k);\n    } else {\n      this.fixdown(k);\n    }\n  }\n  /**\n   * Removes the given node from the heap.\n   *\n   * @param node - The node to remove from the heap.\n   */\n  remove(node) {\n    // Move the node we want to remove to the end of the array\n    const position = node.position;\n    this.swap(node.position, this.L.length - 1);\n    this.L.splice(this.L.length - 1);\n    // Update the swapped node assuming we didn't remove the end of the list\n    if (position !== this.L.length) {\n      this.update(this.L[position]);\n    }\n  }\n  /**\n   * Get the number of elements in the Heap.\n   *\n   * @returns The number of elements in the Heap.\n   */\n  count() {\n    return this.L.length - 1;\n  }\n  fixup(pos) {\n    let k = pos;\n    while (this.isGreaterThanParent(k)) {\n      // eslint-disable-next-line no-bitwise\n      const parent = k >> 1;\n      this.swap(k, parent);\n      k = parent;\n    }\n  }\n  isGreaterThanParent(k) {\n    // eslint-disable-next-line no-bitwise\n    return k > 1 && this.comp.compare(this.L[k >> 1].value, this.L[k].value) > 0;\n  }\n  fixdown(pos) {\n    let k = pos;\n    // eslint-disable-next-line no-bitwise\n    while (k << 1 <= this.count()) {\n      // eslint-disable-next-line no-bitwise\n      let j = k << 1;\n      if (j < this.count() && this.comp.compare(this.L[j].value, this.L[j + 1].value) > 0) {\n        j++;\n      }\n      if (this.comp.compare(this.L[k].value, this.L[j].value) <= 0) {\n        break;\n      }\n      this.swap(k, j);\n      k = j;\n    }\n  }\n  swap(k, j) {\n    const tmp = this.L[k];\n    this.L[k] = this.L[j];\n    this.L[k].position = k;\n    this.L[j] = tmp;\n    this.L[j].position = j;\n  }\n}\n//# sourceMappingURL=heap.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}