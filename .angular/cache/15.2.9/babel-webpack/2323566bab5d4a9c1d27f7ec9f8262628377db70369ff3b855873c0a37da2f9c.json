{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, fromBase64ToUtf8, unreachableCase } from \"@fluidframework/common-utils\";\nimport { FileMode, MessageType, TreeEntry } from \"@fluidframework/protocol-definitions\";\nimport { SharedObject } from \"@fluidframework/shared-object-base\";\nimport { ConsensusRegisterCollectionFactory } from \"./consensusRegisterCollectionFactory\";\nimport { debug } from \"./debug\";\nimport { ReadPolicy } from \"./interfaces\";\nconst newLocalRegister = (sequenceNumber, value) => ({\n  sequenceNumber,\n  value: {\n    type: \"Plain\",\n    value\n  }\n});\n/** Distinguish between incoming op formats so we know which type it is */\nconst incomingOpMatchesCurrentFormat = op => \"serializedValue\" in op;\nconst snapshotFileName = \"header\";\n/**\n * Implementation of a consensus register collection\n */\nexport class ConsensusRegisterCollection extends SharedObject {\n  /**\n   * Constructs a new consensus register collection. If the object is non-local an id and service interfaces will\n   * be provided\n   */\n  constructor(id, runtime, attributes) {\n    super(id, runtime, attributes);\n    this.data = new Map();\n  }\n  /**\n   * Create a new consensus register collection\n   *\n   * @param runtime - data store runtime the new consensus register collection belongs to\n   * @param id - optional name of the consensus register collection\n   * @returns newly create consensus register collection (but not attached yet)\n   */\n  static create(runtime, id) {\n    return runtime.createChannel(id, ConsensusRegisterCollectionFactory.Type);\n  }\n  /**\n   * Get a factory for ConsensusRegisterCollection to register with the data store.\n   *\n   * @returns a factory that creates and load ConsensusRegisterCollection\n   */\n  static getFactory() {\n    return new ConsensusRegisterCollectionFactory();\n  }\n  /**\n   * Creates a new register or writes a new value.\n   * Returns a promise that will resolve when the write is acked.\n   *\n   * @returns Promise<true> if write was non-concurrent\n   */\n  write(key, value) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const serializedValue = _this.stringify(value, _this.serializer);\n      if (!_this.isAttached()) {\n        // JSON-roundtrip value for local writes to match the behavior of going through the wire\n        _this.processInboundWrite(key, _this.parse(serializedValue, _this.serializer), 0, 0, true);\n        return true;\n      }\n      const message = {\n        key,\n        type: \"write\",\n        serializedValue,\n        refSeq: _this.runtime.deltaManager.lastSequenceNumber\n      };\n      return _this.newAckBasedPromise(resolve => {\n        // Send the resolve function as the localOpMetadata. This will be provided back to us when the\n        // op is ack'd.\n        _this.submitLocalMessage(message, resolve);\n        // If we fail due to runtime being disposed, it's better to return false then unhandled exception.\n      }).catch(error => false);\n    })();\n  }\n  /**\n   * Returns the most recent local value of a register.\n   * @param key - The key to read\n   * @param readPolicy - The ReadPolicy to apply. Defaults to Atomic.\n   */\n  read(key, readPolicy = ReadPolicy.Atomic) {\n    if (readPolicy === ReadPolicy.Atomic) {\n      return this.readAtomic(key);\n    }\n    const versions = this.readVersions(key);\n    if (versions !== undefined) {\n      // We don't support deletion. So there should be at least one value.\n      assert(versions.length > 0, \"Value should be undefined or non-empty\");\n      return versions[versions.length - 1];\n    }\n  }\n  readVersions(key) {\n    var _a;\n    const data = this.data.get(key);\n    return (_a = data) === null || _a === void 0 ? void 0 : _a.versions.map(element => element.value.value);\n  }\n  keys() {\n    return [...this.data.keys()];\n  }\n  snapshotCore(serializer) {\n    const dataObj = {};\n    this.data.forEach((v, k) => {\n      dataObj[k] = v;\n    });\n    const tree = {\n      entries: [{\n        mode: FileMode.File,\n        path: snapshotFileName,\n        type: TreeEntry.Blob,\n        value: {\n          contents: this.stringify(dataObj, serializer),\n          encoding: \"utf-8\"\n        }\n      }]\n    };\n    return tree;\n  }\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}\n   */\n  loadCore(storage) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      const header = yield storage.read(snapshotFileName);\n      const dataObj = header !== undefined ? _this2.parse(fromBase64ToUtf8(header), _this2.serializer) : {};\n      for (const key of Object.keys(dataObj)) {\n        assert(((_a = dataObj[key].atomic) === null || _a === void 0 ? void 0 : _a.value.type) !== \"Shared\", \"SharedObjects contained in ConsensusRegisterCollection can no longer be deserialized as of 0.17\");\n        _this2.data.set(key, dataObj[key]);\n      }\n    })();\n  }\n  registerCore() {}\n  onDisconnect() {\n    debug(`ConsensusRegisterCollection ${this.id} is now disconnected`);\n  }\n  processCore(message, local, localOpMetadata) {\n    if (message.type === MessageType.Operation) {\n      const op = message.contents;\n      switch (op.type) {\n        case \"write\":\n          {\n            // back-compat 0.13 refSeq\n            // when the refSeq property didn't exist\n            if (op.refSeq === undefined) {\n              op.refSeq = message.referenceSequenceNumber;\n            }\n            // Message can be delivered with delay - e.g. resubmitted on reconnect.\n            // Use the refSeq from when the op was created, not when it was transmitted\n            const refSeqWhenCreated = op.refSeq;\n            assert(refSeqWhenCreated <= message.referenceSequenceNumber);\n            const value = incomingOpMatchesCurrentFormat(op) ? this.parse(op.serializedValue, this.serializer) : op.value.value;\n            const winner = this.processInboundWrite(op.key, value, refSeqWhenCreated, message.sequenceNumber, local);\n            if (local) {\n              // Resolve the pending promise for this operation now that we have received an ack for it.\n              const resolve = localOpMetadata;\n              resolve(winner);\n            }\n            break;\n          }\n        default:\n          unreachableCase(op.type);\n      }\n    }\n  }\n  readAtomic(key) {\n    var _a;\n    const data = this.data.get(key);\n    return (_a = data) === null || _a === void 0 ? void 0 : _a.atomic.value.value;\n  }\n  /**\n   * Process an inbound write op\n   * @param key - Key that was written to\n   * @param value - Incoming value\n   * @param refSeq - RefSeq at the time of write on the remote client\n   * @param sequenceNumber - Sequence Number of this write op\n   * @param local - Did this write originate on this client\n   */\n  processInboundWrite(key, value, refSeq, sequenceNumber, local) {\n    let data = this.data.get(key);\n    // Atomic update if it's a new register or the write was not concurrent,\n    // meaning our state was known to the remote client at the time of write\n    const winner = data === undefined || refSeq >= data.atomic.sequenceNumber;\n    if (winner) {\n      const atomicUpdate = newLocalRegister(sequenceNumber, value);\n      if (data === undefined) {\n        data = {\n          atomic: atomicUpdate,\n          versions: []\n        };\n        this.data.set(key, data);\n      } else {\n        data.atomic = atomicUpdate;\n      }\n    } else {\n      assert(!!data);\n    }\n    // Remove versions that were known to the remote client at the time of write\n    while (data.versions.length > 0 && refSeq >= data.versions[0].sequenceNumber) {\n      data.versions.shift();\n    }\n    const versionUpdate = newLocalRegister(sequenceNumber, value);\n    // Asserts for data integrity\n    if (!this.isAttached()) {\n      assert(refSeq === 0 && sequenceNumber === 0, \"sequence numbersare expected to be 0 when unattached\");\n    } else if (data.versions.length > 0) {\n      assert(sequenceNumber > data.versions[data.versions.length - 1].sequenceNumber, \"Versions should naturally be ordered by sequenceNumber\");\n    }\n    // Push the new element.\n    data.versions.push(versionUpdate);\n    // Raise events at the end, to avoid reentrancy issues\n    if (winner) {\n      this.emit(\"atomicChanged\", key, value, local);\n    }\n    this.emit(\"versionChanged\", key, value, local);\n    return winner;\n  }\n  stringify(value, serializer) {\n    return serializer.stringify(value, this.handle);\n  }\n  parse(content, serializer) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return serializer.parse(content);\n  }\n}\n//# sourceMappingURL=consensusRegisterCollection.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}