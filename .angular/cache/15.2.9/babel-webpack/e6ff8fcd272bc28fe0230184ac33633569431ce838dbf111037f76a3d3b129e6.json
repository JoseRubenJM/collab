{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { AttachState } from \"@fluidframework/container-definitions\";\nimport { Loader } from \"@fluidframework/container-loader\";\nimport { ensureFluidResolvedUrl } from \"@fluidframework/driver-utils\";\nimport { DOProviderContainerRuntimeFactory, FluidContainer } from \"@fluidframework/fluid-static\";\nimport { SummaryType } from \"@fluidframework/protocol-definitions\";\nimport { RouterliciousDocumentServiceFactory } from \"@fluidframework/routerlicious-driver\";\nimport { requestFluidObject } from \"@fluidframework/runtime-utils\";\nimport { AzureAudience } from \"./AzureAudience\";\nimport { AzureUrlResolver, createAzureCreateNewRequest } from \"./AzureUrlResolver\";\nimport { isAzureRemoteConnectionConfig } from \"./utils\";\n/**\n * Strongly typed id for connecting to a local Azure Fluid Relay.\n */\nconst LOCAL_MODE_TENANT_ID = \"local\";\nconst getTenantId = connectionProps => {\n  return isAzureRemoteConnectionConfig(connectionProps) ? connectionProps.tenantId : LOCAL_MODE_TENANT_ID;\n};\nconst MAX_VERSION_COUNT = 5;\n/**\n * AzureClient provides the ability to have a Fluid object backed by the Azure Fluid Relay or,\n * when running with local tenantId, have it be backed by a local Azure Fluid Relay instance.\n */\nexport class AzureClient {\n  /**\n   * Creates a new client instance using configuration parameters.\n   * @param props - Properties for initializing a new AzureClient instance\n   */\n  constructor(props) {\n    this.props = props;\n    // remove trailing slash from URL if any\n    props.connection.endpoint = props.connection.endpoint.replace(/\\/$/, \"\");\n    this.urlResolver = new AzureUrlResolver();\n    // The local service implementation differs from the Azure Fluid Relay in blob\n    // storage format. Azure Fluid Relay supports whole summary upload. Local currently does not.\n    const isRemoteConnection = isAzureRemoteConnectionConfig(this.props.connection);\n    this.documentServiceFactory = new RouterliciousDocumentServiceFactory(this.props.connection.tokenProvider, {\n      enableWholeSummaryUpload: isRemoteConnection,\n      enableDiscovery: isRemoteConnection\n    });\n  }\n  /**\n   * Creates a new detached container instance in the Azure Fluid Relay.\n   * @param containerSchema - Container schema for the new container.\n   * @returns New detached container instance along with associated services.\n   */\n  createContainer(containerSchema) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const loader = _this.createLoader(containerSchema);\n      const container = yield loader.createDetachedContainer({\n        package: \"no-dynamic-package\",\n        config: {}\n      });\n      const fluidContainer = yield _this.createFluidContainer(container, _this.props.connection);\n      const services = _this.getContainerServices(container);\n      return {\n        container: fluidContainer,\n        services\n      };\n    })();\n  }\n  /**\n   * Creates new detached container out of specific version of another container.\n   * @param id - Unique ID of the source container in Azure Fluid Relay.\n   * @param containerSchema - Container schema used to access data objects in the container.\n   * @param version - Unique version of the source container in Azure Fluid Relay.\n   * It defaults to latest version if parameter not provided.\n   * @returns New detached container instance along with associated services.\n   */\n  copyContainer(id, containerSchema, version) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      const loader = _this2.createLoader(containerSchema);\n      const url = new URL(_this2.props.connection.endpoint);\n      url.searchParams.append(\"storage\", encodeURIComponent(_this2.props.connection.endpoint));\n      url.searchParams.append(\"tenantId\", encodeURIComponent(getTenantId(_this2.props.connection)));\n      url.searchParams.append(\"containerId\", encodeURIComponent(id));\n      const sourceContainer = yield loader.resolve({\n        url: url.href\n      });\n      if (sourceContainer.resolvedUrl === undefined) {\n        throw new Error(\"Source container cannot resolve URL.\");\n      }\n      const documentService = yield _this2.documentServiceFactory.createDocumentService(sourceContainer.resolvedUrl);\n      const storage = yield documentService.connectToStorage();\n      const handle = {\n        type: SummaryType.Handle,\n        handleType: SummaryType.Tree,\n        handle: (_a = version === null || version === void 0 ? void 0 : version.id) !== null && _a !== void 0 ? _a : \"latest\"\n      };\n      const tree = yield storage.downloadSummary(handle);\n      const container = yield loader.rehydrateDetachedContainerFromSnapshot(JSON.stringify(tree));\n      const fluidContainer = yield _this2.createFluidContainer(container, _this2.props.connection);\n      const services = _this2.getContainerServices(container);\n      return {\n        container: fluidContainer,\n        services\n      };\n    })();\n  }\n  /**\n   * Accesses the existing container given its unique ID in the Azure Fluid Relay.\n   * @param id - Unique ID of the container in Azure Fluid Relay.\n   * @param containerSchema - Container schema used to access data objects in the container.\n   * @returns Existing container instance along with associated services.\n   */\n  getContainer(id, containerSchema) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const loader = _this3.createLoader(containerSchema);\n      const url = new URL(_this3.props.connection.endpoint);\n      url.searchParams.append(\"storage\", encodeURIComponent(_this3.props.connection.endpoint));\n      url.searchParams.append(\"tenantId\", encodeURIComponent(getTenantId(_this3.props.connection)));\n      url.searchParams.append(\"containerId\", encodeURIComponent(id));\n      const container = yield loader.resolve({\n        url: url.href\n      });\n      const rootDataObject = yield requestFluidObject(container, \"/\");\n      const fluidContainer = new FluidContainer(container, rootDataObject);\n      const services = _this3.getContainerServices(container);\n      return {\n        container: fluidContainer,\n        services\n      };\n    })();\n  }\n  /**\n   * Get the list of versions for specific container.\n   * @param id - Unique ID of the source container in Azure Fluid Relay.\n   * @param options - \"Get\" options. If options are not provided, API\n   * will assume maxCount of versions to retreive to be 5.\n   * @returns Array of available container versions.\n   */\n  getContainerVersions(id, options) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      const url = new URL(_this4.props.connection.endpoint);\n      url.searchParams.append(\"storage\", encodeURIComponent(_this4.props.connection.endpoint));\n      url.searchParams.append(\"tenantId\", encodeURIComponent(getTenantId(_this4.props.connection)));\n      url.searchParams.append(\"containerId\", encodeURIComponent(id));\n      const resolvedUrl = yield _this4.urlResolver.resolve({\n        url: url.href\n      });\n      if (!resolvedUrl) {\n        throw new Error(\"Unable to resolved URL\");\n      }\n      const documentService = yield _this4.documentServiceFactory.createDocumentService(resolvedUrl);\n      const storage = yield documentService.connectToStorage();\n      // External API uses null\n      // eslint-disable-next-line unicorn/no-null\n      const versions = yield storage.getVersions(null, (_a = options === null || options === void 0 ? void 0 : options.maxCount) !== null && _a !== void 0 ? _a : MAX_VERSION_COUNT);\n      return versions.map(item => {\n        return {\n          id: item.id,\n          date: item.date\n        };\n      });\n    })();\n  }\n  getContainerServices(container) {\n    return {\n      audience: new AzureAudience(container)\n    };\n  }\n  createLoader(containerSchema) {\n    const runtimeFactory = new DOProviderContainerRuntimeFactory(containerSchema);\n    const load = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* () {\n        return {\n          module: {\n            fluidExport: runtimeFactory\n          },\n          details: {\n            package: \"no-dynamic-package\",\n            config: {}\n          }\n        };\n      });\n      return function load() {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    const codeLoader = {\n      load\n    };\n    return new Loader({\n      urlResolver: this.urlResolver,\n      documentServiceFactory: this.documentServiceFactory,\n      codeLoader,\n      logger: this.props.logger\n    });\n  }\n  createFluidContainer(container, connection) {\n    return _asyncToGenerator(function* () {\n      const createNewRequest = createAzureCreateNewRequest(connection.endpoint, getTenantId(connection));\n      const rootDataObject = yield requestFluidObject(container, \"/\");\n      /**\n       * See {@link FluidContainer.attach}\n       */\n      const attach = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* () {\n          if (container.attachState !== AttachState.Detached) {\n            throw new Error(\"Cannot attach container. Container is not in detached state\");\n          }\n          yield container.attach(createNewRequest);\n          const resolved = container.resolvedUrl;\n          ensureFluidResolvedUrl(resolved);\n          return resolved.id;\n        });\n        return function attach() {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      const fluidContainer = new FluidContainer(container, rootDataObject);\n      fluidContainer.attach = attach;\n      return fluidContainer;\n    })();\n  }\n}\n//# sourceMappingURL=AzureClient.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}