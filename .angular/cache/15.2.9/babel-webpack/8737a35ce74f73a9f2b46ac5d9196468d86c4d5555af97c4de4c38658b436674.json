{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { ChildLogger, TelemetryLogger } from \"@fluidframework/telemetry-utils\";\nimport { MessageType } from \"@fluidframework/protocol-definitions\";\nimport { assert, performance } from \"@fluidframework/common-utils\";\n/**\n * We report various latency-related errors when waiting for op roundtrip takes longer than that amout of time.\n */\nexport const latencyThreshold = 5000;\nclass OpPerfTelemetry {\n  constructor(clientId, deltaManager, logger) {\n    this.clientId = clientId;\n    this.deltaManager = deltaManager;\n    this.pongCount = 0;\n    this.msnTrackingTimestamp = 0;\n    this.opProcessingTimes = {};\n    // Performance Data to be reported for ops round trips and processing.\n    this.opPerfData = {};\n    this.firstConnection = true;\n    this.bootTime = performance.now();\n    this.connectionStartTime = 0;\n    this.gap = 0;\n    this.logger = ChildLogger.create(logger, \"OpPerf\");\n    this.deltaManager.on(\"pong\", latency => this.recordPingTime(latency));\n    this.deltaManager.on(\"submitOp\", message => this.beforeOpSubmit(message));\n    this.deltaManager.on(\"op\", message => this.afterProcessingOp(message));\n    this.deltaManager.on(\"connect\", (details, opsBehind) => {\n      this.clientId = details.clientId;\n      if (opsBehind !== undefined) {\n        this.connectionOpSeqNumber = this.deltaManager.lastKnownSeqNumber;\n        this.gap = opsBehind;\n        this.connectionStartTime = performance.now();\n        // We might be already up-today. If so, report it right away.\n        if (this.gap <= 0) {\n          this.reportGettingUpToDate();\n        }\n      }\n    });\n    this.deltaManager.on(\"disconnect\", () => {\n      this.sequenceNumberForMsnTracking = undefined;\n      this.clientSequenceNumberForLatencyStatistics = undefined;\n      this.opProcessingTimes = {};\n      this.opPerfData = {};\n      this.connectionOpSeqNumber = undefined;\n      this.firstConnection = false;\n      this.pongCount = 0;\n    });\n    this.deltaManager.outbound.on(\"push\", messages => {\n      for (const msg of messages) {\n        if (msg.type === MessageType.Operation && this.clientSequenceNumberForLatencyStatistics === msg.clientSequenceNumber) {\n          assert(this.opProcessingTimes.outboundPushEventTime === undefined, 0x2c8 /* \"outboundPushEventTime should be undefined\" */);\n          assert(this.opPerfData.durationNetwork === undefined, 0x2c9 /* \"durationNetwork should be undefined\" */);\n          this.opProcessingTimes.outboundPushEventTime = Date.now();\n          assert(this.opPerfData.durationOutboundBatching === undefined, 0x2ca /* \"durationOutboundBatching should be undefined\" */);\n          assert(this.opProcessingTimes.submitOpEventTime !== undefined, 0x2cb /* \"submitOpEventTime should be undefined\" */);\n          this.opPerfData.durationOutboundBatching = this.opProcessingTimes.outboundPushEventTime - this.opProcessingTimes.submitOpEventTime;\n        }\n      }\n    });\n    this.deltaManager.inbound.on(\"push\", message => {\n      if (this.clientId === message.clientId && message.type === MessageType.Operation && this.clientSequenceNumberForLatencyStatistics === message.clientSequenceNumber && this.opProcessingTimes.outboundPushEventTime !== undefined) {\n        this.opProcessingTimes.inboundPushEventTime = Date.now();\n        this.opPerfData.durationNetwork = this.opProcessingTimes.inboundPushEventTime - this.opProcessingTimes.outboundPushEventTime;\n        this.opProcessingTimes.outboundPushEventTime = undefined;\n        this.opPerfData.lengthInboundQueue = this.deltaManager.inbound.length;\n      }\n    });\n    this.deltaManager.inbound.on(\"idle\", (count, duration) => {\n      // Do not want to log zero for sure.\n      // We are more interested in aggregates, so logging only if we are processing some number of ops\n      // Cut-off is arbitrary - can be increased or decreased based on amount of data collected and questions we\n      // want to get answered\n      // back-compat: Once 0.36 loader version saturates (count & duration args were added there),\n      // we can remove typeof check.\n      if (typeof count === \"number\" && count >= 100) {\n        this.logger.sendPerformanceEvent({\n          eventName: \"GetDeltas_OpProcessing\",\n          count,\n          duration\n        });\n      }\n    });\n  }\n  reportGettingUpToDate() {\n    this.connectionOpSeqNumber = undefined;\n    this.logger.sendPerformanceEvent({\n      eventName: \"ConnectionSpeed\",\n      duration: performance.now() - this.connectionStartTime,\n      ops: this.gap,\n      // track time to connect only for first connection.\n      timeToConnect: this.firstConnection ? TelemetryLogger.formatTick(this.connectionStartTime - this.bootTime) : undefined,\n      firstConnection: this.firstConnection\n    });\n  }\n  recordPingTime(latency) {\n    this.pingLatency = latency;\n    // logging one in every 1000 pongs, including the first time, if it is a \"write\" client.\n    if (this.pongCount % 100 === 0 && this.deltaManager.active) {\n      this.logger.sendPerformanceEvent({\n        eventName: \"DeltaLatency\",\n        duration: latency\n      });\n    }\n    this.pongCount++;\n  }\n  beforeOpSubmit(message) {\n    // start with first client op and measure latency every 500 client ops\n    if (this.clientSequenceNumberForLatencyStatistics === undefined && message.clientSequenceNumber % 500 === 1) {\n      assert(this.opProcessingTimes.outboundPushEventTime === undefined, 0x2cc /* \"OpTimeSittingInboundQueue should be undefined\" */);\n      assert(this.opPerfData.durationNetwork === undefined, 0x2cd /* \"durationNetwork should be undefined\" */);\n      this.opProcessingTimes.submitOpEventTime = Date.now();\n      this.clientSequenceNumberForLatencyStatistics = message.clientSequenceNumber;\n    }\n  }\n  afterProcessingOp(message) {\n    const sequenceNumber = message.sequenceNumber;\n    if (sequenceNumber === this.connectionOpSeqNumber) {\n      this.reportGettingUpToDate();\n    }\n    // Record collab window max size after every 1000th op.\n    if (this.sequenceNumberForMsnTracking === undefined && sequenceNumber % 1000 === 0) {\n      this.sequenceNumberForMsnTracking = sequenceNumber;\n      this.msnTrackingTimestamp = message.timestamp;\n    }\n    if (this.sequenceNumberForMsnTracking !== undefined && message.minimumSequenceNumber >= this.sequenceNumberForMsnTracking) {\n      assert(this.msnTrackingTimestamp !== undefined, 0x2ce /* \"msnTrackingTimestamp should not be undefined\" */);\n      this.logger.sendPerformanceEvent({\n        eventName: \"MsnStatistics\",\n        sequenceNumber,\n        msnDistance: sequenceNumber - this.sequenceNumberForMsnTracking,\n        duration: message.timestamp - this.msnTrackingTimestamp\n      });\n      this.sequenceNumberForMsnTracking = undefined;\n    }\n    if (this.clientId === message.clientId && this.clientSequenceNumberForLatencyStatistics === message.clientSequenceNumber) {\n      assert(this.opProcessingTimes.submitOpEventTime !== undefined, 0x120 /* \"Undefined latency statistics (op send time)\" */);\n      const currentTime = Date.now();\n      if (this.opProcessingTimes.inboundPushEventTime !== undefined) {\n        this.opPerfData.durationInboundToProcessing = currentTime - this.opProcessingTimes.inboundPushEventTime;\n      }\n      const duration = currentTime - this.opProcessingTimes.submitOpEventTime;\n      // One of the core expectations for Fluid service is to be fast.\n      // When it's not the case, we want to learn about it and be able to investigate, so\n      // raise awareness.\n      // This also helps identify cases where it's due to client behavior (sending too many ops)\n      // that results in overwhelming ordering service and thus starting to see long latencies.\n      // The threshold could be adjusted, but ideally it stays  workload-agnostic, as service\n      // performance impacts all workloads relying on service.\n      const category = duration > latencyThreshold ? \"error\" : \"performance\";\n      this.logger.sendPerformanceEvent(Object.assign({\n        eventName: \"OpRoundtripTime\",\n        sequenceNumber,\n        referenceSequenceNumber: message.referenceSequenceNumber,\n        duration,\n        category,\n        pingLatency: this.pingLatency,\n        msnDistance: this.deltaManager.lastSequenceNumber - this.deltaManager.minimumSequenceNumber\n      }, this.opPerfData));\n      this.clientSequenceNumberForLatencyStatistics = undefined;\n      this.opPerfData = {};\n    }\n  }\n}\nexport function ReportOpPerfTelemetry(clientId, deltaManager, logger) {\n  new OpPerfTelemetry(clientId, deltaManager, logger);\n}\n//# sourceMappingURL=connectionTelemetry.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}