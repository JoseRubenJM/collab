{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { Deferred } from \"@fluidframework/common-utils\";\n/**\n * Helper class to coordinate something that needs to run only while connected.\n * This provides promises that resolve as it starts or stops.  Stopping happens\n * when disconnected or if stop() is called.\n */\nexport class RunWhileConnectedCoordinator {\n  constructor(runtime) {\n    this.runtime = runtime;\n    this.everConnected = false;\n    this.stopDeferred = new Deferred();\n    // Try to determine if the runtime has ever been connected\n    if (this.runtime.connected) {\n      this.everConnected = true;\n    } else {\n      this.runtime.once(\"connected\", () => this.everConnected = true);\n    }\n    this.runtime.on(\"disconnected\", () => {\n      // Sometimes the initial connection state is raised as disconnected\n      if (!this.everConnected) {\n        return;\n      }\n      this.stop();\n    });\n  }\n  /**\n   * Starts and waits for a promise which resolves when connected.\n   * The promise will also resolve if stopped either externally or by disconnect.\n   * The return value indicates whether the start is successful or not.\n   */\n  waitStart() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (!_this.runtime.connected) {\n        if (_this.everConnected) {\n          // We will not try to reconnect, so we are done running\n          return {\n            started: false,\n            message: \"DisconnectedBeforeRun\"\n          };\n        }\n        const waitConnected = new Promise(resolve => _this.runtime.once(\"connected\", resolve));\n        yield Promise.race([waitConnected, _this.stopDeferred.promise]);\n        if (!_this.runtime.connected) {\n          // If still not connected, no need to start running\n          return {\n            started: false,\n            message: \"NeverConnectedBeforeRun\"\n          };\n        }\n      }\n      if (_this.runtime.clientId === undefined) {\n        throw Error(\"clientId should be defined if connected.\");\n      }\n      return {\n        started: true,\n        clientId: _this.runtime.clientId\n      };\n    })();\n  }\n  /**\n   * Returns a promise that resolves once stopped either externally or by disconnect.\n   */\n  waitStopped() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return _this2.stopDeferred.promise;\n    })();\n  }\n  /**\n   * Stops running.\n   */\n  stop() {\n    this.stopDeferred.resolve();\n  }\n}\n//# sourceMappingURL=runWhileConnectedCoordinator.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}