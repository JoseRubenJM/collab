{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { BaseTelemetryNullLogger, performance } from \"@fluidframework/common-utils\";\n/**\n * TelemetryLogger class contains various helper telemetry methods,\n * encoding in one place schemas for various types of Fluid telemetry events.\n * Creates sub-logger that appends properties to all events\n */\nexport let TelemetryLogger = /*#__PURE__*/(() => {\n  class TelemetryLogger {\n    constructor(namespace, properties, propertyGetters) {\n      this.namespace = namespace;\n      this.properties = properties;\n      this.propertyGetters = propertyGetters;\n    }\n    static formatTick(tick) {\n      return Math.floor(tick);\n    }\n    /**\n     * Attempts to parse number from string.\n     * If fails,returns original string.\n     * Used to make telemetry data typed (and support math operations, like comparison),\n     * in places where we do expect numbers (like contentsize/duration property in http header)\n     */\n    static numberFromString(str) {\n      if (str === undefined || str === null) {\n        return undefined;\n      }\n      const num = Number(str);\n      return Number.isNaN(num) ? str : num;\n    }\n    static sanitizePkgName(name) {\n      return name.replace(\"@\", \"\").replace(\"/\", \"-\");\n    }\n    static prepareErrorObject(event, error, fetchStack) {\n      if (error === null || typeof error !== \"object\") {\n        event.error = error;\n      } else {\n        // WARNING: Exceptions can contain PII!\n        // For example, XHR will throw object derived from Error that contains config information\n        // for failed request, including all the headers, and thus - user tokens!\n        // Extract only call stack, message, and couple network-related properties form error object\n        const errorAsObject = error;\n        event.stack = errorAsObject.stack;\n        event.error = errorAsObject.message;\n        // Error message can contain PII information.\n        // If we know for sure it does, we have to not log it.\n        if (error.containsPII) {\n          event.error = \"Error message was removed as it contained PII\";\n        } else if (error.getTelemetryProperties) {\n          const telemetryProps = error.getTelemetryProperties();\n          for (const key of Object.keys(telemetryProps)) {\n            if (event[key] === undefined) {\n              event[key] = telemetryProps[key];\n            }\n          }\n        }\n      }\n      // Collect stack if we were not able to extract it from error\n      if (event.stack === undefined && fetchStack) {\n        event.stack = TelemetryLogger.getStack();\n      }\n    }\n    static getStack() {\n      // Some browsers will populate stack right away, others require throwing Error\n      let stack = new Error().stack;\n      if (!stack) {\n        try {\n          throw new Error();\n        } catch (e) {\n          stack = e.stack;\n        }\n      }\n      return stack;\n    }\n    /**\n     * Send a telemetry event with the logger\n     *\n     * @param event - the event to send\n     * @param error - optional error object to log\n     */\n    sendTelemetryEvent(event, error) {\n      const newEvent = Object.assign(Object.assign({}, event), {\n        category: event.category ? event.category : \"generic\"\n      });\n      if (error !== undefined) {\n        TelemetryLogger.prepareErrorObject(newEvent, error, false);\n      }\n      this.send(newEvent);\n    }\n    /**\n     * Send an error telemetry event with the logger\n     *\n     * @param event - the event to send\n     * @param error - optional error object to log\n     */\n    sendErrorEvent(event, error) {\n      const newEvent = Object.assign(Object.assign({}, event), {\n        category: \"error\"\n      });\n      TelemetryLogger.prepareErrorObject(newEvent, error, true);\n      this.send(newEvent);\n    }\n    /**\n     * Send a performance telemetry event with the logger\n     *\n     * @param event - Event to send\n     * @param error - optional error object to log\n     */\n    sendPerformanceEvent(event, error) {\n      const perfEvent = Object.assign(Object.assign({}, event), {\n        category: event.category ? event.category : \"performance\"\n      });\n      if (error !== undefined) {\n        TelemetryLogger.prepareErrorObject(perfEvent, error, false);\n      }\n      if (event.duration) {\n        perfEvent.duration = TelemetryLogger.formatTick(event.duration);\n      }\n      this.send(perfEvent);\n    }\n    /**\n     * Log generic error with the logger\n     *\n     * @param eventName - the name of the event\n     * @param error - the error object to include in the event, require to be JSON-able\n     */\n    logGenericError(eventName, error) {\n      this.sendErrorEvent({\n        eventName\n      }, error);\n    }\n    /**\n     * Helper method to log exceptions\n     * @param event - the event to send\n     * @param exception - Exception object to add to an event\n     */\n    logException(event, exception) {\n      this.sendErrorEvent(Object.assign(Object.assign({}, event), {\n        isException: true\n      }), exception);\n    }\n    /**\n     * Log an debug assert with the logger\n     *\n     * @param condition - the condition to assert on\n     * @param event - the event to log if the condition fails\n     */\n    debugAssert(condition, event) {\n      this.shipAssert(condition, event);\n    }\n    /**\n     * Log an ship assert with the logger\n     *\n     * @param condition - the condition to assert on\n     * @param event - the event to log if the condition fails\n     */\n    shipAssert(condition, event) {\n      if (!condition) {\n        const realEvent = event === undefined ? {\n          eventName: \"Assert\"\n        } : event;\n        realEvent.isAssert = true;\n        realEvent.stack = TelemetryLogger.getStack();\n        this.sendErrorEvent(realEvent);\n      }\n    }\n    prepareEvent(event) {\n      const newEvent = Object.assign(Object.assign({}, this.properties), event);\n      if (this.namespace !== undefined) {\n        newEvent.eventName = `${this.namespace}${TelemetryLogger.eventNamespaceSeparator}${newEvent.eventName}`;\n      }\n      // Evaluate any getter functions\n      if (this.propertyGetters) {\n        for (const key of Object.keys(this.propertyGetters)) {\n          if (event[key] !== undefined) {\n            // Properties directly on the event take priority\n            continue;\n          }\n          const getter = this.propertyGetters[key];\n          // If this throws, hopefully it is handled elsewhere\n          const value = getter();\n          if (value !== undefined) {\n            newEvent[key] = value;\n          }\n        }\n      }\n      return newEvent;\n    }\n  }\n  TelemetryLogger.eventNamespaceSeparator = \":\";\n  /**\n   * ChildLogger class contains various helper telemetry methods,\n   * encoding in one place schemas for various types of Fluid telemetry events.\n   * Creates sub-logger that appends properties to all events\n   */\n  return TelemetryLogger;\n})();\nexport class ChildLogger extends TelemetryLogger {\n  constructor(baseLogger, namespace, properties, propertyGetters) {\n    super(namespace, properties, propertyGetters);\n    this.baseLogger = baseLogger;\n  }\n  /**\n   * Create child logger\n   * @param baseLogger - Base logger to use to output events. If undefined, proper child logger\n   * is created, but it does not sends telemetry events anywhere.\n   * @param namespace - Telemetry event name prefix to add to all events\n   * @param properties - Base properties to add to all events\n   * @param propertyGetters - Getters to add additional properties to all events\n   */\n  static create(baseLogger, namespace, properties, propertyGetters) {\n    // if we are creating a child of a child, rather than nest, which will increase\n    // the callstack overhead, just generate a new logger that includes everything from the previous\n    if (baseLogger instanceof ChildLogger) {\n      const combinedProperties = baseLogger.properties === undefined && properties === undefined ? undefined : Object.assign(Object.assign({}, baseLogger.properties), properties);\n      const combinedGetters = baseLogger.propertyGetters === undefined && propertyGetters === undefined ? undefined : Object.assign(Object.assign({}, baseLogger.propertyGetters), propertyGetters);\n      const combinedNamespace = baseLogger.namespace === undefined ? namespace : namespace === undefined ? baseLogger.namespace : `${baseLogger.namespace}${TelemetryLogger.eventNamespaceSeparator}${namespace}`;\n      return new ChildLogger(baseLogger.baseLogger, combinedNamespace, combinedProperties, combinedGetters);\n    }\n    return new ChildLogger(baseLogger ? baseLogger : new BaseTelemetryNullLogger(), namespace, properties, propertyGetters);\n  }\n  /**\n   * Send an event with the logger\n   *\n   * @param event - the event to send\n   */\n  send(event) {\n    this.baseLogger.send(this.prepareEvent(event));\n  }\n}\n/**\n * Multi-sink logger\n * Takes multiple ITelemetryBaseLogger objects (sinks) and logs all events into each sink\n * Implements ITelemetryBaseLogger (through static create() method)\n */\nexport class MultiSinkLogger extends TelemetryLogger {\n  /**\n   * Create multiple sink logger (i.e. logger that sends events to multiple sinks)\n   * @param namespace - Telemetry event name prefix to add to all events\n   * @param properties - Base properties to add to all events\n   * @param propertyGetters - Getters to add additional properties to all events\n   */\n  constructor(namespace, properties, propertyGetters) {\n    super(namespace, properties, propertyGetters);\n    this.loggers = [];\n  }\n  /**\n   * Add logger to send all events to\n   * @param logger - Logger to add\n   */\n  addLogger(logger) {\n    if (logger !== undefined && logger !== null) {\n      this.loggers.push(logger);\n    }\n  }\n  /**\n   * Send an event to the loggers\n   *\n   * @param event - the event to send to all the registered logger\n   */\n  send(event) {\n    const newEvent = this.prepareEvent(event);\n    this.loggers.forEach(logger => {\n      logger.send(newEvent);\n    });\n  }\n}\n/**\n * Helper class to log performance events\n */\nexport class PerformanceEvent {\n  constructor(logger, event) {\n    this.logger = logger;\n    this.startTime = performance.now();\n    this.event = Object.assign({}, event);\n    this.reportEvent(\"start\");\n    if (typeof window === \"object\" && window != null && window.performance) {\n      this.startMark = `${event.eventName}-start`;\n      window.performance.mark(this.startMark);\n    }\n  }\n  static start(logger, event) {\n    return new PerformanceEvent(logger, event);\n  }\n  static timedExec(logger, event, callback) {\n    const perfEvent = PerformanceEvent.start(logger, event);\n    try {\n      const ret = callback(perfEvent);\n      // Event might have been cancelled or ended in the callback\n      if (perfEvent.event) {\n        perfEvent.end();\n      }\n      return ret;\n    } catch (error) {\n      perfEvent.cancel(undefined, error);\n      throw error;\n    }\n  }\n  static timedExecAsync(logger, event, callback) {\n    return _asyncToGenerator(function* () {\n      const perfEvent = PerformanceEvent.start(logger, event);\n      try {\n        const ret = yield callback(perfEvent);\n        // Event might have been cancelled or ended in the callback\n        if (perfEvent.event) {\n          perfEvent.end();\n        }\n        return ret;\n      } catch (error) {\n        perfEvent.cancel(undefined, error);\n        throw error;\n      }\n    })();\n  }\n  reportProgress(props, eventNameSuffix = \"update\") {\n    this.reportEvent(eventNameSuffix, props);\n  }\n  end(props, eventNameSuffix = \"end\") {\n    if (!this.reportEvent(eventNameSuffix, props)) {\n      return;\n    }\n    if (this.startMark && this.event) {\n      const endMark = `${this.event.eventName}-${eventNameSuffix}`;\n      window.performance.mark(endMark);\n      window.performance.measure(`${this.event.eventName}`, this.startMark, endMark);\n      this.startMark = undefined;\n    }\n    this.event = undefined;\n  }\n  cancel(props, error) {\n    this.reportEvent(\"cancel\", props, error);\n    this.event = undefined;\n  }\n  /**\n   * Report the event, if it hasn't already been reported.\n   * Returns a boolean indicating if it was reported this time.\n   */\n  reportEvent(eventNameSuffix, props, error) {\n    // There are strange sequences involving muliple Promise chains\n    // where the event can be cancelled and then later a callback is invoked\n    // and the caller attempts to end directly, e.g. issue #3936. Just return.\n    if (!this.event) {\n      return false;\n    }\n    const event = Object.assign(Object.assign({}, this.event), props);\n    event.eventName = `${event.eventName}_${eventNameSuffix}`;\n    if (eventNameSuffix !== \"start\") {\n      event.duration = performance.now() - this.startTime;\n    }\n    this.logger.sendPerformanceEvent(event, error);\n    return true;\n  }\n}\n/**\n * - Helper class for error tracking that can be used to log an error in telemetry.\n * - Care needs to be taken not to log PII information!\n * - This allows additional properties to be logged because object of this instance will record all of their properties\n *   when logged with a logger.\n * - Logger ignores all properties from any other error objects (not being instance of LoggingError), with exception of\n *   'message' & 'stack' properties if they exists on error object.\n * - In other words, logger logs only what it knows about and has good confidence it does not container PII information.\n */\nexport class LoggingError extends Error {\n  constructor(message, props) {\n    super(message);\n    Object.assign(this, props);\n  }\n  // Return all properties\n  getTelemetryProperties() {\n    const props = {};\n    // Could not use {...this} because it does not return properties of base class.\n    for (const key of Object.getOwnPropertyNames(this)) {\n      props[key] = this[key];\n    }\n    return props;\n  }\n}\n//# sourceMappingURL=logger.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}