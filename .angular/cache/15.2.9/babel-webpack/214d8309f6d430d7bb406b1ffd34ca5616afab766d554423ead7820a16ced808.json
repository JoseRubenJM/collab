{"ast":null,"code":"import _asyncToGenerator from \"/Users/jose/Desktop/proyects/fluid-angular/FluidAngular/collaborative-textarea/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n// eslint-disable-next-line import/no-internal-modules\nimport merge from \"lodash/merge\";\nimport { v4 as uuid } from \"uuid\";\nimport { assert, performance } from \"@fluidframework/common-utils\";\nimport { isFluidCodeDetails } from \"@fluidframework/core-interfaces\";\nimport { LoaderHeader, AttachState } from \"@fluidframework/container-definitions\";\nimport { CreateContainerError, GenericError } from \"@fluidframework/container-utils\";\nimport { DriverHeader } from \"@fluidframework/driver-definitions\";\nimport { BlobCacheStorageService, readAndParse, OnlineStatus, isOnline, ensureFluidResolvedUrl, combineAppAndProtocolSummary, readAndParseFromBlobs, buildSnapshotTree } from \"@fluidframework/driver-utils\";\nimport { isSystemMessage, ProtocolOpHandler, QuorumProxy } from \"@fluidframework/protocol-base\";\nimport { FileMode, MessageType, TreeEntry } from \"@fluidframework/protocol-definitions\";\nimport { ChildLogger, EventEmitterWithErrorHandling, PerformanceEvent, raiseConnectedEvent, TelemetryLogger } from \"@fluidframework/telemetry-utils\";\nimport { Audience } from \"./audience\";\nimport { ContainerContext } from \"./containerContext\";\nimport { debug } from \"./debug\";\nimport { DeltaManager } from \"./deltaManager\";\nimport { DeltaManagerProxy } from \"./deltaManagerProxy\";\nimport { RelativeLoader } from \"./loader\";\nimport { pkgVersion } from \"./packageVersion\";\nimport { parseUrl, convertProtocolAndAppSummaryToSnapshotTree } from \"./utils\";\nconst detachedContainerRefSeqNumber = 0;\nexport var ConnectionState = /*#__PURE__*/(() => {\n  (function (ConnectionState) {\n    /**\n     * The document is no longer connected to the delta server\n     */\n    ConnectionState[ConnectionState[\"Disconnected\"] = 0] = \"Disconnected\";\n    /**\n     * The document has an inbound connection but is still pending for outbound deltas\n     */\n    ConnectionState[ConnectionState[\"Connecting\"] = 1] = \"Connecting\";\n    /**\n     * The document is fully connected\n     */\n    ConnectionState[ConnectionState[\"Connected\"] = 2] = \"Connected\";\n  })(ConnectionState || (ConnectionState = {}));\n  return ConnectionState;\n})();\n/**\n * Waits until container connects to delta storage and gets up-to-date\n * Useful when resolving URIs and hitting 404, due to container being loaded from (stale) snapshot and not being\n * up to date. Host may chose to wait in such case and retry resolving URI.\n * Warning: Will wait infinitely for connection to establish if there is no connection.\n * May result in deadlock if Container.setAutoReconnect(false) is called and never switched back to auto-reconnect.\n * @returns true: container is up to date, it processed all the ops that were know at the time of first connection\n *          false: storage does not provide indication of how far the client is. Container processed\n *          all the ops known to it, but it maybe still behind.\n */\nexport function waitContainerToCatchUp(_x) {\n  return _waitContainerToCatchUp.apply(this, arguments);\n}\nfunction _waitContainerToCatchUp() {\n  _waitContainerToCatchUp = _asyncToGenerator(function* (container) {\n    // Make sure we stop waiting if container is closed.\n    if (container.closed) {\n      throw new Error(\"Container is closed\");\n    }\n    return new Promise((accept, reject) => {\n      const deltaManager = container.deltaManager;\n      container.on(\"closed\", reject);\n      const waitForOps = () => {\n        assert(container.connectionState !== ConnectionState.Disconnected);\n        const hasCheckpointSequenceNumber = deltaManager.hasCheckpointSequenceNumber;\n        const connectionOpSeqNumber = deltaManager.lastKnownSeqNumber;\n        if (deltaManager.lastSequenceNumber === connectionOpSeqNumber) {\n          accept(hasCheckpointSequenceNumber);\n          return;\n        }\n        const callbackOps = message => {\n          if (connectionOpSeqNumber <= message.sequenceNumber) {\n            accept(hasCheckpointSequenceNumber);\n            deltaManager.off(\"op\", callbackOps);\n          }\n        };\n        deltaManager.on(\"op\", callbackOps);\n      };\n      if (container.connectionState !== ConnectionState.Disconnected) {\n        waitForOps();\n        return;\n      }\n      const callback = () => {\n        deltaManager.off(\"connect\", callback);\n        waitForOps();\n      };\n      deltaManager.on(\"connect\", callback);\n      container.resume();\n    });\n  });\n  return _waitContainerToCatchUp.apply(this, arguments);\n}\nexport let Container = /*#__PURE__*/(() => {\n  class Container extends EventEmitterWithErrorHandling {\n    constructor(loader, config) {\n      super();\n      this.loader = loader;\n      // Tells if container can reconnect on losing fist connection\n      // If false, container gets closed on loss of connection.\n      this._canReconnect = true;\n      this.loaded = false;\n      this._attachState = AttachState.Detached;\n      this._connectionState = ConnectionState.Disconnected;\n      this.resumedOpProcessingAfterLoad = false;\n      this.firstConnection = true;\n      this.manualReconnectInProgress = false;\n      this.connectionTransitionTimes = [];\n      this.messageCountAfterDisconnection = 0;\n      this.attachInProgress = false;\n      this._closed = false;\n      this._audience = new Audience();\n      // Initialize from config\n      this.originalRequest = config.originalRequest;\n      this._id = config.id;\n      this._resolvedUrl = config.resolvedUrl;\n      if (config.canReconnect !== undefined) {\n        this._canReconnect = config.canReconnect;\n      }\n      // Create logger for data stores to use\n      const type = this.client.details.type;\n      const interactive = this.client.details.capabilities.interactive;\n      const clientType = `${interactive ? \"interactive\" : \"noninteractive\"}${type !== undefined && type !== \"\" ? `/${type}` : \"\"}`;\n      // Need to use the property getter for docId because for detached flow we don't have the docId initially.\n      // We assign the id later so property getter is used.\n      this.subLogger = ChildLogger.create(loader.services.subLogger, undefined, {\n        clientType,\n        loaderVersion: pkgVersion,\n        containerId: uuid()\n      }, {\n        docId: () => this.id,\n        containerAttachState: () => this._attachState,\n        containerLoaded: () => this.loaded\n      });\n      // Prefix all events in this file with container-loader\n      this.logger = ChildLogger.create(this.subLogger, \"Container\");\n      this._deltaManager = this.createDeltaManager();\n      // keep track of last time page was visible for telemetry\n      if (typeof document === \"object\" && document !== null) {\n        this.lastVisible = document.hidden ? performance.now() : undefined;\n        document.addEventListener(\"visibilitychange\", () => {\n          if (document.hidden) {\n            this.lastVisible = performance.now();\n          } else {\n            // settimeout so this will hopefully fire after disconnect event if being hidden caused it\n            setTimeout(() => this.lastVisible = undefined, 0);\n          }\n        });\n      }\n    }\n    /**\n     * Load an existing container.\n     */\n    static load(id, loader, request, resolvedUrl) {\n      return _asyncToGenerator(function* () {\n        var _a;\n        const [, docId] = id.split(\"/\");\n        const container = new Container(loader, {\n          originalRequest: request,\n          id: decodeURI(docId),\n          resolvedUrl,\n          canReconnect: !(((_a = request.headers) === null || _a === void 0 ? void 0 : _a[LoaderHeader.reconnect]) === false)\n        });\n        return PerformanceEvent.timedExecAsync(container.logger, {\n          eventName: \"Load\"\n        }, /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (event) {\n            return new Promise((res, rej) => {\n              var _a, _b;\n              const version = (_a = request.headers) === null || _a === void 0 ? void 0 : _a[LoaderHeader.version];\n              const pause = (_b = request.headers) === null || _b === void 0 ? void 0 : _b[LoaderHeader.pause];\n              const onClosed = err => {\n                // Depending where error happens, we can be attempting to connect to web socket\n                // and continuously retrying (consider offline mode)\n                // Host has no container to close, so it's prudent to do it here\n                const error = err !== null && err !== void 0 ? err : CreateContainerError(\"Container closed without an error\");\n                container.close(error);\n                rej(error);\n              };\n              container.on(\"closed\", onClosed);\n              container.load(version, pause === true).finally(() => {\n                container.removeListener(\"closed\", onClosed);\n              }).then(props => {\n                event.end(props);\n                res(container);\n              }, error => {\n                const err = CreateContainerError(error);\n                onClosed(err);\n              });\n            });\n          });\n          return function (_x2) {\n            return _ref.apply(this, arguments);\n          };\n        }());\n      })();\n    }\n    /**\n     * Create a new container in a detached state.\n     */\n    static createDetached(loader, codeDetails) {\n      return _asyncToGenerator(function* () {\n        const container = new Container(loader, {});\n        yield container.createDetached(codeDetails);\n        return container;\n      })();\n    }\n    /**\n     * Create a new container in a detached state that is initialized with a\n     * snapshot from a previous detached container.\n     */\n    static rehydrateDetachedFromSnapshot(loader, snapshot) {\n      return _asyncToGenerator(function* () {\n        const container = new Container(loader, {});\n        yield container.rehydrateDetachedFromSnapshot(snapshot);\n        return container;\n      })();\n    }\n    get storageService() {\n      if (this._storageService === undefined) {\n        throw new Error(\"Attempted to access storageService before it was defined\");\n      }\n      return this._storageService;\n    }\n    get context() {\n      if (this._context === undefined) {\n        throw new Error(\"Attempted to access context before it was defined\");\n      }\n      return this._context;\n    }\n    get protocolHandler() {\n      if (this._protocolHandler === undefined) {\n        throw new Error(\"Attempted to access protocolHandler before it was defined\");\n      }\n      return this._protocolHandler;\n    }\n    get IFluidRouter() {\n      return this;\n    }\n    get resolvedUrl() {\n      return this._resolvedUrl;\n    }\n    get loadedFromVersion() {\n      return this._loadedFromVersion;\n    }\n    /**\n     * {@inheritDoc DeltaManager.readonly}\n     */\n    get readonly() {\n      return this._deltaManager.readonly;\n    }\n    /**\n     * {@inheritDoc DeltaManager.readonlyPermissions}\n     */\n    get readonlyPermissions() {\n      return this._deltaManager.readonlyPermissions;\n    }\n    /**\n     * {@inheritDoc DeltaManager.forceReadonly}\n     */\n    forceReadonly(readonly) {\n      this._deltaManager.forceReadonly(readonly);\n    }\n    get closed() {\n      return this._closed;\n    }\n    get id() {\n      var _a;\n      return _a = this._id, _a !== null && _a !== void 0 ? _a : \"\";\n    }\n    get deltaManager() {\n      return this._deltaManager;\n    }\n    get connectionState() {\n      return this._connectionState;\n    }\n    get connected() {\n      return this.connectionState === ConnectionState.Connected;\n    }\n    /**\n     * Service configuration details. If running in offline mode will be undefined otherwise will contain service\n     * configuration details returned as part of the initial connection.\n     */\n    get serviceConfiguration() {\n      return this._deltaManager.serviceConfiguration;\n    }\n    /**\n     * The server provided id of the client.\n     * Set once this.connected is true, otherwise undefined\n     */\n    get clientId() {\n      return this._clientId;\n    }\n    /**\n     * The server provided claims of the client.\n     * Set once this.connected is true, otherwise undefined\n     */\n    get scopes() {\n      return this._deltaManager.scopes;\n    }\n    get clientDetails() {\n      return this._deltaManager.clientDetails;\n    }\n    /**\n     * @deprecated use codeDetails\n     */\n    get chaincodePackage() {\n      return this.codeDetails;\n    }\n    get codeDetails() {\n      var _a, _b;\n      return _b = (_a = this._context) === null || _a === void 0 ? void 0 : _a.codeDetails, _b !== null && _b !== void 0 ? _b : this.getCodeDetailsFromQuorum();\n    }\n    /**\n     * Flag indicating whether the document already existed at the time of load\n     */\n    get existing() {\n      return this._existing;\n    }\n    /**\n     * Retrieves the audience associated with the document\n     */\n    get audience() {\n      return this._audience;\n    }\n    get serviceFactory() {\n      return this.loader.services.documentServiceFactory;\n    }\n    get urlResolver() {\n      return this.loader.services.urlResolver;\n    }\n    get options() {\n      return this.loader.services.options;\n    }\n    get scope() {\n      return this.loader.services.scope;\n    }\n    get codeLoader() {\n      return this.loader.services.codeLoader;\n    }\n    /**\n     * Retrieves the quorum associated with the document\n     */\n    getQuorum() {\n      return this.protocolHandler.quorum;\n    }\n    close(error) {\n      var _a, _b, _c;\n      if (this._closed) {\n        return;\n      }\n      this._closed = true;\n      this._deltaManager.close(error);\n      (_a = this._protocolHandler) === null || _a === void 0 ? void 0 : _a.close();\n      (_b = this._context) === null || _b === void 0 ? void 0 : _b.dispose(error !== undefined ? new Error(error.message) : undefined);\n      assert(this.connectionState === ConnectionState.Disconnected, \"disconnect event was not raised!\");\n      if (error !== undefined) {\n        // Log current sequence number - useful if we have access to a file to understand better\n        // what op caused trouble (if it's related to op processing).\n        // Runtime may provide sequence number as part of error object - this may not match DeltaManager\n        // knowledge as old ops are processed when data stores / DDS are re-hydrated when delay-loaded\n        this.logger.sendErrorEvent({\n          eventName: \"ContainerClose\",\n          sequenceNumber: (_c = error.sequenceNumber, _c !== null && _c !== void 0 ? _c : this._deltaManager.lastSequenceNumber)\n        }, error);\n      } else {\n        assert(this.loaded);\n        this.logger.sendTelemetryEvent({\n          eventName: \"ContainerClose\"\n        });\n      }\n      this.emit(\"closed\", error);\n      this.removeAllListeners();\n    }\n    get attachState() {\n      return this._attachState;\n    }\n    serialize() {\n      assert(this.attachState === AttachState.Detached, \"Should only be called in detached container\");\n      const appSummary = this.context.createSummary();\n      const protocolSummary = this.captureProtocolSummary();\n      const snapshotTree = convertProtocolAndAppSummaryToSnapshotTree(protocolSummary, appSummary);\n      return JSON.stringify(snapshotTree);\n    }\n    attach(request) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        var _a, _b;\n        assert(_this.loaded, \"not loaded\");\n        assert(!_this.closed, \"closed\");\n        // LoaderHeader.reconnect when set to false means we are allowing one connection,\n        // but do not allow re-connections. This is not very meaningful for attach process,\n        // plus this._canReconnect is provided to DeltaManager in constructor, so it's a bit too late.\n        // It might be useful to have an option to never connect, i.e. create file and close container,\n        // but that's a new feature to implement, not clear if we want to use same property for that.\n        assert(!(((_a = request.headers) === null || _a === void 0 ? void 0 : _a[LoaderHeader.reconnect]) === false), \"reconnect\");\n        // If container is already attached or attach is in progress, return.\n        if (_this._attachState === AttachState.Attached || _this.attachInProgress) {\n          return;\n        }\n        _this.attachInProgress = true;\n        try {\n          assert(_this.deltaManager.inbound.length === 0, \"Inbound queue should be empty when attaching\");\n          // Only take a summary if the container is in detached state, otherwise we could have local changes.\n          // In failed attach call, we would already have a summary cached.\n          if (_this._attachState === AttachState.Detached) {\n            // 0.24 back-compat attachingBeforeSummary\n            if (_this.context.runtimeVersion === undefined || _this.context.runtimeVersion < \"0.25\") {\n              _this._attachState = AttachState.Attaching;\n              _this.emit(\"attaching\");\n            }\n            // Get the document state post attach - possibly can just call attach but we need to change the\n            // semantics around what the attach means as far as async code goes.\n            const appSummary = _this.context.createSummary();\n            if (_this.protocolHandler === undefined) {\n              throw new Error(\"Protocol Handler is undefined\");\n            }\n            const protocolSummary = _this.captureProtocolSummary();\n            _this.cachedAttachSummary = combineAppAndProtocolSummary(appSummary, protocolSummary);\n            // Set the state as attaching as we are starting the process of attaching container.\n            // This should be fired after taking the summary because it is the place where we are\n            // starting to attach the container to storage.\n            // Also, this should only be fired in detached container.\n            if (_this.context.runtimeVersion !== undefined && _this.context.runtimeVersion >= \"0.25\") {\n              _this._attachState = AttachState.Attaching;\n              _this.emit(\"attaching\");\n            }\n          }\n          assert(!!_this.cachedAttachSummary, \"Summary should be there either by this attach call or previous attach call!!\");\n          if (((_b = request.headers) === null || _b === void 0 ? void 0 : _b[DriverHeader.createNew]) === undefined) {\n            request.headers = Object.assign(Object.assign({}, request.headers), {\n              [DriverHeader.createNew]: {}\n            });\n          }\n          const createNewResolvedUrl = yield _this.urlResolver.resolve(request);\n          ensureFluidResolvedUrl(createNewResolvedUrl);\n          // Actually go and create the resolved document\n          if (_this.service === undefined) {\n            _this.service = yield _this.serviceFactory.createContainer(_this.cachedAttachSummary, createNewResolvedUrl, _this.subLogger);\n          }\n          const resolvedUrl = _this.service.resolvedUrl;\n          ensureFluidResolvedUrl(resolvedUrl);\n          _this._resolvedUrl = resolvedUrl;\n          const url = yield _this.getAbsoluteUrl(\"\");\n          assert(url !== undefined, \"Container url undefined\");\n          _this.originalRequest = {\n            url\n          };\n          const parsedUrl = parseUrl(resolvedUrl.url);\n          if (parsedUrl === undefined) {\n            throw new Error(\"Unable to parse Url\");\n          }\n          _this.loader.cacheContainer(_this, request, parsedUrl);\n          const [, docId] = parsedUrl.id.split(\"/\");\n          _this._id = decodeURI(docId);\n          if (_this._storageService === undefined) {\n            _this._storageService = yield _this.getDocumentStorageService();\n          }\n          // This we can probably just pass the storage service to the blob manager - although ideally\n          // there just isn't a blob manager\n          _this._attachState = AttachState.Attached;\n          _this.emit(\"attached\");\n          _this.cachedAttachSummary = undefined;\n          // Propagate current connection state through the system.\n          _this.propagateConnectionState();\n          _this.resumeInternal({\n            fetchOpsFromStorage: false,\n            reason: \"createDetached\"\n          });\n        } finally {\n          _this.attachInProgress = false;\n        }\n      })();\n    }\n    request(path) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        return PerformanceEvent.timedExecAsync(_this2.logger, {\n          eventName: \"Request\"\n        }, /*#__PURE__*/_asyncToGenerator(function* () {\n          return _this2.context.request(path);\n        }));\n      })();\n    }\n    snapshot(tagMessage, fullTree = false) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        // Only snapshot once a code quorum has been established\n        if (!_this3.protocolHandler.quorum.has(\"code\") && !_this3.protocolHandler.quorum.has(\"code2\")) {\n          _this3.logger.sendTelemetryEvent({\n            eventName: \"SkipSnapshot\"\n          });\n          return;\n        }\n        // Stop inbound message processing while we complete the snapshot\n        try {\n          yield _this3.deltaManager.inbound.pause();\n          yield _this3.snapshotCore(tagMessage, fullTree);\n        } catch (ex) {\n          _this3.logger.logException({\n            eventName: \"SnapshotExceptionError\"\n          }, ex);\n          throw ex;\n        } finally {\n          _this3.deltaManager.inbound.resume();\n        }\n      })();\n    }\n    setAutoReconnect(reconnect) {\n      if (reconnect && this.closed) {\n        throw new Error(\"Attempting to setAutoReconnect() a closed DeltaManager\");\n      }\n      this._deltaManager.setAutomaticReconnect(reconnect);\n      this.logger.sendTelemetryEvent({\n        eventName: reconnect ? \"AutoReconnectEnabled\" : \"AutoReconnectDisabled\",\n        connectionMode: this._deltaManager.connectionMode,\n        connectionState: ConnectionState[this.connectionState]\n      });\n      // If container state is not attached and resumed, then don't connect to delta stream. Also don't set the\n      // manual reconnection flag to true as we haven't made the initial connection yet.\n      if (reconnect && this._attachState === AttachState.Attached && this.resumedOpProcessingAfterLoad) {\n        if (this._connectionState === ConnectionState.Disconnected) {\n          // Only track this as a manual reconnection if we are truly the ones kicking it off.\n          this.manualReconnectInProgress = true;\n        }\n        // Ensure connection to web socket\n        this.connectToDeltaStream({\n          reason: \"autoReconnect\"\n        }).catch(error => {\n          // All errors are reported through events (\"error\" / \"disconnected\") and telemetry in DeltaManager\n          // So there shouldn't be a need to record error here.\n          // But we have number of cases where reconnects do not happen, and no errors are recorded, so\n          // adding this log point for easier diagnostics\n          this.logger.sendTelemetryEvent({\n            eventName: \"setAutoReconnectError\"\n          }, error);\n        });\n      }\n    }\n    resume() {\n      this.resumeInternal();\n    }\n    resumeInternal(args = {}) {\n      if (this.closed) {\n        throw new Error(\"Attempting to setAutoReconnect() a closed DeltaManager\");\n      }\n      // Resume processing ops\n      if (!this.resumedOpProcessingAfterLoad) {\n        this.resumedOpProcessingAfterLoad = true;\n        this._deltaManager.inbound.resume();\n        this._deltaManager.outbound.resume();\n        this._deltaManager.inboundSignal.resume();\n      }\n      // Ensure connection to web socket\n      // All errors are reported through events (\"error\" / \"disconnected\") and telemetry in DeltaManager\n      this.connectToDeltaStream(args).catch(() => {});\n    }\n    get storage() {\n      var _a;\n      return _a = this.blobsCacheStorageService, _a !== null && _a !== void 0 ? _a : this._storageService;\n    }\n    /**\n     * Raise non-critical error to host. Calling this API will not close container.\n     * For critical errors, please call Container.close(error).\n     * @param error - an error to raise\n     */\n    raiseContainerWarning(warning) {\n      // Some \"warning\" events come from outside the container and are logged\n      // elsewhere (e.g. summarizing container). We shouldn't log these here.\n      if (warning.logged !== true) {\n        this.logContainerError(warning);\n      }\n      this.emit(\"warning\", warning);\n    }\n    reloadContext() {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        return _this4.reloadContextCore().catch(error => {\n          _this4.close(CreateContainerError(error));\n          throw error;\n        });\n      })();\n    }\n    hasNullRuntime() {\n      return this.context.hasNullRuntime();\n    }\n    getAbsoluteUrl(relativeUrl) {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        var _a;\n        if (_this5.resolvedUrl === undefined) {\n          return undefined;\n        }\n        // TODO: Remove support for legacy requestUrl in 0.20\n        const legacyResolver = _this5.urlResolver;\n        if (legacyResolver.getAbsoluteUrl !== undefined) {\n          return _this5.urlResolver.getAbsoluteUrl(_this5.resolvedUrl, relativeUrl, (_a = _this5._context) === null || _a === void 0 ? void 0 : _a.codeDetails);\n        }\n        if (legacyResolver.requestUrl !== undefined) {\n          const response = yield legacyResolver.requestUrl(_this5.resolvedUrl, {\n            url: relativeUrl\n          });\n          if (response.status === 200) {\n            return response.value;\n          }\n          throw new Error(response.value);\n        }\n        throw new Error(\"Url Resolver does not support creating urls\");\n      })();\n    }\n    proposeCodeDetails(codeDetails) {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        if (!isFluidCodeDetails(codeDetails)) {\n          throw new Error(\"Provided codeDetails are not IFluidCodeDetails\");\n        }\n        if (_this6.codeLoader.IFluidCodeDetailsComparer) {\n          const comparision = yield _this6.codeLoader.IFluidCodeDetailsComparer.compare(codeDetails, _this6.getCodeDetailsFromQuorum());\n          if (comparision !== undefined && comparision <= 0) {\n            throw new Error(\"Proposed code details should be greater than the current\");\n          }\n        }\n        return _this6.getQuorum().propose(\"code\", codeDetails).then(() => true).catch(() => false);\n      })();\n    }\n    reloadContextCore() {\n      var _this7 = this;\n      return _asyncToGenerator(function* () {\n        var _a;\n        const codeDetails = _this7.getCodeDetailsFromQuorum();\n        yield Promise.all([_this7.deltaManager.inbound.pause(), _this7.deltaManager.inboundSignal.pause()]);\n        if ((yield _this7.context.satisfies(codeDetails)) === true) {\n          _this7.deltaManager.inbound.resume();\n          _this7.deltaManager.inboundSignal.resume();\n          return;\n        }\n        let state = {\n          hotSwap: false\n        };\n        if (_this7.options.hotSwapContext === true) {\n          const prevState = yield _this7.context.snapshotRuntimeState();\n          state = {\n            hotSwap: true,\n            prevState\n          };\n        }\n        _this7.context.dispose(new Error(\"ContextDisposedForReload\"));\n        // We always hot-swap, but we don't fire the contextDisposed event\n        // if we are transitioning from a null runtime to a real runtime\n        // with detached container we no longer need the null runtime, but for legacy\n        // reasons need to keep it around (old documents without summary before code proposal).\n        // client's shouldn't need to care about this transition, as it is a implementation detail.\n        // if we didn't do this check, the clients would need to do it themselves,\n        // which would futher spread the usage of the hasNullRuntime property\n        // making it harder to deprecate.\n        if (_this7.hasNullRuntime()) {\n          if (!state.hotSwap) {\n            state = {\n              hotSwap: true,\n              prevState: {}\n            };\n          }\n        } else {\n          _this7.emit(\"contextDisposed\", codeDetails, (_a = _this7.context) === null || _a === void 0 ? void 0 : _a.codeDetails);\n        }\n        if (_this7.closed) {\n          return;\n        }\n        if (!state.hotSwap) {\n          _this7.close();\n          return;\n        }\n        let snapshot;\n        const blobs = new Map();\n        if (state.prevState.snapshot !== undefined) {\n          snapshot = buildSnapshotTree(state.prevState.snapshot.entries, blobs);\n          /**\n           * Should be removed / updated after issue #2914 is fixed.\n           * There are currently two scenarios where this is called:\n           * 1. When a new code proposal is accepted - This should be set to true before `this.loadContext` is\n           * called which creates and loads the ContainerRuntime. This is because for \"read\" mode clients this\n           * flag is false which causes ContainerRuntime to create the internal components again.\n           * 2. When the first client connects in \"write\" mode - This happens when a client does not create the\n           * Container in detached mode. In this case, when the code proposal is accepted, we come here and we\n           * need to create the internal data stores in ContainerRuntime.\n           * Once we move to using detached container everywhere, this can move outside this block.\n           */\n          _this7._existing = true;\n        }\n        if (blobs.size > 0) {\n          _this7.blobsCacheStorageService = new BlobCacheStorageService(_this7.storageService, blobs);\n        }\n        const attributes = {\n          branch: _this7.id,\n          minimumSequenceNumber: _this7._deltaManager.minimumSequenceNumber,\n          sequenceNumber: _this7._deltaManager.lastSequenceNumber,\n          term: _this7._deltaManager.referenceTerm\n        };\n        yield _this7.loadContext(codeDetails, attributes, snapshot, state.prevState);\n        _this7.deltaManager.inbound.resume();\n        _this7.deltaManager.inboundSignal.resume();\n      })();\n    }\n    snapshotCore(tagMessage, fullTree = false) {\n      var _this8 = this;\n      return _asyncToGenerator(function* () {\n        // Snapshots base document state and currently running context\n        const root = _this8.snapshotBase();\n        const dataStoreEntries = yield _this8.context.snapshot(tagMessage, fullTree);\n        // And then combine\n        if (dataStoreEntries !== null) {\n          root.entries.push(...dataStoreEntries.entries);\n        }\n        // Generate base snapshot message\n        const deltaDetails = `${_this8._deltaManager.lastSequenceNumber}:${_this8._deltaManager.minimumSequenceNumber}`;\n        const message = `Commit @${deltaDetails} ${tagMessage}`;\n        // Pull in the prior version and snapshot tree to store against\n        const lastVersion = yield _this8.getVersion(_this8.id);\n        const parents = lastVersion !== undefined ? [lastVersion.id] : [];\n        // Write the full snapshot\n        return _this8.storageService.write(root, parents, message, \"\");\n      })();\n    }\n    snapshotBase() {\n      const entries = [];\n      const quorumSnapshot = this.protocolHandler.quorum.snapshot();\n      entries.push({\n        mode: FileMode.File,\n        path: \"quorumMembers\",\n        type: TreeEntry.Blob,\n        value: {\n          contents: JSON.stringify(quorumSnapshot.members),\n          encoding: \"utf-8\"\n        }\n      });\n      entries.push({\n        mode: FileMode.File,\n        path: \"quorumProposals\",\n        type: TreeEntry.Blob,\n        value: {\n          contents: JSON.stringify(quorumSnapshot.proposals),\n          encoding: \"utf-8\"\n        }\n      });\n      entries.push({\n        mode: FileMode.File,\n        path: \"quorumValues\",\n        type: TreeEntry.Blob,\n        value: {\n          contents: JSON.stringify(quorumSnapshot.values),\n          encoding: \"utf-8\"\n        }\n      });\n      // Save attributes for the document\n      const documentAttributes = {\n        branch: this.id,\n        minimumSequenceNumber: this._deltaManager.minimumSequenceNumber,\n        sequenceNumber: this._deltaManager.lastSequenceNumber,\n        term: this._deltaManager.referenceTerm\n      };\n      entries.push({\n        mode: FileMode.File,\n        path: \".attributes\",\n        type: TreeEntry.Blob,\n        value: {\n          contents: JSON.stringify(documentAttributes),\n          encoding: \"utf-8\"\n        }\n      });\n      // Output the tree\n      const root = {\n        entries\n      };\n      return root;\n    }\n    getVersion(version) {\n      var _this9 = this;\n      return _asyncToGenerator(function* () {\n        const versions = yield _this9.storageService.getVersions(version, 1);\n        return versions[0];\n      })();\n    }\n    recordConnectStartTime() {\n      if (this.connectionTransitionTimes[ConnectionState.Disconnected] === undefined) {\n        this.connectionTransitionTimes[ConnectionState.Disconnected] = performance.now();\n      }\n    }\n    connectToDeltaStream(args = {}) {\n      var _this10 = this;\n      return _asyncToGenerator(function* () {\n        _this10.recordConnectStartTime();\n        // All agents need \"write\" access, including summarizer.\n        if (!_this10._canReconnect || !_this10.client.details.capabilities.interactive) {\n          args.mode = \"write\";\n        }\n        return _this10._deltaManager.connect(args);\n      })();\n    }\n    /**\n     * Load container.\n     *\n     * @param specifiedVersion - one of the following\n     *   - null: use ops, no snapshots\n     *   - undefined - fetch latest snapshot\n     *   - otherwise, version sha to load snapshot\n     * @param pause - start the container in a paused state\n     */\n    load(specifiedVersion, pause) {\n      var _this11 = this;\n      return _asyncToGenerator(function* () {\n        if (_this11._resolvedUrl === undefined) {\n          throw new Error(\"Attempting to load without a resolved url\");\n        }\n        _this11.service = yield _this11.serviceFactory.createDocumentService(_this11._resolvedUrl, _this11.subLogger);\n        let startConnectionP;\n        // Ideally we always connect as \"read\" by default.\n        // Currently that works with SPO & r11s, because we get \"write\" connection when connecting to non-existing file.\n        // We should not rely on it by (one of them will address the issue, but we need to address both)\n        // 1) switching create new flow to one where we create file by posting snapshot\n        // 2) Fixing quorum workflows (have retry logic)\n        // That all said, \"read\" does not work with memorylicious workflows (that opens two simultaneous\n        // connections to same file) in two ways:\n        // A) creation flow breaks (as one of the clients \"sees\" file as existing, and hits #2 above)\n        // B) Once file is created, transition from view-only connection to write does not work - some bugs to be fixed.\n        const connectionArgs = {\n          mode: \"write\"\n        };\n        // Start websocket connection as soon as possible. Note that there is no op handler attached yet, but the\n        // DeltaManager is resilient to this and will wait to start processing ops until after it is attached.\n        if (!pause) {\n          startConnectionP = _this11.connectToDeltaStream(connectionArgs);\n          startConnectionP.catch(error => {});\n        }\n        _this11._storageService = yield _this11.getDocumentStorageService();\n        _this11._attachState = AttachState.Attached;\n        // Fetch specified snapshot, but intentionally do not load from snapshot if specifiedVersion is null\n        const {\n          snapshot,\n          versionId\n        } = yield _this11.fetchSnapshotTree(specifiedVersion);\n        const attributes = yield _this11.getDocumentAttributes(_this11.storageService, snapshot);\n        // Attach op handlers to start processing ops\n        _this11.attachDeltaManagerOpHandler(attributes);\n        // ...load in the existing quorum\n        // Initialize the protocol handler\n        const protocolHandlerP = _this11.loadAndInitializeProtocolState(attributes, _this11.storageService, snapshot);\n        let loadDetailsP;\n        // Initialize document details - if loading a snapshot use that - otherwise we need to wait on\n        // the initial details\n        if (snapshot !== undefined) {\n          _this11._existing = true;\n          loadDetailsP = Promise.resolve();\n        } else {\n          if (startConnectionP === undefined) {\n            startConnectionP = _this11.connectToDeltaStream(connectionArgs);\n          }\n          // Intentionally don't .catch on this promise - we'll let any error throw below in the await.\n          loadDetailsP = startConnectionP.then(details => {\n            _this11._existing = details.existing;\n          });\n        }\n        // LoadContext directly requires protocolHandler to be ready, and eventually calls\n        // instantiateRuntime which will want to know existing state.  Wait for these promises to finish.\n        [_this11._protocolHandler] = yield Promise.all([protocolHandlerP, loadDetailsP]);\n        const codeDetails = _this11.getCodeDetailsFromQuorum();\n        yield _this11.loadContext(codeDetails, attributes, snapshot);\n        // Propagate current connection state through the system.\n        _this11.propagateConnectionState();\n        if (!pause) {\n          _this11.resume();\n        }\n        // Internal context is fully loaded at this point\n        _this11.loaded = true;\n        return {\n          existing: _this11._existing,\n          sequenceNumber: attributes.sequenceNumber,\n          version: versionId\n        };\n      })();\n    }\n    createDetached(source) {\n      var _this12 = this;\n      return _asyncToGenerator(function* () {\n        if (!isFluidCodeDetails(source)) {\n          _this12.logger.send({\n            eventName: \"DetachCreateNotIFluidCodeDetails\",\n            category: \"warning\"\n          });\n        }\n        const attributes = {\n          branch: \"\",\n          sequenceNumber: detachedContainerRefSeqNumber,\n          term: 1,\n          minimumSequenceNumber: 0\n        };\n        // Seed the base quorum to be an empty list with a code quorum set\n        const committedCodeProposal = {\n          key: \"code\",\n          value: source,\n          approvalSequenceNumber: 0,\n          commitSequenceNumber: 0,\n          sequenceNumber: 0\n        };\n        const members = [];\n        const proposals = [];\n        const values = [[\"code\", committedCodeProposal]];\n        _this12.attachDeltaManagerOpHandler(attributes);\n        // We know this is create detached flow without snapshot.\n        _this12._existing = false;\n        // Need to just seed the source data in the code quorum. Quorum itself is empty\n        _this12._protocolHandler = _this12.initializeProtocolState(attributes, members, proposals, values);\n        // The load context - given we seeded the quorum - will be great\n        yield _this12.createDetachedContext(attributes);\n        _this12.propagateConnectionState();\n        _this12.loaded = true;\n      })();\n    }\n    rehydrateDetachedFromSnapshot(snapshotTree) {\n      var _this13 = this;\n      return _asyncToGenerator(function* () {\n        const attributes = yield _this13.getDocumentAttributes(undefined, snapshotTree);\n        assert(attributes.sequenceNumber === 0, \"Seq number in detached container should be 0!!\");\n        _this13.attachDeltaManagerOpHandler(attributes);\n        // We know this is create detached flow with snapshot.\n        _this13._existing = true;\n        // ...load in the existing quorum\n        // Initialize the protocol handler\n        _this13._protocolHandler = yield _this13.loadAndInitializeProtocolState(attributes, undefined, snapshotTree);\n        yield _this13.createDetachedContext(attributes, snapshotTree);\n        _this13.loaded = true;\n        _this13.propagateConnectionState();\n      })();\n    }\n    getDocumentStorageService() {\n      var _this14 = this;\n      return _asyncToGenerator(function* () {\n        return _this14._deltaManager.connectToStorage();\n      })();\n    }\n    getDocumentAttributes(storage, tree) {\n      var _this15 = this;\n      return _asyncToGenerator(function* () {\n        if (tree === undefined) {\n          return {\n            branch: _this15.id,\n            minimumSequenceNumber: 0,\n            sequenceNumber: 0,\n            term: 1\n          };\n        }\n        // Back-compat: old docs would have \".attributes\" instead of \"attributes\"\n        const attributesHash = \".protocol\" in tree.trees ? tree.trees[\".protocol\"].blobs.attributes : tree.blobs[\".attributes\"];\n        const attributes = storage !== undefined ? yield readAndParse(storage, attributesHash) : readAndParseFromBlobs(tree.trees[\".protocol\"].blobs, attributesHash);\n        // Back-compat for older summaries with no term\n        if (attributes.term === undefined) {\n          attributes.term = 1;\n        }\n        return attributes;\n      })();\n    }\n    loadAndInitializeProtocolState(attributes, storage, snapshot) {\n      var _this16 = this;\n      return _asyncToGenerator(function* () {\n        let members = [];\n        let proposals = [];\n        let values = [];\n        if (snapshot !== undefined) {\n          const baseTree = \".protocol\" in snapshot.trees ? snapshot.trees[\".protocol\"] : snapshot;\n          if (storage !== undefined) {\n            [members, proposals, values] = yield Promise.all([readAndParse(storage, baseTree.blobs.quorumMembers), readAndParse(storage, baseTree.blobs.quorumProposals), readAndParse(storage, baseTree.blobs.quorumValues)]);\n          } else {\n            members = readAndParseFromBlobs(snapshot.trees[\".protocol\"].blobs, baseTree.blobs.quorumMembers);\n            proposals = readAndParseFromBlobs(snapshot.trees[\".protocol\"].blobs, baseTree.blobs.quorumProposals);\n            values = readAndParseFromBlobs(snapshot.trees[\".protocol\"].blobs, baseTree.blobs.quorumValues);\n          }\n        }\n        const protocolHandler = _this16.initializeProtocolState(attributes, members, proposals, values);\n        return protocolHandler;\n      })();\n    }\n    initializeProtocolState(attributes, members, proposals, values) {\n      const protocol = new ProtocolOpHandler(attributes.minimumSequenceNumber, attributes.sequenceNumber, attributes.term, members, proposals, values, (key, value) => this.submitMessage(MessageType.Propose, {\n        key,\n        value\n      }), sequenceNumber => this.submitMessage(MessageType.Reject, sequenceNumber));\n      const protocolLogger = ChildLogger.create(this.subLogger, \"ProtocolHandler\");\n      protocol.quorum.on(\"error\", error => {\n        protocolLogger.sendErrorEvent(error);\n      });\n      // Track membership changes and update connection state accordingly\n      protocol.quorum.on(\"addMember\", (clientId, details) => {\n        // This is the only one that requires the pending client ID\n        if (clientId === this.pendingClientId) {\n          this.setConnectionState(ConnectionState.Connected);\n        }\n      });\n      protocol.quorum.on(\"removeMember\", clientId => {\n        if (clientId === this._clientId) {\n          this._deltaManager.updateQuorumLeave();\n        }\n      });\n      protocol.quorum.on(\"addProposal\", proposal => {\n        if (proposal.key === \"code\" || proposal.key === \"code2\") {\n          this.emit(\"codeDetailsProposed\", proposal.value, proposal);\n        }\n      });\n      protocol.quorum.on(\"approveProposal\", (sequenceNumber, key, value) => {\n        debug(`approved ${key}`);\n        if (key === \"code\" || key === \"code2\") {\n          debug(`codeProposal ${JSON.stringify(value)}`);\n          if (!isFluidCodeDetails(value)) {\n            this.logger.send({\n              eventName: \"CodeProposalNotIFluidCodeDetails\",\n              category: \"warning\"\n            });\n          }\n          // eslint-disable-next-line @typescript-eslint/no-floating-promises\n          this.reloadContext();\n        }\n      });\n      return protocol;\n    }\n    captureProtocolSummary() {\n      const quorumSnapshot = this.protocolHandler.quorum.snapshot();\n      // Save attributes for the document\n      const documentAttributes = {\n        branch: this.id,\n        minimumSequenceNumber: this.protocolHandler.minimumSequenceNumber,\n        sequenceNumber: this.protocolHandler.sequenceNumber,\n        term: this.protocolHandler.term\n      };\n      const summary = {\n        tree: {\n          attributes: {\n            content: JSON.stringify(documentAttributes),\n            type: 2 /* Blob */\n          },\n\n          quorumMembers: {\n            content: JSON.stringify(quorumSnapshot.members),\n            type: 2 /* Blob */\n          },\n\n          quorumProposals: {\n            content: JSON.stringify(quorumSnapshot.proposals),\n            type: 2 /* Blob */\n          },\n\n          quorumValues: {\n            content: JSON.stringify(quorumSnapshot.values),\n            type: 2 /* Blob */\n          }\n        },\n\n        type: 1 /* Tree */\n      };\n\n      return summary;\n    }\n    getCodeDetailsFromQuorum() {\n      const quorum = this.protocolHandler.quorum;\n      let pkg = quorum.get(\"code\");\n      // Back compat\n      if (pkg === undefined) {\n        pkg = quorum.get(\"code2\");\n      }\n      return pkg;\n    }\n    get client() {\n      var _a, _b, _c;\n      const client = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.client) !== undefined ? this.options.client : {\n        details: {\n          capabilities: {\n            interactive: true\n          }\n        },\n        mode: \"read\",\n        permission: [],\n        scopes: [],\n        user: {\n          id: \"\"\n        }\n      };\n      // Client info from headers overrides client info from loader options\n      const headerClientDetails = (_c = (_b = this.originalRequest) === null || _b === void 0 ? void 0 : _b.headers) === null || _c === void 0 ? void 0 : _c[LoaderHeader.clientDetails];\n      if (headerClientDetails !== undefined) {\n        merge(client.details, headerClientDetails);\n      }\n      return client;\n    }\n    createDeltaManager() {\n      const deltaManager = new DeltaManager(() => this.service, this.client, ChildLogger.create(this.subLogger, \"DeltaManager\"), this._canReconnect);\n      deltaManager.on(\"connect\", (details, opsBehind) => {\n        var _a;\n        const oldState = this._connectionState;\n        this._connectionState = ConnectionState.Connecting;\n        // Stash the clientID to detect when transitioning from connecting (socket.io channel open) to connected\n        // (have received the join message for the client ID)\n        // This is especially important in the reconnect case. It's possible there could be outstanding\n        // ops sent by this client, so we should keep the old client id until we see our own client's\n        // join message. after we see the join message for out new connection with our new client id,\n        // we know there can no longer be outstanding ops that we sent with the previous client id.\n        this.pendingClientId = details.clientId;\n        this.emit(\"connect\", opsBehind);\n        // Report telemetry after we set client id!\n        this.logConnectionStateChangeTelemetry(ConnectionState.Connecting, oldState);\n        // Check if we already processed our own join op through delta storage!\n        // we are fetching ops from storage in parallel to connecting to ordering service\n        // Given async processes, it's possible that we have already processed our own join message before\n        // connection was fully established.\n        // Note that we might be still initializing quorum - connection is established proactively on load!\n        if (this._protocolHandler !== undefined && this._protocolHandler.quorum.has(details.clientId) || deltaManager.connectionMode === \"read\") {\n          this.setConnectionState(ConnectionState.Connected);\n        }\n        // Back-compat for new client and old server.\n        this._audience.clear();\n        for (const priorClient of (_a = details.initialClients, _a !== null && _a !== void 0 ? _a : [])) {\n          this._audience.addMember(priorClient.clientId, priorClient.client);\n        }\n      });\n      deltaManager.on(\"disconnect\", reason => {\n        this.manualReconnectInProgress = false;\n        this.setConnectionState(ConnectionState.Disconnected, reason);\n      });\n      deltaManager.on(\"throttled\", warning => {\n        this.raiseContainerWarning(warning);\n      });\n      deltaManager.on(\"readonly\", readonly => {\n        this.emit(\"readonly\", readonly);\n      });\n      return deltaManager;\n    }\n    attachDeltaManagerOpHandler(attributes) {\n      var _a;\n      this._deltaManager.on(\"closed\", error => {\n        this.close(error);\n      });\n      // If we're the outer frame, do we want to do this?\n      // Begin fetching any pending deltas once we know the base sequence #. Can this fail?\n      // It seems like something, like reconnection, that we would want to retry but otherwise allow\n      // the document to load\n      this._deltaManager.attachOpHandler(attributes.minimumSequenceNumber, attributes.sequenceNumber, (_a = attributes.term, _a !== null && _a !== void 0 ? _a : 1), {\n        process: message => this.processRemoteMessage(message),\n        processSignal: message => {\n          this.processSignal(message);\n        }\n      });\n    }\n    logConnectionStateChangeTelemetry(value, oldState, reason) {\n      // Log actual event\n      const time = performance.now();\n      this.connectionTransitionTimes[value] = time;\n      const duration = time - this.connectionTransitionTimes[oldState];\n      let durationFromDisconnected;\n      let connectionMode;\n      let connectionInitiationReason;\n      let autoReconnect;\n      let checkpointSequenceNumber;\n      let sequenceNumber;\n      let opsBehind;\n      if (value === ConnectionState.Disconnected) {\n        autoReconnect = this._deltaManager.reconnectMode;\n      } else {\n        connectionMode = this._deltaManager.connectionMode;\n        sequenceNumber = this.deltaManager.lastSequenceNumber;\n        if (value === ConnectionState.Connected) {\n          durationFromDisconnected = time - this.connectionTransitionTimes[ConnectionState.Disconnected];\n          durationFromDisconnected = TelemetryLogger.formatTick(durationFromDisconnected);\n        } else {\n          // This info is of most interest on establishing connection only.\n          checkpointSequenceNumber = this.deltaManager.lastKnownSeqNumber;\n          if (this.deltaManager.hasCheckpointSequenceNumber) {\n            opsBehind = checkpointSequenceNumber - sequenceNumber;\n          }\n        }\n        if (this.firstConnection) {\n          connectionInitiationReason = \"InitialConnect\";\n        } else if (this.manualReconnectInProgress) {\n          connectionInitiationReason = \"ManualReconnect\";\n        } else {\n          connectionInitiationReason = \"AutoReconnect\";\n        }\n      }\n      this.logger.sendPerformanceEvent({\n        eventName: `ConnectionStateChange_${ConnectionState[value]}`,\n        from: ConnectionState[oldState],\n        duration,\n        durationFromDisconnected,\n        reason,\n        connectionInitiationReason,\n        socketDocumentId: this._deltaManager.socketDocumentId,\n        pendingClientId: this.pendingClientId,\n        clientId: this.clientId,\n        connectionMode,\n        autoReconnect,\n        opsBehind,\n        online: OnlineStatus[isOnline()],\n        lastVisible: this.lastVisible !== undefined ? performance.now() - this.lastVisible : undefined,\n        checkpointSequenceNumber,\n        sequenceNumber\n      });\n      if (value === ConnectionState.Connected) {\n        this.firstConnection = false;\n        this.manualReconnectInProgress = false;\n      }\n    }\n    setConnectionState(value, reason) {\n      var _a;\n      assert(value !== ConnectionState.Connecting);\n      if (this.connectionState === value) {\n        // Already in the desired state - exit early\n        this.logger.sendErrorEvent({\n          eventName: \"setConnectionStateSame\",\n          value\n        });\n        return;\n      }\n      const oldState = this._connectionState;\n      this._connectionState = value;\n      if (value === ConnectionState.Connected) {\n        // Mark our old client should have left in the quorum if it's still there\n        if (this._clientId !== undefined) {\n          const client = (_a = this._protocolHandler) === null || _a === void 0 ? void 0 : _a.quorum.getMember(this._clientId);\n          if (client !== undefined) {\n            client.shouldHaveLeft = true;\n          }\n        }\n        this._clientId = this.pendingClientId;\n        this._deltaManager.updateQuorumJoin();\n      } else if (value === ConnectionState.Disconnected) {\n        // Important as we process our own joinSession message through delta request\n        this.pendingClientId = undefined;\n      }\n      if (this.loaded) {\n        this.propagateConnectionState();\n      }\n      // Report telemetry after we set client id!\n      this.logConnectionStateChangeTelemetry(value, oldState, reason);\n    }\n    propagateConnectionState() {\n      const logOpsOnReconnect = this._connectionState === ConnectionState.Connected && !this.firstConnection && this._deltaManager.connectionMode === \"write\";\n      if (logOpsOnReconnect) {\n        this.messageCountAfterDisconnection = 0;\n      }\n      const state = this._connectionState === ConnectionState.Connected;\n      if (!this.context.disposed) {\n        this.context.setConnectionState(state, this.clientId);\n      }\n      this.protocolHandler.quorum.setConnectionState(state, this.clientId);\n      raiseConnectedEvent(this.logger, this, state, this.clientId);\n      if (logOpsOnReconnect) {\n        this.logger.sendTelemetryEvent({\n          eventName: \"OpsSentOnReconnect\",\n          count: this.messageCountAfterDisconnection\n        });\n      }\n    }\n    submitContainerMessage(type, contents, batch, metadata) {\n      const outboundMessageType = type;\n      switch (outboundMessageType) {\n        case MessageType.Operation:\n        case MessageType.RemoteHelp:\n        case MessageType.Summarize:\n          break;\n        default:\n          this.close(CreateContainerError(`Runtime can't send arbitrary message type: ${type}`));\n          return -1;\n      }\n      return this.submitMessage(type, contents, batch, metadata);\n    }\n    submitMessage(type, contents, batch, metadata) {\n      if (this.connectionState !== ConnectionState.Connected) {\n        this.logger.sendErrorEvent({\n          eventName: \"SubmitMessageWithNoConnection\",\n          type\n        });\n        return -1;\n      }\n      this.messageCountAfterDisconnection += 1;\n      return this._deltaManager.submit(type, contents, batch, metadata);\n    }\n    processRemoteMessage(message) {\n      var _a;\n      // Check and report if we're getting messages from a clientId that we previously\n      // flagged as shouldHaveLeft, or from a client that's not in the quorum but should be\n      if (message.clientId != null) {\n        let errorMsg;\n        const client = this.getQuorum().getMember(message.clientId);\n        if (client === undefined && message.type !== MessageType.ClientJoin) {\n          errorMsg = \"messageClientIdMissingFromQuorum\";\n        } else if (((_a = client) === null || _a === void 0 ? void 0 : _a.shouldHaveLeft) === true) {\n          errorMsg = \"messageClientIdShouldHaveLeft\";\n        }\n        if (errorMsg !== undefined) {\n          const error = new GenericError(errorMsg, {\n            clientId: this._clientId,\n            messageClientId: message.clientId,\n            sequenceNumber: message.sequenceNumber,\n            clientSequenceNumber: message.clientSequenceNumber\n          });\n          this.close(CreateContainerError(error));\n        }\n      }\n      const local = this._clientId === message.clientId;\n      // Forward non system messages to the loaded runtime for processing\n      if (!isSystemMessage(message)) {\n        this.context.process(message, local, undefined);\n      }\n      // Allow the protocol handler to process the message\n      const result = this.protocolHandler.processMessage(message, local);\n      this.emit(\"op\", message);\n      return result;\n    }\n    submitSignal(message) {\n      this._deltaManager.submitSignal(JSON.stringify(message));\n    }\n    processSignal(message) {\n      // No clientId indicates a system signal message.\n      if (message.clientId === null) {\n        const innerContent = message.content;\n        if (innerContent.type === MessageType.ClientJoin) {\n          const newClient = innerContent.content;\n          this._audience.addMember(newClient.clientId, newClient.client);\n        } else if (innerContent.type === MessageType.ClientLeave) {\n          const leftClientId = innerContent.content;\n          this._audience.removeMember(leftClientId);\n        }\n      } else {\n        const local = this._clientId === message.clientId;\n        this.context.processSignal(message, local);\n      }\n    }\n    /**\n     * Get the most recent snapshot, or a specific version.\n     * @param specifiedVersion - The specific version of the snapshot to retrieve\n     * @returns The snapshot requested, or the latest snapshot if no version was specified, plus version ID\n     */\n    fetchSnapshotTree(specifiedVersion) {\n      var _this17 = this;\n      return _asyncToGenerator(function* () {\n        var _a, _b;\n        if (specifiedVersion === null) {\n          return {};\n        }\n        const version = yield _this17.getVersion(specifiedVersion !== null && specifiedVersion !== void 0 ? specifiedVersion : _this17.id);\n        if (version === undefined && specifiedVersion !== undefined) {\n          // We should have a defined version to load from if specified version requested\n          _this17.logger.sendErrorEvent({\n            eventName: \"NoVersionFoundWhenSpecified\",\n            id: specifiedVersion\n          });\n        }\n        _this17._loadedFromVersion = version;\n        const snapshot = (_a = yield _this17.storageService.getSnapshotTree(version), _a !== null && _a !== void 0 ? _a : undefined);\n        if (snapshot === undefined && version !== undefined) {\n          _this17.logger.sendErrorEvent({\n            eventName: \"getSnapshotTreeFailed\",\n            id: version.id\n          });\n        }\n        return {\n          snapshot,\n          versionId: (_b = version) === null || _b === void 0 ? void 0 : _b.id\n        };\n      })();\n    }\n    loadContext(codeDetails, attributes, snapshot, previousRuntimeState = {}) {\n      var _this18 = this;\n      return _asyncToGenerator(function* () {\n        var _a, _b;\n        assert(((_a = _this18._context) === null || _a === void 0 ? void 0 : _a.disposed) !== false, \"Existing context not disposed\");\n        // The relative loader will proxy requests to '/' to the loader itself assuming no non-cache flags\n        // are set. Global requests will still go directly to the loader\n        const loader = new RelativeLoader(_this18.loader, () => _this18.originalRequest);\n        const previousCodeDetails = (_b = _this18._context) === null || _b === void 0 ? void 0 : _b.codeDetails;\n        _this18._context = yield ContainerContext.createOrLoad(_this18, _this18.scope, _this18.codeLoader, codeDetails, snapshot, attributes, new DeltaManagerProxy(_this18._deltaManager), new QuorumProxy(_this18.protocolHandler.quorum), loader, warning => _this18.raiseContainerWarning(warning), (type, contents, batch, metadata) => _this18.submitContainerMessage(type, contents, batch, metadata), message => _this18.submitSignal(message), /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator(function* (message) {\n            return _this18.snapshot(message);\n          });\n          return function (_x3) {\n            return _ref3.apply(this, arguments);\n          };\n        }(), error => _this18.close(error), Container.version, previousRuntimeState);\n        loader.resolveContainer(_this18);\n        _this18.emit(\"contextChanged\", codeDetails, previousCodeDetails);\n      })();\n    }\n    /**\n     * Creates a new, unattached container context\n     */\n    createDetachedContext(attributes, snapshot) {\n      var _this19 = this;\n      return _asyncToGenerator(function* () {\n        const codeDetails = _this19.getCodeDetailsFromQuorum();\n        if (codeDetails === undefined) {\n          throw new Error(\"pkg should be provided in create flow!!\");\n        }\n        yield _this19.loadContext(codeDetails, attributes, snapshot);\n      })();\n    }\n    // Please avoid calling it directly.\n    // raiseContainerWarning() is the right flow for most cases\n    logContainerError(warning) {\n      this.logger.sendErrorEvent({\n        eventName: \"ContainerWarning\"\n      }, warning);\n    }\n  }\n  Container.version = \"^0.1.0\";\n  //# sourceMappingURL=container.js.map\n  return Container;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}