{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/* eslint-disable @typescript-eslint/consistent-type-assertions, max-len, no-bitwise, no-param-reassign, no-shadow */\nimport { assert, Trace } from \"@fluidframework/common-utils\";\nimport * as Collections from \"./collections\";\nimport { LocalClientId, NonCollabClient, TreeMaintenanceSequenceNumber, UnassignedSequenceNumber, UniversalSequenceNumber } from \"./constants\";\nimport { LocalReference, LocalReferenceCollection } from \"./localReference\";\nimport { TrackingGroupCollection } from \"./mergeTreeTracking\";\nimport * as ops from \"./ops\";\nimport { PartialSequenceLengths } from \"./partialLengths\";\nimport * as Properties from \"./properties\";\nimport { SegmentGroupCollection } from \"./segmentGroupCollection\";\nimport { SegmentPropertiesManager } from \"./segmentPropertiesManager\";\nexport class MergeNode {\n  isLeaf() {\n    return false;\n  }\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction addTile(tile, tiles) {\n  for (const tileLabel of tile.getTileLabels()) {\n    tiles[tileLabel] = tile;\n  }\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction addTileIfNotPresent(tile, tiles) {\n  for (const tileLabel of tile.getTileLabels()) {\n    if (tiles[tileLabel] === undefined) {\n      tiles[tileLabel] = tile;\n    }\n  }\n}\nfunction applyStackDelta(currentStackMap, deltaStackMap) {\n  // eslint-disable-next-line guard-for-in, no-restricted-syntax\n  for (const label in deltaStackMap) {\n    const deltaStack = deltaStackMap[label];\n    if (!deltaStack.empty()) {\n      let currentStack = currentStackMap[label];\n      if (currentStack === undefined) {\n        currentStack = new Collections.Stack();\n        currentStackMap[label] = currentStack;\n      }\n      for (const delta of deltaStack.items) {\n        applyRangeReference(currentStack, delta);\n      }\n    }\n  }\n}\nfunction applyRangeReference(stack, delta) {\n  if (delta.refType & ops.ReferenceType.NestBegin) {\n    stack.push(delta);\n    return true;\n  } else {\n    // Assume delta is end reference\n    const top = stack.top();\n    // TODO: match end with begin\n    if (top && top.refType & ops.ReferenceType.NestBegin) {\n      stack.pop();\n    } else {\n      stack.push(delta);\n    }\n    return false;\n  }\n}\nfunction addNodeReferences(mergeTree, node, rightmostTiles, leftmostTiles, rangeStacks) {\n  function updateRangeInfo(label, refPos) {\n    let stack = rangeStacks[label];\n    if (stack === undefined) {\n      stack = new Collections.Stack();\n      rangeStacks[label] = stack;\n    }\n    applyRangeReference(stack, refPos);\n  }\n  if (node.isLeaf()) {\n    const segment = node;\n    if (mergeTree.localNetLength(segment) > 0) {\n      if (Marker.is(segment)) {\n        const markerId = segment.getId();\n        // Also in insertMarker but need for reload segs case\n        // can add option for this only from reload segs\n        if (markerId) {\n          mergeTree.mapIdToSegment(markerId, segment);\n        }\n        if (segment.refType & ops.ReferenceType.Tile) {\n          addTile(segment, rightmostTiles);\n          addTileIfNotPresent(segment, leftmostTiles);\n        }\n        if (segment.refType & (ops.ReferenceType.NestBegin | ops.ReferenceType.NestEnd)) {\n          for (const label of segment.getRangeLabels()) {\n            updateRangeInfo(label, segment);\n          }\n        }\n      } else {\n        const baseSegment = node;\n        if (baseSegment.localRefs && baseSegment.localRefs.hierRefCount !== undefined && baseSegment.localRefs.hierRefCount > 0) {\n          for (const lref of baseSegment.localRefs) {\n            if (lref.refType & ops.ReferenceType.Tile) {\n              addTile(lref, rightmostTiles);\n              addTileIfNotPresent(lref, leftmostTiles);\n            }\n            if (lref.refType & (ops.ReferenceType.NestBegin | ops.ReferenceType.NestEnd)) {\n              for (const label of lref.getRangeLabels()) {\n                updateRangeInfo(label, lref);\n              }\n            }\n          }\n        }\n      }\n    }\n  } else {\n    const block = node;\n    applyStackDelta(rangeStacks, block.rangeStacks);\n    Properties.extend(rightmostTiles, block.rightmostTiles);\n    Properties.extendIfUndefined(leftmostTiles, block.leftmostTiles);\n  }\n}\nexport function ordinalToArray(ord) {\n  const a = [];\n  if (ord) {\n    for (let i = 0, len = ord.length; i < len; i++) {\n      a.push(ord.charCodeAt(i));\n    }\n  }\n  return a;\n}\n// Note that the actual branching factor of the MergeTree is `MaxNodesInBlock - 1`.  This is because\n// the MergeTree always inserts first, then checks for overflow and splits if the child count equals\n// `MaxNodesInBlock`.  (i.e., `MaxNodesInBlock` contains 1 extra slot for temporary storage to\n// facilitate splits.)\nexport const MaxNodesInBlock = 8;\nexport let MergeBlock = /*#__PURE__*/(() => {\n  class MergeBlock extends MergeNode {\n    constructor(childCount) {\n      super();\n      this.childCount = childCount;\n      this.children = new Array(MaxNodesInBlock);\n    }\n    hierBlock() {\n      return undefined;\n    }\n    setOrdinal(child, index) {\n      let childCount = this.childCount;\n      if (childCount === 8) {\n        childCount = 7;\n      }\n      assert(childCount >= 1 && childCount <= 7);\n      let localOrdinal;\n      const ordinalWidth = 1 << MaxNodesInBlock - (childCount + 1);\n      if (index === 0) {\n        localOrdinal = ordinalWidth - 1;\n      } else {\n        const prevOrd = this.children[index - 1].ordinal;\n        const prevOrdCode = prevOrd.charCodeAt(prevOrd.length - 1);\n        localOrdinal = prevOrdCode + ordinalWidth;\n      }\n      child.ordinal = this.ordinal + String.fromCharCode(localOrdinal);\n      if (MergeBlock.traceOrdinals) {\n        console.log(`so: prnt chld prev ${ordinalToArray(this.ordinal)} ${ordinalToArray(child.ordinal)} ${index > 0 ? ordinalToArray(this.children[index - 1].ordinal) : \"NA\"}`);\n      }\n      assert(child.ordinal.length === this.ordinal.length + 1);\n      if (index > 0) {\n        assert(child.ordinal > this.children[index - 1].ordinal);\n        // console.log(`${ordinalToArray(this.ordinal)} ${ordinalToArray(child.ordinal)} ${ordinalToArray(this.children[index - 1].ordinal)}`);\n        // console.log(`ord width ${ordinalWidth}`);\n      }\n    }\n\n    assignChild(child, index, updateOrdinal = true) {\n      child.parent = this;\n      child.index = index;\n      if (updateOrdinal) {\n        this.setOrdinal(child, index);\n      }\n      this.children[index] = child;\n    }\n  }\n  MergeBlock.traceOrdinals = false;\n  return MergeBlock;\n})();\nclass HierMergeBlock extends MergeBlock {\n  constructor(childCount) {\n    super(childCount);\n    this.rightmostTiles = Properties.createMap();\n    this.leftmostTiles = Properties.createMap();\n    this.rangeStacks = Properties.createMap();\n  }\n  addNodeReferences(mergeTree, node) {\n    addNodeReferences(mergeTree, node, this.rightmostTiles, this.leftmostTiles, this.rangeStacks);\n  }\n  hierBlock() {\n    return this;\n  }\n  hierToString(indentCount) {\n    let strbuf = \"\";\n    // eslint-disable-next-line guard-for-in, no-restricted-syntax\n    for (const key in this.rangeStacks) {\n      const stack = this.rangeStacks[key];\n      strbuf += internedSpaces(indentCount);\n      strbuf += `${key}: `;\n      for (const item of stack.items) {\n        strbuf += `${item.toString()} `;\n      }\n      strbuf += \"\\n\";\n    }\n    return strbuf;\n  }\n}\nfunction nodeTotalLength(mergeTree, node) {\n  if (!node.isLeaf()) {\n    return node.cachedLength;\n  }\n  return mergeTree.localNetLength(node);\n}\nexport class BaseSegment extends MergeNode {\n  constructor() {\n    super();\n    this.clientId = LocalClientId;\n    this.seq = UniversalSequenceNumber;\n    this.segmentGroups = new SegmentGroupCollection(this);\n    this.trackingCollection = new TrackingGroupCollection(this);\n  }\n  addProperties(newProps, op, seq, collabWindow) {\n    if (!this.propertyManager) {\n      this.propertyManager = new SegmentPropertiesManager(this);\n    }\n    return this.propertyManager.addProperties(newProps, op, seq, collabWindow);\n  }\n  hasProperty(key) {\n    return this.properties && this.properties[key] !== undefined;\n  }\n  isLeaf() {\n    return true;\n  }\n  cloneInto(b) {\n    b.clientId = this.clientId;\n    // TODO: deep clone properties\n    b.properties = Properties.clone(this.properties);\n    b.removedClientId = this.removedClientId;\n    // TODO: copy removed client overlap and branch removal info\n    b.removedSeq = this.removedSeq;\n    b.seq = this.seq;\n  }\n  canAppend(segment) {\n    return false;\n  }\n  addSerializedProps(jseg) {\n    if (this.properties) {\n      jseg.props = this.properties;\n    }\n  }\n  ack(segmentGroup, opArgs, mergeTree) {\n    const currentSegmentGroup = this.segmentGroups.dequeue();\n    assert(currentSegmentGroup === segmentGroup);\n    switch (opArgs.op.type) {\n      case 2 /* ANNOTATE */:\n        assert(!!this.propertyManager);\n        this.propertyManager.ackPendingProperties(opArgs.op);\n        return true;\n      case 0 /* INSERT */:\n        assert(this.seq === UnassignedSequenceNumber);\n        this.seq = opArgs.sequencedMessage.sequenceNumber;\n        this.localSeq = undefined;\n        return true;\n      case 1 /* REMOVE */:\n        const segBranchId = mergeTree.getBranchId(this.clientId);\n        const removalInfo = mergeTree.getRemovalInfo(mergeTree.localBranchId, segBranchId, this);\n        assert(!!removalInfo);\n        assert(!!removalInfo.removedSeq);\n        this.localRemovedSeq = undefined;\n        if (removalInfo.removedSeq === UnassignedSequenceNumber) {\n          removalInfo.removedSeq = opArgs.sequencedMessage.sequenceNumber;\n          return true;\n        }\n        if (MergeTree.diagOverlappingRemove) {\n          console.log(`grump @seq ${opArgs.sequencedMessage.sequenceNumber} ` + `cli ${glc(mergeTree, mergeTree.collabWindow.clientId)} ` + `from ${removalInfo.removedSeq} text ${mergeTree.toString()}`);\n        }\n        return false;\n      default:\n        throw new Error(`${opArgs.op.type} is in unrecognized operation type`);\n    }\n  }\n  splitAt(pos) {\n    if (pos > 0) {\n      const leafSegment = this.createSplitSegmentAt(pos);\n      if (leafSegment) {\n        if (this.propertyManager) {\n          this.propertyManager.copyTo(leafSegment);\n        }\n        leafSegment.parent = this.parent;\n        // Give the leaf a temporary yet valid ordinal.\n        // when this segment is put in the tree, it will get it's real ordinal,\n        // but this ordinal meets all the necessary invariants for now.\n        leafSegment.ordinal = this.ordinal + String.fromCharCode(0);\n        leafSegment.removedClientId = this.removedClientId;\n        leafSegment.removedSeq = this.removedSeq;\n        leafSegment.localRemovedSeq = this.localRemovedSeq;\n        if (this.removalsByBranch) {\n          leafSegment.removalsByBranch = [];\n          for (let i = 0, len = this.removalsByBranch.length; i < len; i++) {\n            const fromRemovalInfo = this.removalsByBranch[i];\n            if (fromRemovalInfo) {\n              leafSegment.removalsByBranch[i] = {\n                removedClientId: fromRemovalInfo.removedClientId,\n                removedSeq: fromRemovalInfo.removedSeq,\n                removedClientOverlap: fromRemovalInfo.removedClientOverlap ? [...fromRemovalInfo.removedClientOverlap] : undefined\n              };\n            }\n          }\n        }\n        leafSegment.seq = this.seq;\n        leafSegment.localSeq = this.localSeq;\n        leafSegment.clientId = this.clientId;\n        if (this.removedClientOverlap) {\n          leafSegment.removedClientOverlap = [...this.removedClientOverlap];\n        }\n        this.segmentGroups.copyTo(leafSegment);\n        this.trackingCollection.copyTo(leafSegment);\n        if (this.localRefs) {\n          this.localRefs.split(pos, leafSegment);\n        }\n      }\n      return leafSegment;\n    }\n  }\n}\nexport const reservedTileLabelsKey = \"referenceTileLabels\";\nexport const reservedRangeLabelsKey = \"referenceRangeLabels\";\nexport const reservedMarkerIdKey = \"markerId\";\nexport const reservedMarkerSimpleTypeKey = \"markerSimpleType\";\n// eslint-disable-next-line @typescript-eslint/no-unsafe-return\nexport const refHasTileLabels = refPos => refPos.refType & ops.ReferenceType.Tile && refPos.properties && refPos.properties[reservedTileLabelsKey];\n// eslint-disable-next-line @typescript-eslint/no-unsafe-return\nexport const refHasRangeLabels = refPos => refPos.refType & (ops.ReferenceType.NestBegin | ops.ReferenceType.NestEnd) && refPos.properties && refPos.properties[reservedRangeLabelsKey];\nexport function refHasTileLabel(refPos, label) {\n  if (refPos.hasTileLabels()) {\n    for (const refLabel of refPos.properties[reservedTileLabelsKey]) {\n      if (label === refLabel) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nexport function refHasRangeLabel(refPos, label) {\n  if (refPos.hasRangeLabels()) {\n    for (const refLabel of refPos.properties[reservedRangeLabelsKey]) {\n      if (label === refLabel) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nexport function refGetTileLabels(refPos) {\n  if (refPos.hasTileLabels()) {\n    return refPos.properties[reservedTileLabelsKey];\n  } else {\n    return [];\n  }\n}\nexport function refGetRangeLabels(refPos) {\n  if (refPos.hasRangeLabels()) {\n    return refPos.properties[reservedRangeLabelsKey];\n  } else {\n    return [];\n  }\n}\nexport let Marker = /*#__PURE__*/(() => {\n  class Marker extends BaseSegment {\n    constructor(refType) {\n      super();\n      this.refType = refType;\n      this.type = Marker.type;\n      this.cachedLength = 1;\n    }\n    static is(segment) {\n      return segment.type === Marker.type;\n    }\n    static make(refType, props) {\n      const marker = new Marker(refType);\n      if (props) {\n        marker.addProperties(props);\n      }\n      return marker;\n    }\n    toJSONObject() {\n      const obj = {\n        marker: {\n          refType: this.refType\n        }\n      };\n      super.addSerializedProps(obj);\n      return obj;\n    }\n    static fromJSONObject(spec) {\n      if (spec && typeof spec === \"object\" && \"marker\" in spec) {\n        return Marker.make(spec.marker.refType, spec.props);\n      }\n      return undefined;\n    }\n    clone() {\n      const b = Marker.make(this.refType, this.properties);\n      this.cloneInto(b);\n      return b;\n    }\n    getSegment() {\n      return this;\n    }\n    getOffset() {\n      return 0;\n    }\n    hasSimpleType(simpleTypeName) {\n      return this.hasProperty(reservedMarkerSimpleTypeKey) && this.properties[reservedMarkerSimpleTypeKey] === simpleTypeName;\n    }\n    getProperties() {\n      return this.properties;\n    }\n    getId() {\n      if (this.properties && this.properties[reservedMarkerIdKey]) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return this.properties[reservedMarkerIdKey];\n      }\n    }\n    hasTileLabels() {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return refHasTileLabels(this);\n    }\n    hasRangeLabels() {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return refHasRangeLabels(this);\n    }\n    hasTileLabel(label) {\n      return refHasTileLabel(this, label);\n    }\n    hasRangeLabel(label) {\n      return refHasRangeLabel(this, label);\n    }\n    getTileLabels() {\n      return refGetTileLabels(this);\n    }\n    getRangeLabels() {\n      return refGetRangeLabels(this);\n    }\n    toString() {\n      let bbuf = \"\";\n      if (this.refType & ops.ReferenceType.Tile) {\n        bbuf += \"Tile\";\n      }\n      if (this.refType & ops.ReferenceType.NestBegin) {\n        if (bbuf.length > 0) {\n          bbuf += \"; \";\n        }\n        bbuf += \"RangeBegin\";\n      }\n      if (this.refType & ops.ReferenceType.NestEnd) {\n        if (bbuf.length > 0) {\n          bbuf += \"; \";\n        }\n        bbuf += \"RangeEnd\";\n      }\n      let lbuf = \"\";\n      const id = this.getId();\n      if (id) {\n        bbuf += ` (${id}) `;\n      }\n      if (this.hasTileLabels()) {\n        lbuf += \"tile -- \";\n        const labels = this.properties[reservedTileLabelsKey];\n        for (let i = 0, len = labels.length; i < len; i++) {\n          const tileLabel = labels[i];\n          if (i > 0) {\n            lbuf += \"; \";\n          }\n          lbuf += tileLabel;\n        }\n      }\n      if (this.hasRangeLabels()) {\n        let rangeKind = \"begin\";\n        if (this.refType & ops.ReferenceType.NestEnd) {\n          rangeKind = \"end\";\n        }\n        if (this.hasTileLabels()) {\n          lbuf += \" \";\n        }\n        lbuf += `range ${rangeKind} -- `;\n        const labels = this.properties[reservedRangeLabelsKey];\n        for (let i = 0, len = labels.length; i < len; i++) {\n          const rangeLabel = labels[i];\n          if (i > 0) {\n            lbuf += \"; \";\n          }\n          lbuf += rangeLabel;\n        }\n      }\n      let pbuf = \"\";\n      if (this.properties) {\n        pbuf += JSON.stringify(this.properties, (key, value) => {\n          // Avoid circular reference when stringifying makers containing handles.\n          // (Substitute a debug string instead.)\n          const handle = !!value && value.IFluidHandle;\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n          return handle ? `#Handle(${handle.routeContext.path}/${handle.path})` : value;\n        });\n      }\n      return `M ${bbuf}: ${lbuf} ${pbuf}`;\n    }\n    createSplitSegmentAt(pos) {\n      return undefined;\n    }\n    canAppend(segment) {\n      return false;\n    }\n    append() {\n      throw new Error(\"Can not append to marker\");\n    }\n  }\n  Marker.type = \"Marker\";\n  return Marker;\n})();\nexport var IncrementalExecOp = /*#__PURE__*/(() => {\n  (function (IncrementalExecOp) {\n    IncrementalExecOp[IncrementalExecOp[\"Go\"] = 0] = \"Go\";\n    IncrementalExecOp[IncrementalExecOp[\"Stop\"] = 1] = \"Stop\";\n    IncrementalExecOp[IncrementalExecOp[\"Yield\"] = 2] = \"Yield\";\n  })(IncrementalExecOp || (IncrementalExecOp = {}));\n  return IncrementalExecOp;\n})();\nexport class IncrementalMapState {\n  constructor(block, actions, pos, refSeq, clientId, context, start, end, childIndex = 0) {\n    this.block = block;\n    this.actions = actions;\n    this.pos = pos;\n    this.refSeq = refSeq;\n    this.clientId = clientId;\n    this.context = context;\n    this.start = start;\n    this.end = end;\n    this.childIndex = childIndex;\n    this.op = IncrementalExecOp.Go;\n  }\n}\nexport class CollaborationWindow {\n  constructor() {\n    this.clientId = LocalClientId;\n    this.collaborating = false;\n    // Lowest-numbered segment in window; no client can reference a state before this one\n    this.minSeq = 0;\n    // Highest-numbered segment in window and current\n    // reference segment for this client\n    this.currentSeq = 0;\n    this.localSeq = 0;\n  }\n  loadFrom(a) {\n    this.clientId = a.clientId;\n    this.collaborating = a.collaborating;\n    this.minSeq = a.minSeq;\n    this.currentSeq = a.currentSeq;\n  }\n}\nexport const compareNumbers = (a, b) => a - b;\nexport const compareStrings = (a, b) => a.localeCompare(b);\nexport function clock() {\n  return Trace.start();\n}\nexport function elapsedMicroseconds(trace) {\n  return trace.trace().duration * 1000;\n}\nconst indentStrings = [\"\", \" \", \"  \"];\nexport function internedSpaces(n) {\n  if (indentStrings[n] === undefined) {\n    indentStrings[n] = \"\";\n    for (let i = 0; i < n; i++) {\n      indentStrings[n] += \" \";\n    }\n  }\n  return indentStrings[n];\n}\nexport class RegisterCollection {\n  constructor() {\n    this.clientCollections = Properties.createMap();\n    // TODO: snapshot\n  }\n\n  set(clientId, id, segments) {\n    if (!this.clientCollections[clientId]) {\n      this.clientCollections[clientId] = Properties.createMap();\n    }\n    this.clientCollections[clientId][id] = segments;\n  }\n  get(clientId, id) {\n    const clientCollection = this.clientCollections[clientId];\n    if (clientCollection) {\n      return clientCollection[id];\n    }\n  }\n  getLength(clientId, id) {\n    const segs = this.get(clientId, id);\n    let len = 0;\n    if (segs) {\n      for (const seg of segs) {\n        len += seg.cachedLength;\n      }\n    }\n    return len;\n  }\n  removeClient(clientId) {\n    this.clientCollections[clientId] = undefined;\n  }\n}\nexport const clientSeqComparer = {\n  min: {\n    refSeq: -1,\n    clientId: \"\"\n  },\n  compare: (a, b) => a.refSeq - b.refSeq\n};\nconst LRUSegmentComparer = {\n  min: {\n    maxSeq: -2\n  },\n  compare: (a, b) => a.maxSeq - b.maxSeq\n};\nexport function glc(mergeTree, id) {\n  if (mergeTree.getLongClientId) {\n    return mergeTree.getLongClientId(id);\n  } else {\n    return id.toString();\n  }\n}\nfunction applyLeafRangeMarker(marker, searchInfo) {\n  for (const rangeLabel of searchInfo.rangeLabels) {\n    if (marker.hasRangeLabel(rangeLabel)) {\n      let currentStack = searchInfo.stacks[rangeLabel];\n      if (currentStack === undefined) {\n        currentStack = new Collections.Stack();\n        searchInfo.stacks[rangeLabel] = currentStack;\n      }\n      applyRangeReference(currentStack, marker);\n    }\n  }\n}\nfunction recordRangeLeaf(segment, segpos, refSeq, clientId, start, end, searchInfo) {\n  if (Marker.is(segment)) {\n    if (segment.refType & (ops.ReferenceType.NestBegin | ops.ReferenceType.NestEnd)) {\n      applyLeafRangeMarker(segment, searchInfo);\n    }\n  }\n  return false;\n}\nfunction rangeShift(node, segpos, refSeq, clientId, offset, end, searchInfo) {\n  if (node.isLeaf()) {\n    const seg = node;\n    if (searchInfo.mergeTree.localNetLength(seg) > 0 && Marker.is(seg)) {\n      if (seg.refType & (ops.ReferenceType.NestBegin | ops.ReferenceType.NestEnd)) {\n        applyLeafRangeMarker(seg, searchInfo);\n      }\n    }\n  } else {\n    const block = node;\n    applyStackDelta(searchInfo.stacks, block.rangeStacks);\n  }\n  return true;\n}\nfunction recordTileStart(segment, segpos, refSeq, clientId, start, end, searchInfo) {\n  if (Marker.is(segment)) {\n    if (segment.hasTileLabel(searchInfo.tileLabel)) {\n      searchInfo.tile = segment;\n    }\n  }\n  return false;\n}\nfunction tileShift(node, segpos, refSeq, clientId, offset, end, searchInfo) {\n  if (node.isLeaf()) {\n    const seg = node;\n    if (searchInfo.mergeTree.localNetLength(seg) > 0 && Marker.is(seg)) {\n      if (seg.hasTileLabel(searchInfo.tileLabel)) {\n        searchInfo.tile = seg;\n      }\n    }\n  } else {\n    const block = node;\n    let marker;\n    if (searchInfo.posPrecedesTile) {\n      marker = block.rightmostTiles[searchInfo.tileLabel];\n    } else {\n      marker = block.leftmostTiles[searchInfo.tileLabel];\n    }\n    if (marker !== undefined) {\n      searchInfo.tile = marker;\n    }\n  }\n  return true;\n}\nconst minListenerComparer = {\n  min: {\n    minRequired: Number.MIN_VALUE\n  },\n  compare: (a, b) => a.minRequired - b.minRequired\n};\n// Represents a sequence of text segments\nexport let MergeTree = /*#__PURE__*/(() => {\n  class MergeTree {\n    // TODO: make and use interface describing options\n    constructor(options) {\n      this.options = options;\n      this.windowTime = 0;\n      this.packTime = 0;\n      this.ordTime = 0;\n      this.maxOrdTime = 0;\n      this.collabWindow = new CollaborationWindow();\n      // TODO: change this to ES6 map; add remove on segment remove\n      // for now assume only markers have ids and so point directly at the Segment\n      // if we need to have pointers to non-markers, we can change to point at local refs\n      this.idToSegment = Properties.createMap();\n      this.clientIdToBranchId = [];\n      this.localBranchId = 0;\n      this.minSeqPending = false;\n      this.splitLeafSegment = (segment, pos) => {\n        if (!(pos > 0)) {\n          return {};\n        }\n        const next = segment.splitAt(pos);\n        if (this.mergeTreeMaintenanceCallback) {\n          this.mergeTreeMaintenanceCallback({\n            operation: -2 /* SPLIT */,\n            deltaSegments: [{\n              segment\n            }, {\n              segment: next\n            }]\n          });\n        }\n        return {\n          next\n        };\n      };\n      this.blockUpdateActions = MergeTree.initBlockUpdateActions;\n      this.root = this.initialNode();\n    }\n    makeBlock(childCount) {\n      let block;\n      if (MergeTree.blockUpdateMarkers) {\n        block = new HierMergeBlock(childCount);\n      } else {\n        block = new MergeBlock(childCount);\n      }\n      block.ordinal = \"\";\n      return block;\n    }\n    initialNode() {\n      const block = this.makeBlock(0);\n      block.cachedLength = 0;\n      return block;\n    }\n    clone() {\n      const b = new MergeTree(this.options);\n      // For now assume that b will not collaborate\n      b.root = b.blockClone(this.root);\n    }\n    blockClone(block, segments) {\n      const bBlock = this.makeBlock(block.childCount);\n      for (let i = 0; i < block.childCount; i++) {\n        const child = block.children[i];\n        if (child.isLeaf()) {\n          const segment = this.segmentClone(child);\n          bBlock.assignChild(segment, i);\n          if (segments) {\n            segments.push(segment);\n          }\n        } else {\n          bBlock.assignChild(this.blockClone(child, segments), i);\n        }\n      }\n      this.nodeUpdateLengthNewStructure(bBlock);\n      this.nodeUpdateOrdinals(bBlock);\n      return bBlock;\n    }\n    segmentClone(segment) {\n      const b = segment.clone();\n      return b;\n    }\n    localNetLength(segment) {\n      const segBranchId = this.getBranchId(segment.clientId);\n      let removalInfo = segment;\n      if (this.localBranchId > segBranchId) {\n        removalInfo = this.getRemovalInfo(this.localBranchId, segBranchId, segment);\n      }\n      if (removalInfo.removedSeq !== undefined) {\n        return 0;\n      } else {\n        return segment.cachedLength;\n      }\n    }\n    getBranchId(clientId) {\n      if (this.clientIdToBranchId.length > clientId && clientId >= 0) {\n        return this.clientIdToBranchId[clientId];\n      } else if (clientId === LocalClientId) {\n        return 0;\n      } else {\n        return this.localBranchId;\n      }\n    }\n    // TODO: remove id when segment removed\n    mapIdToSegment(id, segment) {\n      this.idToSegment[id] = segment;\n    }\n    addNode(block, node) {\n      const index = block.childCount++;\n      block.assignChild(node, index, false);\n      return index;\n    }\n    reloadFromSegments(segments) {\n      // This code assumes that a later call to `startCollaboration()` will initialize partial lengths.\n      assert(!this.collabWindow.collaborating);\n      const maxChildren = MaxNodesInBlock - 1;\n      const measureReloadTime = false;\n      // Starting with the leaf segments, recursively builds the B-Tree layer by layer from the bottom up.\n      const buildMergeBlock = nodes => {\n        const blockCount = Math.ceil(nodes.length / maxChildren); // Compute # blocks require for this level of B-Tree\n        const blocks = new Array(blockCount); // Pre-alloc array to collect nodes\n        // For each block in this level of the B-Tree...\n        for (let nodeIndex = 0, blockIndex = 0;\n        // Start with the first block and first node\n        blockIndex < blockCount;\n        // If we have more blocks, we also have more nodes to insert\n        blockIndex++ // Advance to next block in this layer.\n        ) {\n          const block = blocks[blockIndex] = this.makeBlock(0);\n          // For each child of the current block, insert a node (while we have nodes left)\n          // and update the block's info.\n          for (let childIndex = 0; childIndex < maxChildren && nodeIndex < nodes.length;\n          // While we still have children & nodes left\n          childIndex++, nodeIndex++ // Advance to next child & node\n          ) {\n            // Insert the next node into the current block\n            this.addNode(block, nodes[nodeIndex]);\n          }\n          // Calculate this block's info.  Previously this was inlined into the above loop as a micro-optimization,\n          // but it turns out to be negligible in practice since `reloadFromSegments()` is only invoked for the\n          // snapshot header.  The bulk of the segments in long documents are inserted via `insertSegments()`.\n          this.blockUpdate(block);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return blocks.length === 1 // If there is only one block at this layer...\n        ? blocks[0] // ...then we're done.  Return the root.\n        : buildMergeBlock(blocks); // ...otherwise recursively build the next layer above blocks.\n      };\n\n      let clockStart;\n      if (measureReloadTime) {\n        clockStart = clock();\n      }\n      if (segments.length > 0) {\n        this.root = buildMergeBlock(segments);\n        this.nodeUpdateOrdinals(this.root);\n      } else {\n        this.root = this.makeBlock(0);\n        this.root.cachedLength = 0;\n      }\n      this.root.index = 0;\n      if (measureReloadTime) {\n        console.log(`reload time ${elapsedMicroseconds(clockStart)}`);\n      }\n    }\n    // For now assume min starts at zero\n    startCollaboration(localClientId, minSeq, currentSeq, branchId) {\n      this.collabWindow.clientId = localClientId;\n      this.collabWindow.minSeq = minSeq;\n      this.collabWindow.collaborating = true;\n      this.collabWindow.currentSeq = currentSeq;\n      this.localBranchId = branchId;\n      this.segmentsToScour = new Collections.Heap([], LRUSegmentComparer);\n      this.pendingSegments = Collections.ListMakeHead();\n      const measureFullCollab = false;\n      let clockStart;\n      if (measureFullCollab) {\n        clockStart = clock();\n      }\n      this.nodeUpdateLengthNewStructure(this.root, true);\n      if (measureFullCollab) {\n        console.log(`update partial lengths at start ${elapsedMicroseconds(clockStart)}`);\n      }\n    }\n    addToLRUSet(segment, seq) {\n      // If the parent node has not yet been marked for scour (i.e., needsScour is not false or undefined),\n      // add the segment and mark the mark the node now.\n      // TODO: 'seq' may be less than the current sequence number when inserting pre-ACKed\n      //       segments from a snapshot.  We currently skip these for now.\n      if (segment.parent.needsScour !== true && seq > this.collabWindow.currentSeq) {\n        segment.parent.needsScour = true;\n        this.segmentsToScour.add({\n          segment,\n          maxSeq: seq\n        });\n      }\n    }\n    underflow(node) {\n      return node.childCount < MaxNodesInBlock / 2;\n    }\n    scourNode(node, holdNodes) {\n      let prevSegment;\n      for (let k = 0; k < node.childCount; k++) {\n        const childNode = node.children[k];\n        if (childNode.isLeaf()) {\n          const segment = childNode;\n          if (segment.segmentGroups.empty) {\n            if (segment.removedSeq !== undefined) {\n              const createBrid = this.getBranchId(segment.clientId);\n              const removeBrid = this.getBranchId(segment.removedClientId);\n              if (removeBrid !== createBrid || segment.removedSeq > this.collabWindow.minSeq) {\n                holdNodes.push(segment);\n              } else if (!segment.trackingCollection.empty) {\n                holdNodes.push(segment);\n              } else {\n                if (MergeTree.traceZRemove) {\n                  // eslint-disable-next-line dot-notation\n                  console.log(`${this.getLongClientId(this.collabWindow.clientId)}: Zremove ${segment[\"text\"]}; cli ${this.getLongClientId(segment.clientId)}`);\n                }\n                // Notify maintenance event observers that the segment is being unlinked from the MergeTree.\n                if (this.mergeTreeMaintenanceCallback) {\n                  this.mergeTreeMaintenanceCallback({\n                    operation: -3 /* UNLINK */,\n                    deltaSegments: [{\n                      segment\n                    }]\n                  });\n                }\n                segment.parent = undefined;\n              }\n              prevSegment = undefined;\n            } else {\n              if (segment.seq <= this.collabWindow.minSeq) {\n                const canAppend = prevSegment && prevSegment.canAppend(segment) && Properties.matchProperties(prevSegment.properties, segment.properties) && prevSegment.trackingCollection.matches(segment.trackingCollection) && this.getBranchId(prevSegment.clientId) === this.getBranchId(segment.clientId) && this.localNetLength(segment) > 0;\n                if (canAppend) {\n                  if (MergeTree.traceAppend) {\n                    // eslint-disable-next-line dot-notation\n                    console.log(`${this.getLongClientId(this.collabWindow.clientId)}: append ${prevSegment[\"text\"]} + ${segment[\"text\"]}; cli ${this.getLongClientId(prevSegment.clientId)} + cli ${this.getLongClientId(segment.clientId)}`);\n                  }\n                  prevSegment.append(segment);\n                  if (this.mergeTreeMaintenanceCallback) {\n                    this.mergeTreeMaintenanceCallback({\n                      operation: -1 /* APPEND */,\n                      deltaSegments: [{\n                        segment: prevSegment\n                      }, {\n                        segment\n                      }]\n                    });\n                  }\n                  segment.parent = undefined;\n                  segment.trackingCollection.trackingGroups.forEach(tg => tg.unlink(segment));\n                } else {\n                  holdNodes.push(segment);\n                  if (this.localNetLength(segment) > 0) {\n                    prevSegment = segment;\n                  } else {\n                    prevSegment = undefined;\n                  }\n                }\n              } else {\n                holdNodes.push(segment);\n                prevSegment = undefined;\n              }\n            }\n          } else {\n            holdNodes.push(segment);\n            prevSegment = undefined;\n          }\n        } else {\n          holdNodes.push(childNode);\n          prevSegment = undefined;\n        }\n      }\n    }\n    // Interior node with all node children\n    pack(block) {\n      const parent = block.parent;\n      const children = parent.children;\n      let childIndex;\n      let childBlock;\n      const holdNodes = [];\n      for (childIndex = 0; childIndex < parent.childCount; childIndex++) {\n        // Debug assert not isLeaf()\n        childBlock = children[childIndex];\n        this.scourNode(childBlock, holdNodes);\n        // Will replace this block with a packed block\n        childBlock.parent = undefined;\n      }\n      const totalNodeCount = holdNodes.length;\n      const halfCount = MaxNodesInBlock / 2;\n      let childCount = Math.min(MaxNodesInBlock - 1, Math.floor(totalNodeCount / halfCount));\n      if (childCount < 1) {\n        childCount = 1;\n      }\n      const baseCount = Math.floor(totalNodeCount / childCount);\n      let extraCount = totalNodeCount % childCount;\n      const packedBlocks = new Array(MaxNodesInBlock);\n      let readCount = 0;\n      for (let nodeIndex = 0; nodeIndex < childCount; nodeIndex++) {\n        let nodeCount = baseCount;\n        if (extraCount > 0) {\n          nodeCount++;\n          extraCount--;\n        }\n        const packedBlock = this.makeBlock(nodeCount);\n        for (let packedNodeIndex = 0; packedNodeIndex < nodeCount; packedNodeIndex++) {\n          const nodeToPack = holdNodes[readCount++];\n          packedBlock.assignChild(nodeToPack, packedNodeIndex, false);\n        }\n        packedBlock.parent = parent;\n        packedBlocks[nodeIndex] = packedBlock;\n        this.nodeUpdateLengthNewStructure(packedBlock);\n      }\n      if (readCount !== totalNodeCount) {\n        console.log(`total count ${totalNodeCount} readCount ${readCount}`);\n      }\n      parent.children = packedBlocks;\n      for (let j = 0; j < childCount; j++) {\n        parent.assignChild(packedBlocks[j], j, false);\n      }\n      parent.childCount = childCount;\n      if (this.underflow(parent) && parent.parent) {\n        this.pack(parent);\n      } else {\n        this.nodeUpdateOrdinals(parent);\n        this.blockUpdatePathLengths(parent, UnassignedSequenceNumber, -1, true);\n      }\n    }\n    zamboniSegments(zamboniSegmentsMaxCount = MergeTree.zamboniSegmentsMaxCount) {\n      if (!this.collabWindow.collaborating) {\n        return;\n      }\n      let clockStart;\n      if (MergeTree.options.measureWindowTime) {\n        clockStart = clock();\n      }\n      for (let i = 0; i < zamboniSegmentsMaxCount; i++) {\n        let segmentToScour = this.segmentsToScour.peek();\n        if (!segmentToScour || segmentToScour.maxSeq > this.collabWindow.minSeq) {\n          break;\n        }\n        segmentToScour = this.segmentsToScour.get();\n        // Only skip scouring if needs scour is explicitly false, not true or undefined\n        if (segmentToScour.segment.parent && segmentToScour.segment.parent.needsScour !== false) {\n          const block = segmentToScour.segment.parent;\n          const childrenCopy = [];\n          // console.log(`scouring from ${segmentToScour.segment.seq}`);\n          this.scourNode(block, childrenCopy);\n          // This will avoid the cost of re-scouring nodes\n          // that have recently been scoured\n          block.needsScour = false;\n          const newChildCount = childrenCopy.length;\n          if (newChildCount < block.childCount) {\n            block.childCount = newChildCount;\n            block.children = childrenCopy;\n            for (let j = 0; j < newChildCount; j++) {\n              block.assignChild(childrenCopy[j], j, false);\n            }\n            if (this.underflow(block) && block.parent) {\n              // nodeUpdatePathLengths(node, UnassignedSequenceNumber, -1, true);\n              let packClockStart;\n              if (MergeTree.options.measureWindowTime) {\n                packClockStart = clock();\n              }\n              this.pack(block);\n              if (MergeTree.options.measureWindowTime) {\n                this.packTime += elapsedMicroseconds(packClockStart);\n              }\n            } else {\n              this.nodeUpdateOrdinals(block);\n              this.blockUpdatePathLengths(block, UnassignedSequenceNumber, -1, true);\n            }\n          }\n        }\n      }\n      if (MergeTree.options.measureWindowTime) {\n        this.windowTime += elapsedMicroseconds(clockStart);\n      }\n    }\n    getCollabWindow() {\n      return this.collabWindow;\n    }\n    getStats() {\n      const nodeGetStats = block => {\n        const stats = {\n          maxHeight: 0,\n          nodeCount: 0,\n          leafCount: 0,\n          removedLeafCount: 0,\n          liveCount: 0,\n          histo: []\n        };\n        for (let k = 0; k < MaxNodesInBlock; k++) {\n          stats.histo[k] = 0;\n        }\n        for (let i = 0; i < block.childCount; i++) {\n          const child = block.children[i];\n          let height = 1;\n          if (!child.isLeaf()) {\n            const childStats = nodeGetStats(child);\n            height = 1 + childStats.maxHeight;\n            stats.nodeCount += childStats.nodeCount;\n            stats.leafCount += childStats.leafCount;\n            stats.removedLeafCount += childStats.removedLeafCount;\n            stats.liveCount += childStats.liveCount;\n            for (let i = 0; i < MaxNodesInBlock; i++) {\n              stats.histo[i] += childStats.histo[i];\n            }\n          } else {\n            stats.leafCount++;\n            const segment = child;\n            if (segment.removedSeq !== undefined) {\n              stats.removedLeafCount++;\n            }\n          }\n          if (height > stats.maxHeight) {\n            stats.maxHeight = height;\n          }\n        }\n        stats.histo[block.childCount]++;\n        stats.nodeCount++;\n        stats.liveCount += block.childCount;\n        return stats;\n      };\n      const rootStats = nodeGetStats(this.root);\n      if (MergeTree.options.measureWindowTime) {\n        rootStats.windowTime = this.windowTime;\n        rootStats.packTime = this.packTime;\n        rootStats.ordTime = this.ordTime;\n        rootStats.maxOrdTime = this.maxOrdTime;\n      }\n      return rootStats;\n    }\n    findHistorialPosition(pos, fromSeq, toSeq, clientId) {\n      return this.findHistorialPositionFromClient(pos, fromSeq, toSeq, clientId);\n    }\n    findHistorialPositionFromClient(pos, fromSeq, toSeq, clientId) {\n      assert(fromSeq < toSeq);\n      if (pos < this.getLength(fromSeq, clientId)) {\n        assert(toSeq <= this.collabWindow.currentSeq);\n        const segoff = this.getContainingSegment(pos, fromSeq, clientId);\n        assert(segoff.segment !== undefined);\n        const toPos = this.getPosition(segoff.segment, toSeq, clientId);\n        const ret = toPos + segoff.offset;\n        assert(ret !== undefined);\n        return ret;\n      } else {\n        return pos;\n      }\n    }\n    findHistorialRangeFromClient(rangeStart, rangeEnd, fromSeq, toSeq, clientId) {\n      const ranges = [];\n      const recordRange = (segment, pos, refSeq, clientId, segStart, segEnd) => {\n        if (this.nodeLength(segment, toSeq, clientId) > 0) {\n          const position = this.getPosition(segment, toSeq, clientId);\n          if (segStart < 0) {\n            segStart = 0;\n          }\n          if (segEnd > segment.cachedLength) {\n            segEnd = segment.cachedLength;\n          }\n          ranges.push({\n            start: position + segStart,\n            end: position + segEnd\n          });\n        }\n        return true;\n      };\n      this.mapRange({\n        leaf: recordRange\n      }, fromSeq, clientId, undefined, rangeStart, rangeEnd);\n      return ranges;\n    }\n    findHistorialRange(rangeStart, rangeEnd, fromSeq, toSeq, clientId) {\n      return this.findHistorialRangeFromClient(rangeStart, rangeEnd, fromSeq, toSeq, clientId);\n    }\n    getLength(refSeq, clientId) {\n      return this.blockLength(this.root, refSeq, clientId);\n    }\n    /**\n     * Returns the current length of the MergeTree for the local client.\n     */\n    get length() {\n      return this.root.cachedLength;\n    }\n    getPosition(node, refSeq, clientId) {\n      let totalOffset = 0;\n      let parent = node.parent;\n      let prevParent;\n      while (parent) {\n        const children = parent.children;\n        for (let childIndex = 0; childIndex < parent.childCount; childIndex++) {\n          const child = children[childIndex];\n          if (prevParent && child === prevParent || child === node) {\n            break;\n          }\n          totalOffset += this.nodeLength(child, refSeq, clientId);\n        }\n        prevParent = parent;\n        parent = parent.parent;\n      }\n      return totalOffset;\n    }\n    cloneSegments(refSeq, clientId, start = 0, end) {\n      const gatherSegment = (segment, pos, refSeq, clientId, start, end, accumSegments) => {\n        accumSegments.segments.push(segment.clone());\n        return true;\n      };\n      if (end === undefined) {\n        end = this.blockLength(this.root, refSeq, clientId);\n      }\n      const accum = {\n        segments: []\n      };\n      this.mapRange({\n        leaf: gatherSegment\n      }, refSeq, clientId, accum, start, end);\n      return accum.segments;\n    }\n    getContainingSegment(pos, refSeq, clientId) {\n      let segment;\n      let offset;\n      const leaf = (leafSeg, segpos, refSeq, clientId, start) => {\n        segment = leafSeg;\n        offset = start;\n        return false;\n      };\n      this.searchBlock(this.root, pos, 0, refSeq, clientId, {\n        leaf\n      });\n      return {\n        segment,\n        offset\n      };\n    }\n    blockLength(node, refSeq, clientId) {\n      if (this.collabWindow.collaborating && clientId !== this.collabWindow.clientId) {\n        return node.partialLengths.getPartialLength(this, refSeq, clientId);\n      } else {\n        return node.cachedLength;\n      }\n    }\n    getRemovalInfo(branchId, segBranchId, segment) {\n      if (branchId > segBranchId) {\n        const index = branchId - segBranchId - 1;\n        if (!segment.removalsByBranch) {\n          segment.removalsByBranch = [];\n        }\n        if (!segment.removalsByBranch[index]) {\n          segment.removalsByBranch[index] = {};\n        }\n        return segment.removalsByBranch[index];\n      } else {\n        return segment;\n      }\n    }\n    nodeLength(node, refSeq, clientId) {\n      if (!this.collabWindow.collaborating || this.collabWindow.clientId === clientId) {\n        // Local client sees all segments, even when collaborating\n        if (!node.isLeaf()) {\n          return node.cachedLength;\n        } else {\n          return this.localNetLength(node);\n        }\n      } else {\n        // Sequence number within window\n        const branchId = this.getBranchId(clientId);\n        if (!node.isLeaf()) {\n          return node.partialLengths.getPartialLength(this, refSeq, clientId);\n        } else {\n          const segment = node;\n          const segBranchId = this.getBranchId(segment.clientId);\n          if (segBranchId <= branchId && (segment.clientId === clientId || segment.seq !== UnassignedSequenceNumber && segment.seq <= refSeq)) {\n            let removalInfo = segment;\n            if (branchId > segBranchId) {\n              removalInfo = this.getRemovalInfo(branchId, segBranchId, segment);\n            }\n            // Segment happened by reference sequence number or segment from requesting client\n            if (removalInfo.removedSeq !== undefined) {\n              if (removalInfo.removedClientId === clientId || removalInfo.removedClientOverlap && removalInfo.removedClientOverlap.includes(clientId) || removalInfo.removedSeq !== UnassignedSequenceNumber && removalInfo.removedSeq <= refSeq) {\n                return 0;\n              } else {\n                return segment.cachedLength;\n              }\n            } else {\n              return segment.cachedLength;\n            }\n          } else {\n            // Segment invisible to client at reference sequence number/branch id/client id of op\n            return 0;\n          }\n        }\n      }\n    }\n    addMinSeqListener(minRequired, onMinGE) {\n      if (!this.minSeqListeners) {\n        this.minSeqListeners = new Collections.Heap([], minListenerComparer);\n      }\n      this.minSeqListeners.add({\n        minRequired,\n        onMinGE\n      });\n    }\n    notifyMinSeqListeners() {\n      this.minSeqPending = false;\n      while (this.minSeqListeners.count() > 0 && this.minSeqListeners.peek().minRequired <= this.collabWindow.minSeq) {\n        const minListener = this.minSeqListeners.get();\n        minListener.onMinGE(this.collabWindow.minSeq);\n      }\n    }\n    setMinSeq(minSeq) {\n      assert(minSeq <= this.collabWindow.currentSeq);\n      // Only move forward\n      assert(this.collabWindow.minSeq <= minSeq);\n      if (minSeq > this.collabWindow.minSeq) {\n        this.collabWindow.minSeq = minSeq;\n        if (MergeTree.options.zamboniSegments) {\n          this.zamboniSegments();\n        }\n        if (this.minSeqListeners && this.minSeqListeners.count()) {\n          this.minSeqPending = true;\n        }\n        if (this.minSeqPending) {\n          this.notifyMinSeqListeners();\n        }\n      }\n    }\n    referencePositionToLocalPosition(refPos, refSeq = this.collabWindow.currentSeq, clientId = this.collabWindow.clientId) {\n      const seg = refPos.getSegment();\n      if (seg && seg.parent) {\n        const offset = !seg.removedSeq ? refPos.getOffset() : 0;\n        return offset + this.getPosition(seg, refSeq, clientId);\n      }\n      return LocalReference.DetachedPosition;\n    }\n    getStackContext(startPos, clientId, rangeLabels) {\n      const searchInfo = {\n        mergeTree: this,\n        stacks: Properties.createMap(),\n        rangeLabels\n      };\n      this.search(startPos, UniversalSequenceNumber, clientId, {\n        leaf: recordRangeLeaf,\n        shift: rangeShift\n      }, searchInfo);\n      return searchInfo.stacks;\n    }\n    // TODO: filter function\n    findTile(startPos, clientId, tileLabel, posPrecedesTile = true) {\n      const searchInfo = {\n        mergeTree: this,\n        posPrecedesTile,\n        tileLabel\n      };\n      if (posPrecedesTile) {\n        this.search(startPos, UniversalSequenceNumber, clientId, {\n          leaf: recordTileStart,\n          shift: tileShift\n        }, searchInfo);\n      } else {\n        this.backwardSearch(startPos, UniversalSequenceNumber, clientId, {\n          leaf: recordTileStart,\n          shift: tileShift\n        }, searchInfo);\n      }\n      if (searchInfo.tile) {\n        let pos;\n        if (searchInfo.tile.isLeaf()) {\n          const marker = searchInfo.tile;\n          pos = this.getPosition(marker, UniversalSequenceNumber, clientId);\n        } else {\n          const localRef = searchInfo.tile;\n          pos = localRef.toPosition();\n        }\n        return {\n          tile: searchInfo.tile,\n          pos\n        };\n      }\n    }\n    search(pos, refSeq, clientId, actions, clientData) {\n      return this.searchBlock(this.root, pos, 0, refSeq, clientId, actions, clientData);\n    }\n    searchBlock(block, pos, segpos, refSeq, clientId, actions, clientData) {\n      const children = block.children;\n      if (actions && actions.pre) {\n        actions.pre(block, segpos, refSeq, clientId, undefined, undefined, clientData);\n      }\n      const contains = actions && actions.contains;\n      for (let childIndex = 0; childIndex < block.childCount; childIndex++) {\n        const child = children[childIndex];\n        const len = this.nodeLength(child, refSeq, clientId);\n        if (!contains && pos < len || contains && contains(child, pos, refSeq, clientId, undefined, undefined, clientData)) {\n          // Found entry containing pos\n          if (!child.isLeaf()) {\n            return this.searchBlock(child, pos, segpos, refSeq, clientId, actions, clientData);\n          } else {\n            if (actions && actions.leaf) {\n              actions.leaf(child, segpos, refSeq, clientId, pos, -1, clientData);\n            }\n            return child;\n          }\n        } else {\n          if (actions && actions.shift) {\n            actions.shift(child, segpos, refSeq, clientId, pos, undefined, clientData);\n          }\n          pos -= len;\n          segpos += len;\n        }\n      }\n      if (actions && actions.post) {\n        actions.post(block, segpos, refSeq, clientId, undefined, undefined, clientData);\n      }\n    }\n    backwardSearch(pos, refSeq, clientId, actions, clientData) {\n      const len = this.getLength(refSeq, clientId);\n      if (pos > len) {\n        return undefined;\n      }\n      return this.backwardSearchBlock(this.root, pos, len, refSeq, clientId, actions, clientData);\n    }\n    backwardSearchBlock(block, pos, segEnd, refSeq, clientId, actions, clientData) {\n      const children = block.children;\n      if (actions && actions.pre) {\n        actions.pre(block, segEnd, refSeq, clientId, undefined, undefined, clientData);\n      }\n      const contains = actions && actions.contains;\n      for (let childIndex = block.childCount - 1; childIndex >= 0; childIndex--) {\n        const child = children[childIndex];\n        const len = this.nodeLength(child, refSeq, clientId);\n        const segpos = segEnd - len;\n        if (!contains && pos >= segpos || contains && contains(child, pos, refSeq, clientId, undefined, undefined, clientData)) {\n          // Found entry containing pos\n          if (!child.isLeaf()) {\n            return this.backwardSearchBlock(child, pos, segEnd, refSeq, clientId, actions, clientData);\n          } else {\n            if (actions && actions.leaf) {\n              actions.leaf(child, segpos, refSeq, clientId, pos, -1, clientData);\n            }\n            return child;\n          }\n        } else {\n          if (actions && actions.shift) {\n            actions.shift(child, segpos, refSeq, clientId, pos, undefined, clientData);\n          }\n          segEnd = segpos;\n        }\n      }\n      if (actions && actions.post) {\n        actions.post(block, segEnd, refSeq, clientId, undefined, undefined, clientData);\n      }\n    }\n    updateRoot(splitNode) {\n      if (splitNode !== undefined) {\n        const newRoot = this.makeBlock(2);\n        newRoot.index = 0;\n        newRoot.ordinal = \"\";\n        newRoot.assignChild(this.root, 0, false);\n        newRoot.assignChild(splitNode, 1, false);\n        this.root = newRoot;\n        this.nodeUpdateOrdinals(this.root);\n        this.nodeUpdateLengthNewStructure(this.root);\n      }\n    }\n    /**\n     * Assign sequence number to existing segment; update partial lengths to reflect the change\n     * @param seq - sequence number given by server to pending segment\n     */\n    ackPendingSegment(opArgs, verboseOps = false) {\n      const seq = opArgs.sequencedMessage.sequenceNumber;\n      const pendingSegmentGroup = this.pendingSegments.dequeue();\n      const nodesToUpdate = [];\n      let overwrite = false;\n      if (pendingSegmentGroup !== undefined) {\n        if (verboseOps) {\n          console.log(`segment group has ${pendingSegmentGroup.segments.length} segments`);\n        }\n        pendingSegmentGroup.segments.map(pendingSegment => {\n          overwrite = !pendingSegment.ack(pendingSegmentGroup, opArgs, this) || overwrite;\n          if (MergeTree.options.zamboniSegments) {\n            this.addToLRUSet(pendingSegment, seq);\n          }\n          if (!nodesToUpdate.includes(pendingSegment.parent)) {\n            nodesToUpdate.push(pendingSegment.parent);\n          }\n        });\n        const clientId = this.collabWindow.clientId;\n        for (const node of nodesToUpdate) {\n          this.blockUpdatePathLengths(node, seq, clientId, overwrite);\n          // NodeUpdatePathLengths(node, seq, clientId, true);\n        }\n      }\n\n      if (MergeTree.options.zamboniSegments) {\n        this.zamboniSegments();\n      }\n    }\n    addToPendingList(segment, segmentGroup, localSeq) {\n      if (segmentGroup === undefined) {\n        segmentGroup = {\n          segments: [],\n          localSeq\n        };\n        this.pendingSegments.enqueue(segmentGroup);\n      }\n      segment.segmentGroups.enqueue(segmentGroup);\n      return segmentGroup;\n    }\n    // TODO: error checking\n    getMarkerFromId(id) {\n      return this.idToSegment[id];\n    }\n    /**\n     * Given a position specified relative to a marker id, lookup the marker\n     * and convert the position to a character position.\n     * @param relativePos - Id of marker (may be indirect) and whether position is before or after marker.\n     * @param refseq - The reference sequence number at which to compute the position.\n     * @param clientId - The client id with which to compute the position.\n     */\n    posFromRelativePos(relativePos, refseq = this.collabWindow.currentSeq, clientId = this.collabWindow.clientId) {\n      let pos = -1;\n      let marker;\n      if (relativePos.id) {\n        marker = this.getMarkerFromId(relativePos.id);\n      }\n      if (marker) {\n        pos = this.getPosition(marker, refseq, clientId);\n        if (!relativePos.before) {\n          pos += marker.cachedLength;\n          if (relativePos.offset !== undefined) {\n            pos += relativePos.offset;\n          }\n        } else {\n          if (relativePos.offset !== undefined) {\n            pos -= relativePos.offset;\n          }\n        }\n      }\n      return pos;\n    }\n    insertSegments(pos, segments, refSeq, clientId, seq, opArgs) {\n      // const tt = MergeTree.traceTraversal;\n      // MergeTree.traceTraversal = true;\n      this.ensureIntervalBoundary(pos, refSeq, clientId);\n      if (MergeTree.traceOrdinals) {\n        this.ordinalIntegrity();\n      }\n      const localSeq = seq === UnassignedSequenceNumber ? ++this.collabWindow.localSeq : undefined;\n      this.blockInsert(pos, refSeq, clientId, seq, localSeq, segments);\n      // opArgs == undefined => loading snapshot or test code\n      if (this.mergeTreeDeltaCallback && opArgs !== undefined) {\n        this.mergeTreeDeltaCallback(opArgs, {\n          operation: 0 /* INSERT */,\n          deltaSegments: segments.map(segment => ({\n            segment\n          }))\n        });\n      }\n      // MergeTree.traceTraversal = tt;\n      if (MergeTree.traceOrdinals) {\n        this.ordinalIntegrity();\n      }\n      if (this.collabWindow.collaborating && MergeTree.options.zamboniSegments && seq !== UnassignedSequenceNumber) {\n        this.zamboniSegments();\n      }\n    }\n    insertAtReferencePosition(referencePosition, insertSegment, opArgs) {\n      if (insertSegment.cachedLength === 0) {\n        return;\n      }\n      if (insertSegment.parent || insertSegment.removedSeq || insertSegment.seq !== UniversalSequenceNumber) {\n        throw new Error(\"Cannot insert segment that has already been inserted.\");\n      }\n      const rebalanceTree = segment => {\n        // Blocks should never be left full\n        // if the inserts makes the block full\n        // then we need to walk up the chain of parents\n        // and split the blocks until we find a block with\n        // room\n        let block = segment.parent;\n        let ordinalUpdateNode = block;\n        while (block !== undefined) {\n          if (block.childCount >= MaxNodesInBlock) {\n            const splitNode = this.split(block);\n            if (block === this.root) {\n              this.updateRoot(splitNode);\n              // Update root already updates all it's children ordinals\n              ordinalUpdateNode = undefined;\n            } else {\n              this.insertChildNode(block.parent, splitNode, block.index + 1);\n              ordinalUpdateNode = splitNode.parent;\n              this.blockUpdateLength(block.parent, UnassignedSequenceNumber, clientId);\n            }\n          } else {\n            this.blockUpdateLength(block, UnassignedSequenceNumber, clientId);\n          }\n          block = block.parent;\n        }\n        // Only update ordinals once, for all children,\n        // on the path\n        if (ordinalUpdateNode) {\n          this.nodeUpdateOrdinals(ordinalUpdateNode);\n        }\n      };\n      const clientId = this.collabWindow.clientId;\n      const refSegment = referencePosition.getSegment();\n      const refOffset = referencePosition.getOffset();\n      const refSegLen = this.nodeLength(refSegment, this.collabWindow.currentSeq, clientId);\n      let startSeg = refSegment;\n      if (refOffset !== 0 && refSegLen !== 0) {\n        const splitSeg = this.splitLeafSegment(refSegment, refOffset);\n        assert(!!splitSeg.next);\n        this.insertChildNode(refSegment.parent, splitSeg.next, refSegment.index + 1);\n        rebalanceTree(splitSeg.next);\n        startSeg = splitSeg.next;\n      }\n      this.leftExcursion(startSeg, backSeg => {\n        if (!backSeg.isLeaf()) {\n          return true;\n        }\n        const backLen = this.nodeLength(backSeg, this.collabWindow.currentSeq, clientId);\n        // Find the nearest 0 length seg we can insert over, as all other inserts\n        // go near to far\n        if (backLen === 0) {\n          if (this.breakTie(0, 0, backSeg, this.collabWindow.currentSeq, clientId)) {\n            startSeg = backSeg;\n          }\n          return true;\n        }\n        return false;\n      });\n      const localSeq = ++this.collabWindow.localSeq;\n      insertSegment.seq = UnassignedSequenceNumber;\n      insertSegment.localSeq = localSeq;\n      insertSegment.clientId = clientId;\n      if (Marker.is(insertSegment)) {\n        const markerId = insertSegment.getId();\n        if (markerId) {\n          this.mapIdToSegment(markerId, insertSegment);\n        }\n      }\n      this.insertChildNode(startSeg.parent, insertSegment, startSeg.index);\n      rebalanceTree(insertSegment);\n      if (this.mergeTreeDeltaCallback) {\n        this.mergeTreeDeltaCallback(opArgs, {\n          deltaSegments: [{\n            segment: insertSegment\n          }],\n          operation: 0 /* INSERT */\n        });\n      }\n\n      if (this.collabWindow.collaborating) {\n        this.addToPendingList(insertSegment, undefined, localSeq);\n      }\n    }\n    /**\n     * Resolves a remote client's position against the local sequence\n     * and returns the remote client's position relative to the local\n     * sequence\n     * @param remoteClientPosition - The remote client's position to resolve\n     * @param remoteClientRefSeq - The reference sequence number of the remote client\n     * @param remoteClientId - The client id of the remote client\n     */\n    resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId) {\n      const segmentInfo = this.getContainingSegment(remoteClientPosition, remoteClientRefSeq, remoteClientId);\n      const segwindow = this.getCollabWindow();\n      if (segmentInfo && segmentInfo.segment) {\n        const segmentPosition = this.getPosition(segmentInfo.segment, segwindow.currentSeq, segwindow.clientId);\n        return segmentPosition + segmentInfo.offset;\n      } else {\n        if (remoteClientPosition === this.getLength(remoteClientRefSeq, remoteClientId)) {\n          return this.getLength(segwindow.currentSeq, segwindow.clientId);\n        }\n      }\n    }\n    insertChildNode(block, child, childIndex) {\n      assert(block.childCount < MaxNodesInBlock);\n      for (let i = block.childCount; i > childIndex; i--) {\n        block.children[i] = block.children[i - 1];\n        block.children[i].index = i;\n      }\n      block.childCount++;\n      block.assignChild(child, childIndex, false);\n    }\n    blockInsert(pos, refSeq, clientId, seq, localSeq, newSegments) {\n      let segIsLocal = false;\n      const checkSegmentIsLocal = (segment, pos, refSeq, clientId) => {\n        if (segment.seq === UnassignedSequenceNumber) {\n          if (MergeTree.diagInsertTie) {\n            console.log(`@cli ${glc(this, this.collabWindow.clientId)}: promoting continue due to seq ${segment.seq} text ${segment.toString()} ref ${refSeq}`);\n          }\n          segIsLocal = true;\n        }\n        // Only need to look at first segment that follows finished node\n        return false;\n      };\n      const continueFrom = node => {\n        segIsLocal = false;\n        this.rightExcursion(node, checkSegmentIsLocal);\n        if (MergeTree.diagInsertTie && segIsLocal) {\n          console.log(`@cli ${glc(this, this.collabWindow.clientId)}: attempting continue with seq ${seq}  ref ${refSeq} `);\n        }\n        return segIsLocal;\n      };\n      let segmentGroup;\n      const saveIfLocal = locSegment => {\n        // Save segment so can assign sequence number when acked by server\n        if (this.collabWindow.collaborating) {\n          if (locSegment.seq === UnassignedSequenceNumber && clientId === this.collabWindow.clientId) {\n            segmentGroup = this.addToPendingList(locSegment, segmentGroup, localSeq);\n          }\n          // LocSegment.seq === 0 when coming from SharedSegmentSequence.loadBody()\n          // In all other cases this has to be true (checked by addToLRUSet):\n          // locSegment.seq > this.collabWindow.currentSeq\n          else if (locSegment.seq > this.collabWindow.minSeq && MergeTree.options.zamboniSegments) {\n            this.addToLRUSet(locSegment, locSegment.seq);\n          }\n        }\n      };\n      const onLeaf = (segment, pos, context) => {\n        const segmentChanges = {};\n        if (segment) {\n          // Insert before segment\n          segmentChanges.replaceCurrent = context.candidateSegment;\n          segmentChanges.next = segment;\n        } else {\n          segmentChanges.next = context.candidateSegment;\n        }\n        return segmentChanges;\n      };\n      // TODO: build tree from segs and insert all at once\n      let insertPos = pos;\n      for (const newSegment of newSegments) {\n        segIsLocal = false;\n        if (newSegment.cachedLength > 0) {\n          newSegment.seq = seq;\n          newSegment.localSeq = localSeq;\n          newSegment.clientId = clientId;\n          if (Marker.is(newSegment)) {\n            const markerId = newSegment.getId();\n            if (markerId) {\n              this.mapIdToSegment(markerId, newSegment);\n            }\n          }\n          const splitNode = this.insertingWalk(this.root, insertPos, refSeq, clientId, seq, {\n            leaf: onLeaf,\n            candidateSegment: newSegment,\n            continuePredicate: continueFrom\n          });\n          if (newSegment.parent === undefined) {\n            throw new Error(`MergeTree insert failed: ${JSON.stringify({\n              currentSeq: this.collabWindow.currentSeq,\n              minSeq: this.collabWindow.minSeq,\n              segSeq: newSegment.seq\n            })}`);\n          }\n          this.updateRoot(splitNode);\n          saveIfLocal(newSegment);\n          insertPos += newSegment.cachedLength;\n        }\n      }\n    }\n    ensureIntervalBoundary(pos, refSeq, clientId) {\n      const splitNode = this.insertingWalk(this.root, pos, refSeq, clientId, TreeMaintenanceSequenceNumber, {\n        leaf: this.splitLeafSegment\n      });\n      this.updateRoot(splitNode);\n    }\n    // Assume called only when pos == len\n    breakTie(pos, len, node, refSeq, clientId, candidateSegment) {\n      if (node.isLeaf()) {\n        if (pos === 0) {\n          const segment = node;\n          const branchId = this.getBranchId(clientId);\n          const segmentBranchId = this.getBranchId(segment.clientId);\n          const removalInfo = this.getRemovalInfo(branchId, segmentBranchId, segment);\n          if (removalInfo.removedSeq && removalInfo.removedSeq <= refSeq && removalInfo.removedSeq !== UnassignedSequenceNumber) {\n            return false;\n          }\n          // Local change see everything\n          if (clientId === this.collabWindow.clientId) {\n            return true;\n          }\n          if (node.seq !== UnassignedSequenceNumber) {\n            // Ensure we merge right. newer segments should come before older segments\n            return true;\n          }\n        }\n        return false;\n      } else {\n        return true;\n      }\n    }\n    // Visit segments starting from node's left siblings, then up to node's parent\n    leftExcursion(node, leafAction) {\n      const actions = {\n        leaf: leafAction\n      };\n      let go = true;\n      let startNode = node;\n      let parent = startNode.parent;\n      while (parent) {\n        const children = parent.children;\n        let childIndex;\n        let node;\n        let matchedStart = false;\n        for (childIndex = parent.childCount - 1; childIndex >= 0; childIndex--) {\n          node = children[childIndex];\n          if (matchedStart) {\n            if (!node.isLeaf()) {\n              const childBlock = node;\n              go = this.nodeMapReverse(childBlock, actions, 0, UniversalSequenceNumber, this.collabWindow.clientId, undefined);\n            } else {\n              go = leafAction(node, 0, UniversalSequenceNumber, this.collabWindow.clientId, 0, 0);\n            }\n            if (!go) {\n              return;\n            }\n          } else {\n            matchedStart = startNode === node;\n          }\n        }\n        startNode = parent;\n        parent = parent.parent;\n      }\n    }\n    // Visit segments starting from node's right siblings, then up to node's parent\n    rightExcursion(node, leafAction) {\n      const actions = {\n        leaf: leafAction\n      };\n      let go = true;\n      let startNode = node;\n      let parent = startNode.parent;\n      while (parent) {\n        const children = parent.children;\n        let childIndex;\n        let node;\n        let matchedStart = false;\n        for (childIndex = 0; childIndex < parent.childCount; childIndex++) {\n          node = children[childIndex];\n          if (matchedStart) {\n            if (!node.isLeaf()) {\n              const childBlock = node;\n              go = this.nodeMap(childBlock, actions, 0, UniversalSequenceNumber, this.collabWindow.clientId, undefined);\n            } else {\n              go = leafAction(node, 0, UniversalSequenceNumber, this.collabWindow.clientId, 0, 0);\n            }\n            if (!go) {\n              return;\n            }\n          } else {\n            matchedStart = startNode === node;\n          }\n        }\n        startNode = parent;\n        parent = parent.parent;\n      }\n    }\n    insertingWalk(block, pos, refSeq, clientId, seq, context) {\n      const children = block.children;\n      let childIndex;\n      let child;\n      let newNode;\n      let fromSplit;\n      let found = false;\n      for (childIndex = 0; childIndex < block.childCount; childIndex++) {\n        child = children[childIndex];\n        const len = this.nodeLength(child, refSeq, clientId);\n        if (MergeTree.traceTraversal) {\n          let segInfo;\n          if (!child.isLeaf() && this.collabWindow.collaborating) {\n            segInfo = `minLength: ${child.partialLengths.minLength}`;\n          } else {\n            const segment = child;\n            segInfo = `cli: ${glc(this, segment.clientId)} seq: ${segment.seq} text: ${segment.toString()}`;\n            if (segment.removedSeq !== undefined) {\n              segInfo += ` rcli: ${glc(this, segment.removedClientId)} rseq: ${segment.removedSeq}`;\n            }\n          }\n          console.log(`@tcli: ${glc(this, this.collabWindow.clientId)} len: ${len} pos: ${pos} ${segInfo}`);\n        }\n        if (pos < len || pos === len && this.breakTie(pos, len, child, refSeq, clientId, context.candidateSegment)) {\n          // Found entry containing pos\n          found = true;\n          if (!child.isLeaf()) {\n            const childBlock = child;\n            // Internal node\n            const splitNode = this.insertingWalk(childBlock, pos, refSeq, clientId, seq, context);\n            if (splitNode === undefined) {\n              if (context.structureChange) {\n                this.nodeUpdateLengthNewStructure(block);\n              } else {\n                this.blockUpdateLength(block, seq, clientId);\n              }\n              return undefined;\n            } else if (splitNode === MergeTree.theUnfinishedNode) {\n              if (MergeTree.traceTraversal) {\n                console.log(`@cli ${glc(this, this.collabWindow.clientId)} unfinished bus pos ${pos} len ${len}`);\n              }\n              pos -= len; // Act as if shifted segment\n              continue;\n            } else {\n              newNode = splitNode;\n              fromSplit = splitNode;\n              childIndex++; // Insert after\n            }\n          } else {\n            if (MergeTree.traceTraversal) {\n              console.log(`@tcli: ${glc(this, this.collabWindow.clientId)}: leaf action`);\n            }\n            const segment = child;\n            const segmentChanges = context.leaf(segment, pos, context);\n            if (segmentChanges.replaceCurrent) {\n              if (MergeTree.traceOrdinals) {\n                console.log(`assign from leaf with block ord ${ordinalToArray(block.ordinal)}`);\n              }\n              block.assignChild(segmentChanges.replaceCurrent, childIndex, false);\n              segmentChanges.replaceCurrent.ordinal = child.ordinal;\n            }\n            if (segmentChanges.next) {\n              newNode = segmentChanges.next;\n              childIndex++; // Insert after\n            } else {\n              // No change\n              if (context.structureChange) {\n                this.nodeUpdateLengthNewStructure(block);\n              }\n              return undefined;\n            }\n          }\n          break;\n        } else {\n          pos -= len;\n        }\n      }\n      if (MergeTree.traceTraversal) {\n        if (!found && pos > 0) {\n          console.log(`inserting walk fell through pos ${pos} len: ${this.blockLength(this.root, refSeq, clientId)}`);\n        }\n      }\n      if (!newNode) {\n        if (pos === 0) {\n          if (seq !== UnassignedSequenceNumber && context.continuePredicate && context.continuePredicate(block)) {\n            return MergeTree.theUnfinishedNode;\n          } else {\n            if (MergeTree.traceTraversal) {\n              console.log(`@tcli: ${glc(this, this.collabWindow.clientId)}: leaf action pos 0`);\n            }\n            const segmentChanges = context.leaf(undefined, pos, context);\n            newNode = segmentChanges.next;\n            // Assert segmentChanges.replaceCurrent === undefined\n          }\n        }\n      }\n\n      if (newNode) {\n        for (let i = block.childCount; i > childIndex; i--) {\n          block.children[i] = block.children[i - 1];\n          block.children[i].index = i;\n        }\n        block.assignChild(newNode, childIndex, false);\n        block.childCount++;\n        block.setOrdinal(newNode, childIndex);\n        if (block.childCount < MaxNodesInBlock) {\n          if (fromSplit) {\n            if (MergeTree.traceOrdinals) {\n              console.log(`split ord ${ordinalToArray(fromSplit.ordinal)}`);\n            }\n            this.nodeUpdateOrdinals(fromSplit);\n          }\n          if (context.structureChange) {\n            this.nodeUpdateLengthNewStructure(block);\n          } else {\n            this.blockUpdateLength(block, seq, clientId);\n          }\n          return undefined;\n        } else {\n          // Don't update ordinals because higher block will do it\n          return this.split(block);\n        }\n      } else {\n        return undefined;\n      }\n    }\n    split(node) {\n      const halfCount = MaxNodesInBlock / 2;\n      const newNode = this.makeBlock(halfCount);\n      node.childCount = halfCount;\n      // Update ordinals to reflect lowered child count\n      this.nodeUpdateOrdinals(node);\n      for (let i = 0; i < halfCount; i++) {\n        newNode.assignChild(node.children[halfCount + i], i, false);\n        node.children[halfCount + i] = undefined;\n      }\n      this.nodeUpdateLengthNewStructure(node);\n      this.nodeUpdateLengthNewStructure(newNode);\n      return newNode;\n    }\n    ordinalIntegrity() {\n      console.log(\"chk ordnls\");\n      this.nodeOrdinalIntegrity(this.root);\n    }\n    nodeOrdinalIntegrity(block) {\n      const olen = block.ordinal.length;\n      for (let i = 0; i < block.childCount; i++) {\n        const child = block.children[i];\n        if (child.ordinal) {\n          if (olen !== child.ordinal.length - 1) {\n            console.log(\"node integrity issue\");\n          }\n          if (i > 0) {\n            if (child.ordinal <= block.children[i - 1].ordinal) {\n              console.log(\"node sib integrity issue\");\n              console.log(`??: prnt chld prev ${ordinalToArray(block.ordinal)} ${ordinalToArray(child.ordinal)} ${i > 0 ? ordinalToArray(block.children[i - 1].ordinal) : \"NA\"}`);\n            }\n          }\n          if (!child.isLeaf()) {\n            this.nodeOrdinalIntegrity(child);\n          }\n        } else {\n          console.log(`node child ordinal not set ${i}`);\n          console.log(`??: prnt ${ordinalToArray(block.ordinal)}`);\n        }\n      }\n    }\n    nodeUpdateOrdinals(block) {\n      if (MergeTree.traceOrdinals) {\n        console.log(`update ordinals for children of node with ordinal ${ordinalToArray(block.ordinal)}`);\n      }\n      let clockStart;\n      if (MergeTree.options.measureOrdinalTime) {\n        clockStart = clock();\n      }\n      for (let i = 0; i < block.childCount; i++) {\n        const child = block.children[i];\n        block.setOrdinal(child, i);\n        if (!child.isLeaf()) {\n          this.nodeUpdateOrdinals(child);\n        }\n      }\n      if (MergeTree.options.measureOrdinalTime) {\n        const elapsed = elapsedMicroseconds(clockStart);\n        if (elapsed > this.maxOrdTime) {\n          this.maxOrdTime = elapsed;\n        }\n        this.ordTime += elapsed;\n      }\n    }\n    addOverlappingClient(removalInfo, clientId) {\n      if (!removalInfo.removedClientOverlap) {\n        removalInfo.removedClientOverlap = [];\n      }\n      if (MergeTree.diagOverlappingRemove) {\n        console.log(`added cli ${glc(this, clientId)} to rseq: ${removalInfo.removedSeq}`);\n      }\n      removalInfo.removedClientOverlap.push(clientId);\n    }\n    /**\n     * Annotate a range with properties\n     * @param start - The inclusive start postition of the range to annotate\n     * @param end - The exclusive end position of the range to annotate\n     * @param props - The properties to annotate the range with\n     * @param combiningOp - Optional. Specifies how to combine values for the property, such as \"incr\" for increment.\n     * @param refSeq - The reference sequence number to use to apply the annotate\n     * @param clientId - The id of the client making the annotate\n     * @param seq - The sequence number of the annotate operation\n     * @param opArgs - The op args for the annotate op. this is passed to the merge tree callback if there is one\n     */\n    annotateRange(start, end, props, combiningOp, refSeq, clientId, seq, opArgs) {\n      this.ensureIntervalBoundary(start, refSeq, clientId);\n      this.ensureIntervalBoundary(end, refSeq, clientId);\n      const deltaSegments = [];\n      const localSeq = seq === UnassignedSequenceNumber ? ++this.collabWindow.localSeq : undefined;\n      let segmentGroup;\n      const annotateSegment = segment => {\n        const propertyDeltas = segment.addProperties(props, combiningOp, seq, this.collabWindow);\n        deltaSegments.push({\n          segment,\n          propertyDeltas\n        });\n        if (this.collabWindow.collaborating) {\n          if (seq === UnassignedSequenceNumber) {\n            segmentGroup = this.addToPendingList(segment, segmentGroup, localSeq);\n          } else {\n            if (MergeTree.options.zamboniSegments) {\n              this.addToLRUSet(segment, seq);\n            }\n          }\n        }\n        return true;\n      };\n      this.mapRange({\n        leaf: annotateSegment\n      }, refSeq, clientId, undefined, start, end);\n      // OpArgs == undefined => test code\n      if (this.mergeTreeDeltaCallback) {\n        this.mergeTreeDeltaCallback(opArgs, {\n          operation: 2 /* ANNOTATE */,\n          deltaSegments\n        });\n      }\n      if (this.collabWindow.collaborating && seq !== UnassignedSequenceNumber) {\n        if (MergeTree.options.zamboniSegments) {\n          this.zamboniSegments();\n        }\n      }\n    }\n    markRangeRemoved(start, end, refSeq, clientId, seq, overwrite = false, opArgs) {\n      this.ensureIntervalBoundary(start, refSeq, clientId);\n      this.ensureIntervalBoundary(end, refSeq, clientId);\n      let segmentGroup;\n      const removedSegments = [];\n      const savedLocalRefs = [];\n      const localSeq = seq === UnassignedSequenceNumber ? ++this.collabWindow.localSeq : undefined;\n      const markRemoved = (segment, pos, start, end) => {\n        const branchId = this.getBranchId(clientId);\n        const segBranchId = this.getBranchId(segment.clientId);\n        for (let brid = branchId; brid <= this.localBranchId; brid++) {\n          const removalInfo = this.getRemovalInfo(brid, segBranchId, segment);\n          if (removalInfo.removedSeq !== undefined) {\n            if (MergeTree.diagOverlappingRemove) {\n              console.log(`yump @seq ${seq} cli ${glc(this, this.collabWindow.clientId)}: overlaps deleted segment ${removalInfo.removedSeq} text '${segment.toString()}'`);\n            }\n            overwrite = true;\n            if (removalInfo.removedSeq === UnassignedSequenceNumber) {\n              // Will only happen on local branch (brid === this.localBranchId)\n              // replace because comes later\n              removalInfo.removedClientId = clientId;\n              removalInfo.removedSeq = seq;\n              segment.localRemovedSeq = undefined;\n            } else {\n              // Do not replace earlier sequence number for remove\n              this.addOverlappingClient(removalInfo, clientId);\n            }\n          } else {\n            removalInfo.removedClientId = clientId;\n            removalInfo.removedSeq = seq;\n            segment.localRemovedSeq = localSeq;\n            removedSegments.push({\n              segment\n            });\n            if (segment.localRefs && !segment.localRefs.empty && brid === this.localBranchId) {\n              savedLocalRefs.push(segment.localRefs);\n            }\n            segment.localRefs = undefined;\n          }\n        }\n        // Save segment so can assign removed sequence number when acked by server\n        if (this.collabWindow.collaborating) {\n          // Use removal information\n          const removalInfo = this.getRemovalInfo(this.localBranchId, segBranchId, segment);\n          if (removalInfo.removedSeq === UnassignedSequenceNumber && clientId === this.collabWindow.clientId) {\n            segmentGroup = this.addToPendingList(segment, segmentGroup, localSeq);\n          } else {\n            if (MergeTree.options.zamboniSegments) {\n              this.addToLRUSet(segment, seq);\n            }\n          }\n          // console.log(`saved local removed seg with text: ${textSegment.text}`);\n        }\n\n        return true;\n      };\n      const afterMarkRemoved = (node, pos, start, end) => {\n        if (overwrite) {\n          this.nodeUpdateLengthNewStructure(node);\n        } else {\n          this.blockUpdateLength(node, seq, clientId);\n        }\n        return true;\n      };\n      // MergeTree.traceTraversal = true;\n      this.mapRange({\n        leaf: markRemoved,\n        post: afterMarkRemoved\n      }, refSeq, clientId, undefined, start, end);\n      if (savedLocalRefs.length > 0) {\n        const length = this.getLength(refSeq, clientId);\n        let refSegment;\n        if (start < length) {\n          const afterSegOff = this.getContainingSegment(start, refSeq, clientId);\n          refSegment = afterSegOff.segment;\n          assert(!!refSegment);\n          if (!refSegment.localRefs) {\n            refSegment.localRefs = new LocalReferenceCollection(refSegment);\n          }\n          refSegment.localRefs.addBeforeTombstones(...savedLocalRefs);\n        } else if (length > 0) {\n          const beforeSegOff = this.getContainingSegment(length - 1, refSeq, clientId);\n          refSegment = beforeSegOff.segment;\n          assert(!!refSegment);\n          if (!refSegment.localRefs) {\n            refSegment.localRefs = new LocalReferenceCollection(refSegment);\n          }\n          refSegment.localRefs.addAfterTombstones(...savedLocalRefs);\n        } else {\n          // TODO: The tree is empty, so there isn't anywhere to put these\n          // they should be preserved somehow\n          for (const refsCollection of savedLocalRefs) {\n            refsCollection.clear();\n          }\n        }\n        if (refSegment) {\n          this.blockUpdatePathLengths(refSegment.parent, TreeMaintenanceSequenceNumber, LocalClientId);\n        }\n      }\n      // opArgs == undefined => test code\n      if (this.mergeTreeDeltaCallback) {\n        this.mergeTreeDeltaCallback(opArgs, {\n          operation: 1 /* REMOVE */,\n          deltaSegments: removedSegments\n        });\n      }\n      if (this.collabWindow.collaborating && seq !== UnassignedSequenceNumber) {\n        if (MergeTree.options.zamboniSegments) {\n          this.zamboniSegments();\n        }\n      }\n      // MergeTree.traceTraversal = false;\n    }\n\n    nodeUpdateLengthNewStructure(node, recur = false) {\n      this.blockUpdate(node);\n      if (this.collabWindow.collaborating) {\n        node.partialLengths = PartialSequenceLengths.combine(this, node, this.collabWindow, recur);\n      }\n    }\n    removeLocalReference(segment, lref) {\n      if (segment.localRefs) {\n        const removedRef = segment.localRefs.removeLocalRef(lref);\n        if (removedRef) {\n          this.blockUpdatePathLengths(segment.parent, TreeMaintenanceSequenceNumber, LocalClientId);\n        }\n      }\n    }\n    addLocalReference(lref) {\n      const segment = lref.segment;\n      if (!segment.localRefs) {\n        segment.localRefs = new LocalReferenceCollection(segment);\n      }\n      segment.localRefs.addLocalRef(lref);\n      this.blockUpdatePathLengths(segment.parent, TreeMaintenanceSequenceNumber, LocalClientId);\n    }\n    blockUpdate(block) {\n      let len = 0;\n      let hierBlock;\n      if (MergeTree.blockUpdateMarkers) {\n        hierBlock = block.hierBlock();\n        hierBlock.rightmostTiles = Properties.createMap();\n        hierBlock.leftmostTiles = Properties.createMap();\n        hierBlock.rangeStacks = {};\n      }\n      for (let i = 0; i < block.childCount; i++) {\n        const child = block.children[i];\n        len += nodeTotalLength(this, child);\n        if (MergeTree.blockUpdateMarkers) {\n          hierBlock.addNodeReferences(this, child);\n        }\n        if (this.blockUpdateActions) {\n          this.blockUpdateActions.child(block, i);\n        }\n      }\n      block.cachedLength = len;\n    }\n    blockUpdatePathLengths(block, seq, clientId, newStructure = false) {\n      while (block !== undefined) {\n        if (newStructure) {\n          this.nodeUpdateLengthNewStructure(block);\n        } else {\n          this.blockUpdateLength(block, seq, clientId);\n        }\n        block = block.parent;\n      }\n    }\n    blockUpdateLength(node, seq, clientId) {\n      this.blockUpdate(node);\n      if (this.collabWindow.collaborating && seq !== UnassignedSequenceNumber && seq !== TreeMaintenanceSequenceNumber) {\n        if (node.partialLengths !== undefined && MergeTree.options.incrementalUpdate && clientId !== NonCollabClient) {\n          node.partialLengths.update(this, node, seq, clientId, this.collabWindow);\n        } else {\n          node.partialLengths = PartialSequenceLengths.combine(this, node, this.collabWindow);\n        }\n      }\n    }\n    map(actions, refSeq, clientId, accum) {\n      // TODO: optimize to avoid comparisons\n      this.nodeMap(this.root, actions, 0, refSeq, clientId, accum);\n    }\n    mapRange(actions, refSeq, clientId, accum, start, end, splitRange = false) {\n      if (splitRange) {\n        if (start) {\n          this.ensureIntervalBoundary(start, refSeq, clientId);\n        }\n        if (end) {\n          this.ensureIntervalBoundary(end, refSeq, clientId);\n        }\n      }\n      this.nodeMap(this.root, actions, 0, refSeq, clientId, accum, start, end);\n    }\n    nodeToString(block, strbuf, indentCount = 0) {\n      strbuf += internedSpaces(indentCount);\n      strbuf += `Node (len ${block.cachedLength}) p len (${block.parent ? block.parent.cachedLength : 0}) ord ${ordinalToArray(block.ordinal)} with ${block.childCount} segs:\\n`;\n      if (MergeTree.blockUpdateMarkers) {\n        strbuf += internedSpaces(indentCount);\n        strbuf += block.hierToString(indentCount);\n      }\n      if (this.collabWindow.collaborating) {\n        strbuf += internedSpaces(indentCount);\n        strbuf += `${block.partialLengths.toString(id => glc(this, id), indentCount)}\\n`;\n      }\n      const children = block.children;\n      for (let childIndex = 0; childIndex < block.childCount; childIndex++) {\n        const child = children[childIndex];\n        if (!child.isLeaf()) {\n          strbuf = this.nodeToString(child, strbuf, indentCount + 4);\n        } else {\n          const segment = child;\n          strbuf += internedSpaces(indentCount + 4);\n          strbuf += `cli: ${glc(this, segment.clientId)} seq: ${segment.seq} ord: ${ordinalToArray(segment.ordinal)}`;\n          const segBranchId = this.getBranchId(segment.clientId);\n          const branchId = this.localBranchId;\n          const removalInfo = this.getRemovalInfo(branchId, segBranchId, segment);\n          if (removalInfo.removedSeq !== undefined) {\n            strbuf += ` rcli: ${glc(this, removalInfo.removedClientId)} rseq: ${removalInfo.removedSeq}`;\n          }\n          strbuf += \"\\n\";\n          strbuf += internedSpaces(indentCount + 4);\n          strbuf += segment.toString();\n          strbuf += \"\\n\";\n        }\n      }\n      return strbuf;\n    }\n    toString() {\n      return this.nodeToString(this.root, \"\", 0);\n    }\n    incrementalBlockMap(stateStack) {\n      while (!stateStack.empty()) {\n        const state = stateStack.top();\n        if (state.op !== IncrementalExecOp.Go) {\n          return;\n        }\n        if (state.childIndex === 0) {\n          if (state.start === undefined) {\n            state.start = 0;\n          }\n          if (state.end === undefined) {\n            state.end = this.blockLength(state.block, state.refSeq, state.clientId);\n          }\n          if (state.actions.pre) {\n            state.actions.pre(state);\n          }\n        }\n        if (state.op === IncrementalExecOp.Go && state.childIndex < state.block.childCount) {\n          const child = state.block.children[state.childIndex];\n          const len = this.nodeLength(child, state.refSeq, state.clientId);\n          if (MergeTree.traceIncrTraversal) {\n            if (child.isLeaf()) {\n              // eslint-disable-next-line dot-notation\n              console.log(`considering (r ${state.refSeq} c ${glc(this, state.clientId)}) seg with text ${child[\"text\"]} len ${len} seq ${child.seq} rseq ${child.removedSeq} cli ${glc(this, child.clientId)}`);\n            }\n          }\n          if (len > 0 && state.start < len && state.end > 0) {\n            if (!child.isLeaf()) {\n              const childState = new IncrementalMapState(child, state.actions, state.pos, state.refSeq, state.clientId, state.context, state.start, state.end, 0);\n              stateStack.push(childState);\n            } else {\n              if (MergeTree.traceIncrTraversal) {\n                // eslint-disable-next-line dot-notation\n                console.log(`action on seg with text ${child[\"text\"]}`);\n              }\n              state.actions.leaf(child, state);\n            }\n          }\n          state.pos += len;\n          state.start -= len;\n          state.end -= len;\n          state.childIndex++;\n        } else {\n          if (state.childIndex === state.block.childCount) {\n            if (state.op === IncrementalExecOp.Go && state.actions.post) {\n              state.actions.post(state);\n            }\n            stateStack.pop();\n          }\n        }\n      }\n    }\n    nodeMap(node, actions, pos, refSeq, clientId, accum, start, end) {\n      if (start === undefined) {\n        start = 0;\n      }\n      if (end === undefined) {\n        end = this.blockLength(node, refSeq, clientId);\n      }\n      let go = true;\n      if (actions.pre) {\n        go = actions.pre(node, pos, refSeq, clientId, start, end, accum);\n        if (!go) {\n          // Cancel this node but not entire traversal\n          return true;\n        }\n      }\n      const children = node.children;\n      for (let childIndex = 0; childIndex < node.childCount; childIndex++) {\n        const child = children[childIndex];\n        const len = this.nodeLength(child, refSeq, clientId);\n        if (MergeTree.traceTraversal) {\n          let segInfo;\n          if (!child.isLeaf() && this.collabWindow.collaborating) {\n            segInfo = `minLength: ${child.partialLengths.minLength}`;\n          } else {\n            const segment = child;\n            segInfo = `cli: ${glc(this, segment.clientId)} seq: ${segment.seq} text: '${segment.toString()}'`;\n            if (segment.removedSeq !== undefined) {\n              segInfo += ` rcli: ${glc(this, segment.removedClientId)} rseq: ${segment.removedSeq}`;\n            }\n          }\n          console.log(`@tcli ${glc(this, this.collabWindow.clientId)}: map len: ${len} start: ${start} end: ${end} ${segInfo}`);\n        }\n        if (go && end > 0 && len > 0 && start < len) {\n          // Found entry containing pos\n          if (!child.isLeaf()) {\n            if (go) {\n              go = this.nodeMap(child, actions, pos, refSeq, clientId, accum, start, end);\n            }\n          } else {\n            if (MergeTree.traceTraversal) {\n              console.log(`@tcli ${glc(this, this.collabWindow.clientId)}: map leaf action`);\n            }\n            go = actions.leaf(child, pos, refSeq, clientId, start, end, accum);\n          }\n        }\n        if (!go) {\n          break;\n        }\n        if (actions.shift) {\n          actions.shift(child, pos, refSeq, clientId, start, end, accum);\n        }\n        pos += len;\n        start -= len;\n        end -= len;\n      }\n      if (go && actions.post) {\n        go = actions.post(node, pos, refSeq, clientId, start, end, accum);\n      }\n      return go;\n    }\n    // Invokes the leaf action for all segments.  Note that *all* segments are visited\n    // regardless of if they would be visible to the current `clientId` and `refSeq`.\n    walkAllSegments(block, action, accum) {\n      let go = true;\n      const children = block.children;\n      for (let childIndex = 0; go && childIndex < block.childCount; childIndex++) {\n        const child = children[childIndex];\n        go = child.isLeaf() ? action(child, accum) : this.walkAllSegments(child, action, accum);\n      }\n      return go;\n    }\n    // Straight call every segment; goes until leaf action returns false\n    nodeMapReverse(block, actions, pos, refSeq, clientId, accum) {\n      let go = true;\n      const children = block.children;\n      for (let childIndex = block.childCount - 1; childIndex >= 0; childIndex--) {\n        const child = children[childIndex];\n        if (go) {\n          // Found entry containing pos\n          if (!child.isLeaf()) {\n            if (go) {\n              go = this.nodeMapReverse(child, actions, pos, refSeq, clientId, accum);\n            }\n          } else {\n            go = actions.leaf(child, pos, refSeq, clientId, 0, 0, accum);\n          }\n        }\n        if (!go) {\n          break;\n        }\n      }\n      return go;\n    }\n  }\n  // Maximum length of text segment to be considered to be merged with other segment.\n  // Maximum segment length is at least 2x of it (not taking into account initial segment creation).\n  // The bigger it is, the more expensive it is to break segment into sub-segments (on edits)\n  // The smaller it is, the more segments we have in snapshots (and in memory) - it's more expensive to load snapshots.\n  // Small number also makes ReplayTool produce false positives (\"same\" snapshots have slightly different binary representations).\n  // More measurements needs to be done, but it's very likely the right spot is somewhere between 1K-2K mark.\n  // That said, we also break segments on newline and there are very few segments that are longer than 256 because of it.\n  // must be an even number\n  // WARNING:\n  // Setting blockUpdateMarkers to false will result in eventual consistency issues\n  // for property updates on markers when loading from snapshots\n  //# sourceMappingURL=mergeTree.js.map\n  MergeTree.TextSegmentGranularity = 256;\n  MergeTree.zamboniSegmentsMaxCount = 2;\n  MergeTree.options = {\n    incrementalUpdate: true,\n    insertAfterRemovedSegs: true,\n    measureOrdinalTime: true,\n    measureWindowTime: true,\n    zamboniSegments: true\n  };\n  MergeTree.traceAppend = false;\n  MergeTree.traceZRemove = false;\n  MergeTree.traceOrdinals = false;\n  MergeTree.traceGatherText = false;\n  MergeTree.diagInsertTie = false;\n  MergeTree.skipLeftShift = true;\n  MergeTree.diagOverlappingRemove = false;\n  MergeTree.traceTraversal = false;\n  MergeTree.traceIncrTraversal = false;\n  MergeTree.theUnfinishedNode = {\n    childCount: -1\n  };\n  MergeTree.blockUpdateMarkers = true;\n  return MergeTree;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}